{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698",
    "id": 2655159183,
    "node_id": "PR_kwDOAP4Jqs6eQoOP",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1698.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1698.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
    "number": 1698,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add BIP352 module (take 3)",
    "user": {
      "login": "josibake",
      "id": 7444140,
      "node_id": "MDQ6VXNlcjc0NDQxNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josibake",
      "html_url": "https://github.com/josibake",
      "followers_url": "https://api.github.com/users/josibake/followers",
      "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
      "organizations_url": "https://api.github.com/users/josibake/orgs",
      "repos_url": "https://api.github.com/users/josibake/repos",
      "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/josibake/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This PR implements [BIP352 - Silent payments](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). It is recommended to read through the BIP before reviewing this PR.\r\n\r\nThis is a continuation of the work in https://github.com/bitcoin-core/secp256k1/pull/1519 and only opened as a new PR due to the comment history on #1519 becoming quite long and difficult to sift through. It is recommended reviewers go through #1519 for background context, if interested.",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/9",
      "html_url": "https://github.com/bitcoin-core/secp256k1/milestone/9",
      "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/9/labels",
      "id": 13315105,
      "node_id": "MI_kwDOAP4Jqs4Ayywh",
      "number": 9,
      "state": "open",
      "title": "0.7.1",
      "description": "",
      "creator": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "open_issues": 3,
      "closed_issues": 1,
      "created_at": "2025-07-22T09:26:32Z",
      "updated_at": "2025-09-17T08:35:54Z",
      "due_on": "2025-10-17T07:00:00Z"
    },
    "created_at": "2025-07-10T08:53:21Z",
    "updated_at": "2025-09-22T16:30:22Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merged": false,
    "merge_commit_sha": "86e57be9d1be2b6b657ee4e536d7ede85ac7ea5f",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "josibake:bip352-silentpayments-module-2025",
      "ref": "bip352-silentpayments-module-2025",
      "sha": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 751433786,
        "node_id": "R_kgDOLMn4Og",
        "name": "secp256k1",
        "full_name": "josibake/secp256k1",
        "owner": {
          "login": "josibake",
          "id": 7444140,
          "node_id": "MDQ6VXNlcjc0NDQxNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/josibake",
          "html_url": "https://github.com/josibake",
          "followers_url": "https://api.github.com/users/josibake/followers",
          "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
          "organizations_url": "https://api.github.com/users/josibake/orgs",
          "repos_url": "https://api.github.com/users/josibake/repos",
          "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/josibake/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/josibake/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/josibake/secp256k1",
        "archive_url": "https://api.github.com/repos/josibake/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/josibake/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/josibake/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/josibake/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/josibake/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/josibake/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/josibake/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/josibake/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/josibake/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/josibake/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/josibake/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/josibake/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/josibake/secp256k1/events",
        "forks_url": "https://api.github.com/repos/josibake/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/josibake/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/josibake/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/josibake/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/josibake/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/josibake/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/josibake/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/josibake/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/josibake/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/josibake/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/josibake/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/josibake/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/josibake/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/josibake/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/josibake/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/josibake/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:josibake/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/josibake/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/josibake/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/josibake/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/josibake/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/josibake/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/josibake/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/josibake/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/josibake/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/josibake/secp256k1/hooks",
        "svn_url": "https://github.com/josibake/secp256k1",
        "language": "C",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 13743,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-09-22T11:30:28Z",
        "created_at": "2024-02-01T15:52:50Z",
        "updated_at": "2025-09-15T10:01:43Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "de6af6ae3568461edc9967500d7a70beeb66a642",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1090,
        "stargazers_count": 2308,
        "watchers_count": 2308,
        "size": 12678,
        "default_branch": "master",
        "open_issues_count": 156,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-09-22T10:21:40Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2025-09-22T13:56:21Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 8373,
    "deletions": 35,
    "changed_files": 23,
    "commits": 11,
    "review_comments": 246,
    "comments": 38
  },
  "events": [
    {
      "event": "reviewed",
      "id": 3005508488,
      "node_id": "PRR_kwDOAP4Jqs6zJGuI",
      "url": null,
      "actor": null,
      "commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-10T16:26:57Z",
      "author_association": "NONE",
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3005508488",
      "submitted_at": "2025-07-10T16:26:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18619898506,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARV1RqK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18619898506",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9e85256bbe527bf084222ee08dade9ea497d5c99",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/9e85256bbe527bf084222ee08dade9ea497d5c99",
      "created_at": "2025-07-14T14:54:07Z"
    },
    {
      "event": "commented",
      "id": 3069942270,
      "node_id": "IC_kwDOAP4Jqs62-5n-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3069942270",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:20Z",
      "updated_at": "2025-07-14T15:04:20Z",
      "author_association": "MEMBER",
      "body": "Updated [6264c3d](https://github.com/bitcoin-core/secp256k1/commit/6264c3d0939f2ab11ba8c92f3cb521f9c89c8596) -> [9e85256](https://github.com/bitcoin-core/secp256k1/commit/9e85256bbe527bf084222ee08dade9ea497d5c99) ([2025_00](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_00) -> [2025_01](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_01), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_00..bip352-silentpayments-module-2025_01))\r\n\r\n* Added documentation for expectations around `label_lookup` pointer lifetimes (h/t @antonilol)\r\n* Update docs to accurately reflect that `label_context` is optional (h/t @antonilol)\r\n* Added a test case for passing a lookup callback with a null context (which required some small updates to the test label lookup function)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3069942270",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18620089953,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARV2AZh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18620089953",
      "actor": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:20Z"
    },
    {
      "event": "subscribed",
      "id": 18620089990,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARV2AaG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18620089990",
      "actor": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:21Z"
    },
    {
      "event": "reviewed",
      "id": 3037944552,
      "node_id": "PRR_kwDOAP4Jqs61E1ro",
      "url": null,
      "actor": null,
      "commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-21T12:45:15Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3037944552",
      "submitted_at": "2025-07-21T12:45:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18729968570,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARcZKO6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18729968570",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a4db27946b6bdf165095348543e44d7cc4e45e1c",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/a4db27946b6bdf165095348543e44d7cc4e45e1c",
      "created_at": "2025-07-21T14:09:02Z"
    },
    {
      "event": "commented",
      "id": 3096975105,
      "node_id": "IC_kwDOAP4Jqs64mBcB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3096975105",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:15:58Z",
      "updated_at": "2025-07-21T14:15:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "Sorry, stopping CI here. We're about to make a release and need to the CI. :)\r\n\r\nWe'll restart the jobs here afterwards.  ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3096975105",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3096996582,
      "node_id": "IC_kwDOAP4Jqs64mGrm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3096996582",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:51Z",
      "updated_at": "2025-07-21T14:21:51Z",
      "author_association": "MEMBER",
      "body": "Update [9e85256](https://github.com/bitcoin-core/secp256k1/commit/9e85256bbe527bf084222ee08dade9ea497d5c99) -> [a4db279](https://github.com/bitcoin-core/secp256k1/commit/a4db27946b6bdf165095348543e44d7cc4e45e1c) ([2025_01](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_01) -> [2025_02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_01..bip352-silentpayments-module-2025_02))\r\n\r\n* Update the constant time tests to cover the `_recipient_created_shared_secret` and `_recipient_created_output_pubkey` functions (h/t @theStack )\r\n* Remove no longer needed TODO comments and clarify why a constant time test without a label lookup function is sufficient for `_recipient_scan_outputs`",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3096996582",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18730266172,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARcaS48",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18730266172",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:52Z"
    },
    {
      "event": "subscribed",
      "id": 18730266200,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARcaS5Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18730266200",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18749002077,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARdhxFd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18749002077",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e35bedeca6318011afbd59bba6f412a85c33e134",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/e35bedeca6318011afbd59bba6f412a85c33e134",
      "created_at": "2025-07-22T10:27:59Z"
    },
    {
      "event": "commented",
      "id": 3102130501,
      "node_id": "IC_kwDOAP4Jqs645sFF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3102130501",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-22T10:29:47Z",
      "updated_at": "2025-07-22T10:29:47Z",
      "author_association": "MEMBER",
      "body": "Rebased on top of 0.7.0 release :tada: [a4db279](https://github.com/bitcoin-core/secp256k1/commit/a4db27946b6bdf165095348543e44d7cc4e45e1c) -> [e35bede](https://github.com/bitcoin-core/secp256k1/commit/e35bedeca6318011afbd59bba6f412a85c33e134) ([2025_02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02) -> [2025_02_rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02_rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_02..bip352-silentpayments-module-2025_02_rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3102130501",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3102274260,
      "node_id": "IC_kwDOAP4Jqs646PLU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3102274260",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-22T11:13:33Z",
      "updated_at": "2025-07-22T11:13:33Z",
      "author_association": "MEMBER",
      "body": "I did a deep dive on using `(*arg)[size]` in this PR and opened https://github.com/bitcoin-core/secp256k1/issues/1710 for discussion, since this is a broader topic than just this PR. The relevant changes for here and the downstream Bitcoin Core PRs are https://github.com/josibake/secp256k1/commit/5a1088066b2ce5e2e77b4e4bc190575d1171c374 and https://github.com/josibake/bitcoin/commit/5835d987477fc8eae391e4d1cc5033d921925ea1",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3102274260",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "labeled",
      "id": 18768558526,
      "node_id": "LE_lADOAP4Jqs6_1gh3zwAAAAResXm-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18768558526",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-23T08:17:16Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "reviewed",
      "id": 3047815175,
      "node_id": "PRR_kwDOAP4Jqs61qfgH",
      "url": null,
      "actor": null,
      "commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-23T14:51:40Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3047815175",
      "submitted_at": "2025-07-23T14:51:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18794190282,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARgOJXK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794190282",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "created_at": "2025-07-24T12:18:04Z"
    },
    {
      "event": "commented",
      "id": 3113267037,
      "node_id": "IC_kwDOAP4Jqs65kK9d",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3113267037",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:16Z",
      "updated_at": "2025-07-24T12:23:16Z",
      "author_association": "MEMBER",
      "body": "Updated [e35bede](https://github.com/bitcoin-core/secp256k1/commit/e35bedeca6318011afbd59bba6f412a85c33e134) -> [1a84908](https://github.com/bitcoin-core/secp256k1/commit/1a84908cdac60d7313a8d5faee470ce8e2c1c763) ([2025_02_rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02_rebase) -> [2025_03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_03), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_02_rebase..bip352-silentpayments-module-2025_03))\r\n\r\n* Added a test case for the `_recipient_create_output_pubkey` corner case (h/t @theStack)\r\n* Removed the `VERIFY_CHECK` in favour of returning an error",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3113267037",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18794275408,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARgOeJQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794275408",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:17Z"
    },
    {
      "event": "subscribed",
      "id": 18794275428,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARgOeJk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794275428",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:17Z"
    },
    {
      "event": "reviewed",
      "id": 3053302400,
      "node_id": "PRR_kwDOAP4Jqs61_bKA",
      "url": null,
      "actor": null,
      "commit_id": "1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-24T21:35:51Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3053302400",
      "submitted_at": "2025-07-24T21:35:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18811001330,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARhORny",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811001330",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "created_at": "2025-07-25T09:16:34Z"
    },
    {
      "event": "commented",
      "id": 3117040572,
      "node_id": "IC_kwDOAP4Jqs65ykO8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3117040572",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:23Z",
      "updated_at": "2025-07-25T09:20:23Z",
      "author_association": "MEMBER",
      "body": "Update [1a84908](https://github.com/bitcoin-core/secp256k1/commit/1a84908cdac60d7313a8d5faee470ce8e2c1c763) -> [2948a9b](https://github.com/bitcoin-core/secp256k1/commit/2948a9bf619ba97a0acf38056e6b27005448ebb6) ([2025_03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_03) -> [2025_04](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_04), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_03..bip352-silentpayments-module-2025_04))\r\n\r\n* Fixed valgrind error in test\r\n* Update the example to use `EXIT_SUCCESS`/`EXIT_FAILURE` (h/t @theStack)\r\n* Clear shared secret variable consistently (and update comment) (h/t @theStack)\r\n* Add comment explaining why we declassify the pubkey sum (h/t @theStack)\r\n\r\nThanks for the thorough review, @theStack !",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3117040572",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18811062137,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhOgd5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811062137",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:24Z"
    },
    {
      "event": "subscribed",
      "id": 18811062166,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhOgeW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811062166",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18815902894,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARhg-Su",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18815902894",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "64ecd6c01d394fbdd8902a5d7f3f297a76d5f570",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570",
      "created_at": "2025-07-25T14:25:54Z"
    },
    {
      "event": "commented",
      "id": 3118116695,
      "node_id": "IC_kwDOAP4Jqs652q9X",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3118116695",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:30Z",
      "updated_at": "2025-07-25T14:33:30Z",
      "author_association": "MEMBER",
      "body": "Update [2948a9b](https://github.com/bitcoin-core/secp256k1/commit/2948a9bf619ba97a0acf38056e6b27005448ebb6) -> [64ecd6c](https://github.com/bitcoin-core/secp256k1/commit/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570) ([2025_04](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_04) -> [2025_05](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_05), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_04..bip352-silentpayments-module-2025_05))\r\n* Remove no longer needed TODO comment regarding `_cmov`\r\n* Remove todo comment regarding `input_hash`, now that this is [properly specified](https://github.com/bitcoin/bips/pull/1902) in the BIP\r\n\r\ncc @jonasnick and @real-or-random regarding the use of a `VERIFY_CHECK` in favour of returning an error, when returning an error results in an untestable branch. I'm happy with the approach here were we use a `VERIFY_CHECK` for `input_hash` and `t_k` to check for an overflow of the curve order. However, given this is something we've discussed a few times in the post, would be great to hear your thoughts on this and I'm happy to defer to whatever you both think is best.\r\n\r\nThis should address all of the outstanding TODOs (at least the ones we left comments for 😅 )",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3118116695",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18816034806,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhhef2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034806",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "subscribed",
      "id": 18816034824,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhhegI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034824",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "mentioned",
      "id": 18816034846,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhhege",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034846",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "subscribed",
      "id": 18816034872,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhheg4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034872",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "reviewed",
      "id": 3062729343,
      "node_id": "PRR_kwDOAP4Jqs62jYp_",
      "url": null,
      "actor": null,
      "commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-28T13:27:28Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3062729343",
      "submitted_at": "2025-07-28T13:27:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18861898456,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARkQbrY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861898456",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "created_at": "2025-07-28T18:01:49Z"
    },
    {
      "event": "commented",
      "id": 3128406259,
      "node_id": "IC_kwDOAP4Jqs66d7Dz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3128406259",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:21Z",
      "updated_at": "2025-07-28T18:06:21Z",
      "author_association": "MEMBER",
      "body": "Updated [64ecd6c](https://github.com/bitcoin-core/secp256k1/commit/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570) -> [3c4af8f](https://github.com/bitcoin-core/secp256k1/commit/3c4af8fee015bb8b10f53ae560d83ab51738b838) ([2025_05](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_05) -> [2025_06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_06), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_05..bip352-silentpayments-module-2025_06))\r\n\r\n* Updates the benchmarks per @theStack 's suggestion to have separate benchmarks for `_full_scan` and `full_scan_with_labels`\r\n* Leave a TODO comment for a follow-up to make the labels benchmark more representative of real world usage\r\n* Cleans up the benchmark arguments and formatting",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3128406259",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18861996956,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARkQzuc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861996956",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:22Z"
    },
    {
      "event": "subscribed",
      "id": 18861996990,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARkQzu-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861996990",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:22Z"
    },
    {
      "event": "reviewed",
      "id": 3073577403,
      "node_id": "PRR_kwDOAP4Jqs63MxG7",
      "url": null,
      "actor": null,
      "commit_id": "3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-30T23:49:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "In the CI commit, could add the silent payments module also to the native macOS arm64 job (as done for musig recently in #1699), e.g.\r\n\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml\r\nindex 8ee13ce..f612a84 100644\r\n--- a/.github/workflows/ci.yml\r\n+++ b/.github/workflows/ci.yml\r\n@@ -583,13 +583,13 @@ jobs:\r\n       fail-fast: false\r\n       matrix:\r\n         env_vars:\r\n-          - { WIDEMUL: 'int64',  RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n+          - { WIDEMUL: 'int64',  RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n           - { WIDEMUL: 'int128_struct', ECMULTGENPRECISION: 2, ECMULTWINDOW: 4 }\r\n-          - { WIDEMUL: 'int128',                  ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n+          - { WIDEMUL: 'int128',                  ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n           - { WIDEMUL: 'int128', RECOVERY: 'yes' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', CC: 'gcc' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', CPPFLAGS: '-DVERIFY' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes', CC: 'gcc' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes', CPPFLAGS: '-DVERIFY' }\r\n           - BUILD: 'distcheck'\r\n \r\n     steps:\r\n\r\n```\r\n</details>\r\n(untested)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3073577403",
      "submitted_at": "2025-07-30T23:49:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18915784215,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARnd_YX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915784215",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "eb32d06a936307fcce649cf8002e49e6f8730948",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/eb32d06a936307fcce649cf8002e49e6f8730948",
      "created_at": "2025-07-31T09:51:58Z"
    },
    {
      "event": "commented",
      "id": 3139313124,
      "node_id": "IC_kwDOAP4Jqs67Hh3k",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3139313124",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:11Z",
      "updated_at": "2025-07-31T10:04:11Z",
      "author_association": "MEMBER",
      "body": "Updated [3c4af8f](https://github.com/bitcoin-core/secp256k1/commit/3c4af8fee015bb8b10f53ae560d83ab51738b838) -> [eb32d06](https://github.com/bitcoin-core/secp256k1/commit/eb32d06a936307fcce649cf8002e49e6f8730948) ([2025_06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_06) -> [2025_07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_07), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_06..bip352-silentpayments-module-2025_07))\r\n\r\n* Enable macOS arm64 jobs in the CI (h/t @theStack)\r\n* Fix return value in the example (h/t @theStack)\r\n* Improve test coverage (100% function and branch coverage 💪)\r\n* Simplify public data functions\r\n\r\nWhile working through the test coverage, I realised the two public data internal functions `public_data_load_pubkey` and `public_data_load_input_hash` are unnecessary, as they were just thin wrappers around secp256k1 function calls that never return an error.\r\n\r\nI've removed those functions and instead ensured we always check a public data object for correctness before accessing the internals.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3139313124",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18915995135,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARney3_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915995135",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:12Z"
    },
    {
      "event": "subscribed",
      "id": 18915995173,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARney4l",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915995173",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:13Z"
    },
    {
      "event": "reviewed",
      "id": 3075428613,
      "node_id": "PRR_kwDOAP4Jqs63T1EF",
      "url": null,
      "actor": null,
      "commit_id": "eb32d06a936307fcce649cf8002e49e6f8730948",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-31T15:31:13Z",
      "author_association": "MEMBER",
      "body": "Reviewed eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_ again and it looks good to me (not a C expert). Comments mainly about documentation and one variable name suggestion.\r\n\r\nIt could make sense to split  993d34b7ae3d4a8b6d3a8957b309b38e7e50e796 _tests: add BIP-352 test vectors_ and move the send-side tests directly after this commit. Ditto for the send example in ce7cb982d4aceefd8bb8591fd069c3a0b81d1ef2 _silentpayments: add examples/silentpayments.c_.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3075428613",
      "submitted_at": "2025-07-31T15:24:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18936863463,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARouZrn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936863463",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "created_at": "2025-08-01T10:29:26Z"
    },
    {
      "event": "commented",
      "id": 3144097162,
      "node_id": "IC_kwDOAP4Jqs67Zx2K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3144097162",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:46Z",
      "updated_at": "2025-08-01T10:34:46Z",
      "author_association": "MEMBER",
      "body": "Updated [eb32d06](https://github.com/bitcoin-core/secp256k1/commit/eb32d06a936307fcce649cf8002e49e6f8730948) -> [b26c87d](https://github.com/bitcoin-core/secp256k1/commit/b26c87d5c09ddefe764a9cad6a8612e34ccd13de) ([2025_07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_07) -> [2025_08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_08), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_07..bip352-silentpayments-module-2025_08))\r\n\r\n* Updated sending API docs (h/t @Sjors)\r\n* Updated comments and improved variable naming for sending (h/t @Sjors)\r\n\r\nThanks for the review, @Sjors !",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3144097162",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18936947911,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARouuTH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936947911",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:47Z"
    },
    {
      "event": "subscribed",
      "id": 18936947932,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARouuTc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936947932",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:47Z"
    },
    {
      "event": "unsubscribed",
      "id": 18937315173,
      "node_id": "UE_lADOAP4Jqs6_1gh3zwAAAARowH9l",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18937315173",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:55:46Z"
    },
    {
      "event": "commented",
      "id": 3144198707,
      "node_id": "IC_kwDOAP4Jqs67aKoz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3144198707",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T11:10:03Z",
      "updated_at": "2025-08-01T11:10:03Z",
      "author_association": "MEMBER",
      "body": "> It could make sense to split https://github.com/bitcoin-core/secp256k1/commit/993d34b7ae3d4a8b6d3a8957b309b38e7e50e796 tests: add BIP-352 test vectors and move the send-side tests directly after this commit. Ditto for the send example in https://github.com/bitcoin-core/secp256k1/commit/ce7cb982d4aceefd8bb8591fd069c3a0b81d1ef2 silentpayments: add examples/silentpayments.c.\r\n\r\nBy splitting the test vectors commit into sending and receiving commits, it would be possible to break out just sending into its own PR (recall that sending can be implemented without implementing receiving). If this makes it easier to review and merge sending, I'm open to it. This would allow downstream work on the Bitcoin Core sending PR to proceed, while continued review on receiving happens here.\r\n\r\nOn the flipside, I do feel like the module in its current state is close to finished so I'm not sure how much benefit splitting at this stage would bring. I dropped a note in the `#secp256k1` IRC; will wait to hear from other reviewers/maintainers before making a decision here.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3144198707",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "reviewed",
      "id": 3087942073,
      "node_id": "PRR_kwDOAP4Jqs64DkG5",
      "url": null,
      "actor": null,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-05T13:33:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "Left some comments with minor suggestions regarding API header and the example, I'm planning to finish the full review this week.\r\n\r\nNo strong opinion on whether a split-up into sending/receiving PRs makes sense, from a reviewing point of view it likely doesn't make a difference for me at this point. I could imagine it's potentially brittle to only release the sending part if there is no strong test coverage provided that the generated outputs can also be found by receivers, so I'd slightly lean to keep as-is, I guess.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3087942073",
      "submitted_at": "2025-08-05T13:33:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19008541221,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARs_1Il",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19008541221",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "393a2a28c52274ae99fa2271116df2c7b2e4e4b8",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/393a2a28c52274ae99fa2271116df2c7b2e4e4b8",
      "created_at": "2025-08-06T09:06:40Z"
    },
    {
      "event": "commented",
      "id": 3158508760,
      "node_id": "IC_kwDOAP4Jqs68QwTY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3158508760",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T09:15:30Z",
      "updated_at": "2025-08-06T09:15:30Z",
      "author_association": "MEMBER",
      "body": "Updated [b26c87d](https://github.com/bitcoin-core/secp256k1/commit/b26c87d5c09ddefe764a9cad6a8612e34ccd13de) -> [393a2a2](https://github.com/bitcoin-core/secp256k1/commit/393a2a28c52274ae99fa2271116df2c7b2e4e4b8) ([2025_08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_08) -> [2025_09](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_09), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_08..bip352-silentpayments-module-2025_09))\r\n\r\n* Various `example` fix-ups (h/t @theStack)\r\n* `s/outpoint_smallest/outpoint_smallest36/` (h/t @theStack )\r\n* `s/P_output_xonly/output_xonly/` (h/t @theStack )\r\n\r\n@theStack thanks for the continued review!\r\n\r\n> I could imagine it's potentially brittle to only release the sending part if there is no strong test coverage provided that the generated outputs can also be found by receivers\r\n\r\nFor this, I think it would be sufficient to show that the same inputs/outputs from the test vectors used in the sending PR are the same ones used in the receiving PR. But overall, I'm also leaning towards keeping everything together unless its expected that the sending commit is largely good to go but more review is required for the benchmarks, example, and receiving commits.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3158508760",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19008766208,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARtAsEA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19008766208",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T09:15:31Z"
    },
    {
      "event": "subscribed",
      "id": 19008766248,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARtAsEo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19008766248",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T09:15:32Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19011036759,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARtJWZX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011036759",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "96b2362337c4203fad9ef1690c8e60b7db2aa571",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/96b2362337c4203fad9ef1690c8e60b7db2aa571",
      "created_at": "2025-08-06T11:21:46Z"
    },
    {
      "event": "commented",
      "id": 3159769239,
      "node_id": "IC_kwDOAP4Jqs68VkCX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3159769239",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:01Z",
      "updated_at": "2025-08-06T11:27:01Z",
      "author_association": "MEMBER",
      "body": "Updated [393a2a2](https://github.com/bitcoin-core/secp256k1/commit/393a2a28c52274ae99fa2271116df2c7b2e4e4b8) -> [96b2362](https://github.com/bitcoin-core/secp256k1/commit/96b2362337c4203fad9ef1690c8e60b7db2aa571) ([2025_09](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_09) -> [2025_10](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_10), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_09..bip352-silentpayments-module-2025_10))\r\n\r\n* Add asserts in example (h/t @theStack )\r\n* Update header to better document how functions can fail\r\n\r\ncc @real-or-random @jonasnick on the header documentation. A majority of the error cases are can only happen if the user provides malformed inputs, or the output of a hash function results in something greater than the curve order. I opted to document these, but wanted to confirm to make sure I am doing something consistent with the rest of the library.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3159769239",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19011125434,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARtJsC6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125434",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:02Z"
    },
    {
      "event": "subscribed",
      "id": 19011125453,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARtJsDN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125453",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "mentioned",
      "id": 19011125470,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARtJsDe",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125470",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "subscribed",
      "id": 19011125488,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARtJsDw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125488",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "mentioned",
      "id": 19011125511,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARtJsEH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125511",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "subscribed",
      "id": 19011125538,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARtJsEi",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125538",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "reviewed",
      "id": 3101192531,
      "node_id": "PRR_kwDOAP4Jqs642HFT",
      "url": null,
      "actor": null,
      "commit_id": "96b2362337c4203fad9ef1690c8e60b7db2aa571",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-08T15:58:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've convinced myself that the implementation in this PR matches the BIP352 specification and the usual quality requirements, especially regarding treatment of secret data (constant-time ops, clearing out the memory) are met from what I can tell.\r\n\r\nThe remaining comments are just nits for typos/minimizing-diff and a general question about the detail level of header API documentation. Other than that, I think I'd be ready to give a \"take it with a grain of salt, i'm not a cryptographer\"-ACK at this point :detective: ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3101192531",
      "submitted_at": "2025-08-08T15:58:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19082797827,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARxbGMD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19082797827",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd",
      "created_at": "2025-08-11T08:28:15Z"
    },
    {
      "event": "commented",
      "id": 3173754156,
      "node_id": "IC_kwDOAP4Jqs69K6Us",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3173754156",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T08:31:56Z",
      "updated_at": "2025-08-11T08:31:56Z",
      "author_association": "MEMBER",
      "body": "Updated [96b2362](https://github.com/bitcoin-core/secp256k1/commit/96b2362337c4203fad9ef1690c8e60b7db2aa571) -> [142f07b](https://github.com/bitcoin-core/secp256k1/commit/142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd) ([2025_10](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_10) -> [2025_11](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_11), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_10..bip352-silentpayments-module-2025_11))\r\n\r\n* Spelling and documentation fixes, (h/t @theStack)\r\n\r\nThanks again, @theStack, for the thorough review! Much appreciated.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3173754156",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19082863576,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARxbWPY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19082863576",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T08:31:57Z"
    },
    {
      "event": "subscribed",
      "id": 19082863602,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARxbWPy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19082863602",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T08:31:58Z"
    },
    {
      "event": "reviewed",
      "id": 3107973701,
      "node_id": "PRR_kwDOAP4Jqs65P-pF",
      "url": null,
      "actor": null,
      "commit_id": "142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T00:32:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "Left some more nitty findings below.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3107973701",
      "submitted_at": "2025-08-12T00:32:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19107953674,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARy7DwK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19107953674",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "created_at": "2025-08-12T09:36:53Z"
    },
    {
      "event": "commented",
      "id": 3178575124,
      "node_id": "IC_kwDOAP4Jqs69dTUU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3178575124",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T09:40:47Z",
      "updated_at": "2025-08-12T09:40:47Z",
      "author_association": "MEMBER",
      "body": "Updated [142f07b](https://github.com/bitcoin-core/secp256k1/commit/142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd) -> [2b57d2a](https://github.com/bitcoin-core/secp256k1/commit/2b57d2ad8964e536508fae0b6ab1331396fe0308) ([2025_11](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_11) -> [2025_12](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_12), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_11..bip352-silentpayments-module-2025_12))\r\n\r\n* Documentation fixes (h/t @theStack)\r\n* Added `VERIFY_CHECK` and more consistent `ret` (h/t @theStack)\r\n* Removed dead code from tests and improved legibility (h/t @theStack)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3178575124",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19108044316,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARy7Z4c",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19108044316",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T09:40:49Z"
    },
    {
      "event": "subscribed",
      "id": 19108044368,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARy7Z5Q",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19108044368",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T09:40:49Z"
    },
    {
      "event": "reviewed",
      "id": 3109600166,
      "node_id": "PRR_kwDOAP4Jqs65WLum",
      "url": null,
      "actor": null,
      "commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T10:52:00Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3109600166",
      "submitted_at": "2025-08-12T10:52:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3109923614,
      "node_id": "PRR_kwDOAP4Jqs65Xase",
      "url": null,
      "actor": null,
      "commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T11:01:38Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3109923614",
      "submitted_at": "2025-08-12T11:01:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3111636132,
      "node_id": "PRR_kwDOAP4Jqs65d8yk",
      "url": null,
      "actor": null,
      "commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T15:59:43Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3111636132",
      "submitted_at": "2025-08-12T15:59:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19158775745,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAAR187fB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19158775745",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a428424b3ec43ae46d30191e35d8a0b719a78298",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/a428424b3ec43ae46d30191e35d8a0b719a78298",
      "created_at": "2025-08-14T12:45:15Z"
    },
    {
      "event": "commented",
      "id": 3188346146,
      "node_id": "IC_kwDOAP4Jqs6-Ck0i",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3188346146",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-14T12:51:44Z",
      "updated_at": "2025-08-14T12:51:44Z",
      "author_association": "MEMBER",
      "body": "Updated [2b57d2a](https://github.com/bitcoin-core/secp256k1/commit/2b57d2ad8964e536508fae0b6ab1331396fe0308) -> [a428424](https://github.com/bitcoin-core/secp256k1/commit/a428424b3ec43ae46d30191e35d8a0b719a78298) ([2025_12](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_12) -> [2025_13](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_13), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_12..bip352-silentpayments-module-2025_13))\r\n\r\n* Remove extra check to make the autotools build system consistent with other modules (h/t @real-or-random )\r\n* Various wording fix-ups (h/t @real-or-random)\r\n* Use `spend_pubkey` to indicate a spend public key that might also have a tweak and `unlabeled_spend_pubkey` we mean to refer the unlabeled spend public key (vs `labeled_spend_pubkey` and `spend_pubkey`) (h/t @real-or-random )\r\n* Reword the sending API docs to avoid mentioning \"sorting\"\r\n\r\nThanks for the review @real-or-random , much prefer your wording suggestions. I pushed a version of the docs that I think helps minimise confusion about sorting, but curious to hear your thoughts as I imagine these docs will still need a bit of refining.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3188346146",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19158899014,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAAR19ZlG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19158899014",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-14T12:51:45Z"
    },
    {
      "event": "subscribed",
      "id": 19158899043,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAAR19Zlj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19158899043",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-14T12:51:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19174245343,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAAR238Pf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19174245343",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "created_at": "2025-08-15T10:21:13Z"
    },
    {
      "event": "commented",
      "id": 3191203100,
      "node_id": "IC_kwDOAP4Jqs6-NeUc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3191203100",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T10:26:27Z",
      "updated_at": "2025-08-15T10:26:27Z",
      "author_association": "MEMBER",
      "body": "Updated [a428424](https://github.com/bitcoin-core/secp256k1/commit/a428424b3ec43ae46d30191e35d8a0b719a78298) -> [99aef92](https://github.com/bitcoin-core/secp256k1/commit/99aef9204636f04cf689d13eeb365f4f2e3a1568) ([2025_13](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_13) -> [2025_14](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_14), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_13..bip352-silentpayments-module-2025_14))\r\n\r\n* Add tests for the tagged hash midstates used in silent payments (h/t @real-or-random )\r\n\r\nThe first commit moves the convenience function for verifying tagged hashes out of the musig module and is pulled in from https://github.com/bitcoin-core/secp256k1/pull/1725. ",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3191203100",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19174314490,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAAR24NH6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19174314490",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T10:26:29Z"
    },
    {
      "event": "subscribed",
      "id": 19174314504,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAAR24NII",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19174314504",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T10:26:29Z"
    },
    {
      "event": "commented",
      "id": 3199776826,
      "node_id": "IC_kwDOAP4Jqs6-uLg6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3199776826",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-19T08:32:41Z",
      "updated_at": "2025-08-19T08:33:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've made my way through sending (ignoring the public header for now) and I pushed some suggestions for fixups here: https://github.com/bitcoin-core/secp256k1/compare/master...real-or-random:secp256k1:bip352-silentpayments-module-2025-sending-fixups (and some fixups also to receiving, I hope I always picked the right commit to fixup). See commit messages for rationale. Some of these may be opinionated, so feel free to reject, disagree, or adjust.  ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3199776826",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "reviewed",
      "id": 3131312139,
      "node_id": "PRR_kwDOAP4Jqs66pAgL",
      "url": null,
      "actor": null,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-19T08:35:52Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3131312139",
      "submitted_at": "2025-08-19T08:35:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3135696764,
      "node_id": "PRR_kwDOAP4Jqs665u98",
      "url": null,
      "actor": null,
      "commit_id": "090f3839637c2be990e283360aaa639c0018e288",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-20T09:41:22Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3135696764",
      "submitted_at": "2025-08-20T09:41:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19242291688,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAAR67hHo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19242291688",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "created_at": "2025-08-20T09:59:48Z"
    },
    {
      "event": "commented",
      "id": 3205345165,
      "node_id": "IC_kwDOAP4Jqs6_Da-N",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3205345165",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T10:09:32Z",
      "updated_at": "2025-08-20T10:09:32Z",
      "author_association": "MEMBER",
      "body": "Updated [99aef92](https://github.com/bitcoin-core/secp256k1/commit/99aef9204636f04cf689d13eeb365f4f2e3a1568) -> [2164d5c](https://github.com/bitcoin-core/secp256k1/commit/2164d5cfe15ad92641d3ddbf9f664af088a33578) ([2025_14](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_14) -> [2025_15](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_15), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_14..bip352-silentpayments-module-2025_15))\r\n\r\nPrimarily updates the sending commit, with a few changes to the receiving commit:\r\n\r\n* Rebased on https://github.com/bitcoin-core/secp256k1/pull/1725\r\n* IWYU (h/t @real-or-random )\r\n* Improve comments regarding the scan key, i.e., stop referring to it as \"secret-but-not-really\" and explicitly mention what happens if the scan key is leaked (h/t @real-or-random )\r\n* Use the more precise terminology \"negligible probability\" (h/t @real-or-random and crypto camp, where this has been explained! 😄 )\r\n* General wording, clarity improvements for the code/comments\r\n\r\nThanks for the thorough review, @real-or-random ! I reviewed each fixup commit and ended up taking all of them, as I agree with the rational and much prefer the wording(s) you suggested. Also, thanks for the `fixup!` branch; the branch made it super simple to integrate your changes.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3205345165",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19242470148,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAAR68MsE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19242470148",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T10:09:33Z"
    },
    {
      "event": "subscribed",
      "id": 19242470165,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAAR68MsV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19242470165",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T10:09:33Z"
    },
    {
      "event": "referenced",
      "id": 19260639375,
      "node_id": "REFE_lADOAP4Jqs6_1gh3zwAAAAR8BgiP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19260639375",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f36afb8b3dd7daf9edf4bf15c49fcd540f8ce393",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/f36afb8b3dd7daf9edf4bf15c49fcd540f8ce393",
      "created_at": "2025-08-21T07:56:31Z"
    },
    {
      "event": "reviewed",
      "id": 3150297518,
      "node_id": "PRR_kwDOAP4Jqs67xbmu",
      "url": null,
      "actor": null,
      "commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-25T07:45:47Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3150297518",
      "submitted_at": "2025-08-25T07:45:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3150490792,
      "node_id": "PRR_kwDOAP4Jqs67yKyo",
      "url": null,
      "actor": null,
      "commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-25T10:33:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "I attached some high-level comments on the receiver API. I think these should be addressed before I dig deeper into the receiving code.\n\nSome style things:\n\nFull sentences in the comments should end with a period for readability (with the exception that short imperatives are fine). In some sentences my brain really expects more input after the end of the comment, e.g., \"Additionally, we zero out the 32 bytes where the input_hash would be\" (What would the hash be? :D)\n\nAnd I'd prefer to avoid \"formula-style\" variable names like `A_sum`, `B_m`, `P_output`, and `t_k` in code. (The latter is borderline, I guess; at least it's not capital.) Sometimes these appear only in the comments, but that can be confusing then because there are two names for the same thing, e.g., `recipient_spend_pubkey` vs `B_spend`. I think most (all?) of these can be resolved by replacing \"A\" with \"input\" or \"sender,\" as appropriate, and \"B\" with \"receiver.\" \n\nOn the other hand, having a \"normal\" variable name in the code but also the formula-style name in the comments or API docs may be a good idea if you assume that the reader/user is familiar with the BIP. But then I'd make it explicit in the comments, e.g., have a translation table somewhere (could even be a general comment at the top of the file) or say something like \"recipient_spending_key (\"B_spend\" in the BIP)\" whenever a variable occurs first in a comment.\n\nTo be honest, I'm not sure if it's better to keep this connection to the BIP or avoid it entirely. An ideal API would be understandable without the BIP, but since the API covers only the cryptographic core of SP, any user will necessarily need to know some details from the BIP that go beyond what the API will do.\n  \n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3150490792",
      "submitted_at": "2025-08-25T10:33:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "commented",
      "id": 3237867979,
      "node_id": "IC_kwDOAP4Jqs7A_fHL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3237867979",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-29T18:30:38Z",
      "updated_at": "2025-08-31T08:17:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "I pushed some (totally non-essential) fixup suggestions for the Python code to https://github.com/real-or-random/secp256k1/tree/bip352-silentpayments-module-2025-vector-fixups .\r\n\r\n---\r\n\r\nRelated to this: I see why we need the ripemd160 and bech32m Python modules to parse addresses from the test vectors JSON file. This feels a bit wrong. This SP module covers some cryptographic core of SP, which does not deal with address encoding issues. So these files belong to full wallet implementations such as Bitcoin Core (where you got them from, I assume). \r\n\r\nThe only way around this that I see is that the intermediate results computed from the addresses (i.e., the extracted input pubkeys) would additionally be included in the JSON file. Do you think that would be a reasonable solution and acceptable from your point of view as a BIP author? Are there any drawbacks to this? I don't see any, but I might be missing something.\r\n\r\nedit: Oh, or we could compute the input pubkeys from the seckeys in the JSON. Preferably in the C tests because this will require no Python EC code.\r\n\r\n(It's not the end of the world to have this in our repo. I think this is my tendency as a maintainer to avoid code. The more code we have, the more we'll need to maintain.)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3237867979",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3242137276,
      "node_id": "IC_kwDOAP4Jqs7BPxa8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3242137276",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-01T12:14:36Z",
      "updated_at": "2025-09-01T12:14:36Z",
      "author_association": "MEMBER",
      "body": "> Some style things:\r\n\r\nThanks for the feedback! Agree with all of your points and will implement. Regarding keeping notation in line with the BIP or removing entirely, I'd prefer to avoid the BIP as much as possible. As you said, the API should be understandable without the BIP.\r\n\r\nHow the BIP and module are written today is more of a historic \"oopsie.\" Ideally, the protocol should have been specified in a more module way, i.e., a cryptographic primitive (lets call it \"non-interactive-payment\", or \"multiparty ECDH\") and then a Bitcoin specific BIP that specifies how to use this NIP/MPECDH crypto primitive in a bitcoin specific context.\r\n\r\nTLDR; I think we should keep this module more aligned with how things \"should\" have been done.\r\n\r\n> intermediate results computed from the addresses (i.e., the extracted input pubkeys) would additionally be included in the JSON file. Do you think that would be a reasonable solution and acceptable from your point of view as a BIP author? Are there any drawbacks to this? I don't see any, but I might be missing something.\r\n\r\nRegarding the tests, I'd love to rip out all the Bitcoin specific python code. I dont see any drawbacks toward including intermediary results in the test files, and this would also be useful for index builders wishing to reuse the same set of test vectors. I've had a TODO for awhile now to update the BIP test vectors; I'll prioritise that work and update the PR here.\r\n\r\n---\r\n\r\nAs always, thanks for the thorough review! I had one [question](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2313736277) that I'd like your input on, otherwise I'll work on implementing the rest of your feedback over the next couple days.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3242137276",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19480204288,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASJHFQA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19480204288",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/bd745e1a06e85d121faacd020709303f62a55766",
      "created_at": "2025-09-03T11:31:01Z"
    },
    {
      "event": "commented",
      "id": 3248858893,
      "node_id": "IC_kwDOAP4Jqs7BpacN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3248858893",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-03T11:33:20Z",
      "updated_at": "2025-09-03T11:33:20Z",
      "author_association": "MEMBER",
      "body": "Rebased [2164d5c](https://github.com/bitcoin-core/secp256k1/commit/2164d5cfe15ad92641d3ddbf9f664af088a33578) -> [bd745e1](https://github.com/bitcoin-core/secp256k1/commit/bd745e1a06e85d121faacd020709303f62a55766) ([2025_15](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_15) -> [2025_15-rebased](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_15-rebased), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_15..bip352-silentpayments-module-2025_15-rebased))\r\n\r\nRebased on master to include https://github.com/bitcoin-core/secp256k1/pull/1725",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3248858893",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "reviewed",
      "id": 3182825179,
      "node_id": "PRR_kwDOAP4Jqs69tg7b",
      "url": null,
      "actor": null,
      "commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-03T22:58:46Z",
      "author_association": "NONE",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3182825179",
      "submitted_at": "2025-09-03T22:58:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3182850012,
      "node_id": "PRR_kwDOAP4Jqs69tm_c",
      "url": null,
      "actor": null,
      "commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-03T23:13:02Z",
      "author_association": "NONE",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3182850012",
      "submitted_at": "2025-09-03T23:13:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3182904552,
      "node_id": "PRR_kwDOAP4Jqs69t0To",
      "url": null,
      "actor": null,
      "commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-03T23:43:48Z",
      "author_association": "NONE",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3182904552",
      "submitted_at": "2025-09-03T23:43:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3182935500,
      "node_id": "PRR_kwDOAP4Jqs69t73M",
      "url": null,
      "actor": null,
      "commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-04T00:11:25Z",
      "author_association": "NONE",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3182935500",
      "submitted_at": "2025-09-04T00:11:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19501837999,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASKZm6v",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19501837999",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d7281b95add5eef82287327e7c4313cb2ffacb9d",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/d7281b95add5eef82287327e7c4313cb2ffacb9d",
      "created_at": "2025-09-04T11:13:05Z"
    },
    {
      "event": "commented",
      "id": 3253233041,
      "node_id": "IC_kwDOAP4Jqs7B6GWR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3253233041",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T11:25:17Z",
      "updated_at": "2025-09-04T11:25:17Z",
      "author_association": "MEMBER",
      "body": "Updated [bd745e1](https://github.com/bitcoin-core/secp256k1/commit/bd745e1a06e85d121faacd020709303f62a55766) -> [d7281b9](https://github.com/bitcoin-core/secp256k1/commit/d7281b95add5eef82287327e7c4313cb2ffacb9d) ([2025_15-rebased](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_15-rebased) -> [2025_16](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_16), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_15-rebased..bip352-silentpayments-module-2025_16))\r\n\r\n* Removed the workaround for the valgrind false positive :tada:\r\n* `s/public_data/prevout_summary/` (h/t @real-or-random)\r\n* Update functions that either output or take a `prevout_summary` object as input to be a proper lazy evaluation (h/t @real-or-random)\r\n* Avoid using BIP specific variable names, e.g., `s/B_m/labeled_spend_pubkey/` etc (h/t @real-or-random)\r\n* Clean up comments to use proper punctuation and full sentences (h/t @real-or-random)\r\n* Improve error handling for malformed public keys and update test coverage (h/t @w0xlt)\r\n* Explicitly clear intermediate hash variables when creating labels (h/t @w0xlt)\r\n* Improve test coverage by explicitly testing more corner cases (h/t @real-or-random)\r\n* Fix `VERIFY` typo (h/t @w0xlt)\r\n\r\nIn addition to what is explicitly mentioned above, I also slightly reworded a few comments and removed comments that I felt were simply restating what the code does without adding any extra information.\r\n\r\n---\r\n\r\nThanks for the continued review @real-or-random . I think your suggestions for variable names and comments have improved the readability quite a bit. Also much happier with the `prevout_summary` naming and treating the `prevout_summary` object as a lazy evaluation.\r\n\r\nAlso, thanks @w0xlt for the thorough review! Much happier with the error handling and glad you caught the VERIFY typo.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3253233041",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19502085019,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASKajOb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19502085019",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T11:25:18Z"
    },
    {
      "event": "subscribed",
      "id": 19502085054,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASKajO-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19502085054",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T11:25:18Z"
    },
    {
      "event": "mentioned",
      "id": 19502085085,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASKajPd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19502085085",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T11:25:19Z"
    },
    {
      "event": "subscribed",
      "id": 19502085096,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASKajPo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19502085096",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T11:25:19Z"
    },
    {
      "event": "commented",
      "id": 3253263392,
      "node_id": "IC_kwDOAP4Jqs7B6Nwg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3253263392",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T11:35:19Z",
      "updated_at": "2025-09-04T11:35:19Z",
      "author_association": "MEMBER",
      "body": "@real-or-random \r\n\r\n> The only way around this that I see is that the intermediate results computed from the addresses\r\n\r\nWorking on an update to the BIP test vectors to include intermediate outputs. Once I have that pull request open, I'll update the test code here to remove the bech32m and ripemd160 python code. ",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3253263392",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19502269979,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASKbQYb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19502269979",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T11:35:21Z"
    },
    {
      "event": "subscribed",
      "id": 19502270021,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASKbQZF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19502270021",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T11:35:21Z"
    },
    {
      "event": "reviewed",
      "id": 3185761940,
      "node_id": "PRR_kwDOAP4Jqs694t6U",
      "url": null,
      "actor": null,
      "commit_id": "d7281b95add5eef82287327e7c4313cb2ffacb9d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-04T15:35:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re-reviewed up to the receiving commit cb53ab5d05049527ff3d6be30144c188263b1192, left a few suggestions only regarding code comments (i.e. typos, outdated API names/references). I agree that the new naming `_prevout_summary` is an improvement. :+1: ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3185761940",
      "submitted_at": "2025-09-04T15:35:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19524957991,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASLxzcn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19524957991",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f3c0ad6d73bd9adb9cedd7e19a8e0f5545be0b20",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/f3c0ad6d73bd9adb9cedd7e19a8e0f5545be0b20",
      "created_at": "2025-09-05T09:05:24Z"
    },
    {
      "event": "commented",
      "id": 3257646419,
      "node_id": "IC_kwDOAP4Jqs7CK71T",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3257646419",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T09:10:29Z",
      "updated_at": "2025-09-05T09:10:29Z",
      "author_association": "MEMBER",
      "body": "Updated [d7281b9](https://github.com/bitcoin-core/secp256k1/commit/d7281b95add5eef82287327e7c4313cb2ffacb9d) -> [f3c0ad6](https://github.com/bitcoin-core/secp256k1/commit/f3c0ad6d73bd9adb9cedd7e19a8e0f5545be0b20) ([2025_16](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_16) -> [2025_17](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_17), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_16..bip352-silentpayments-module-2025_17))\r\n\r\n* `s/prevout_summary/prevouts_summary/` - should have done this in the last push, apologies for the churn on this\r\n* Updated tests to use the new structure introduced in https://github.com/bitcoin/bips/pull/1953 (h/t @macgyver13)\r\n* Various spelling/comment cleanups (h/t @theStack , I promise I'll eventually learn how to spell recipient 😅 )\r\n\r\nThe main change in this push is being able to remove the ripemd160.py and bech32m.py files from the reference code! Thanks @macgyver13 for making these changes , both here and in the BIP repo!",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3257646419",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19525046999,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASLyJLX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19525046999",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T09:10:31Z"
    },
    {
      "event": "subscribed",
      "id": 19525047033,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASLyJL5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19525047033",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T09:10:31Z"
    },
    {
      "event": "mentioned",
      "id": 19525047054,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASLyJMO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19525047054",
      "actor": {
        "login": "macgyver13",
        "id": 4712150,
        "node_id": "MDQ6VXNlcjQ3MTIxNTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4712150?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/macgyver13",
        "html_url": "https://github.com/macgyver13",
        "followers_url": "https://api.github.com/users/macgyver13/followers",
        "following_url": "https://api.github.com/users/macgyver13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/macgyver13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/macgyver13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/macgyver13/subscriptions",
        "organizations_url": "https://api.github.com/users/macgyver13/orgs",
        "repos_url": "https://api.github.com/users/macgyver13/repos",
        "events_url": "https://api.github.com/users/macgyver13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/macgyver13/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T09:10:31Z"
    },
    {
      "event": "subscribed",
      "id": 19525047068,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASLyJMc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19525047068",
      "actor": {
        "login": "macgyver13",
        "id": 4712150,
        "node_id": "MDQ6VXNlcjQ3MTIxNTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4712150?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/macgyver13",
        "html_url": "https://github.com/macgyver13",
        "followers_url": "https://api.github.com/users/macgyver13/followers",
        "following_url": "https://api.github.com/users/macgyver13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/macgyver13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/macgyver13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/macgyver13/subscriptions",
        "organizations_url": "https://api.github.com/users/macgyver13/orgs",
        "repos_url": "https://api.github.com/users/macgyver13/repos",
        "events_url": "https://api.github.com/users/macgyver13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/macgyver13/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T09:10:31Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19526537983,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASL31L_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19526537983",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "aa85bfb530b9ffc3dde6eaa7a976e129b8bd2f58",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/aa85bfb530b9ffc3dde6eaa7a976e129b8bd2f58",
      "created_at": "2025-09-05T10:44:37Z"
    },
    {
      "event": "commented",
      "id": 3257925411,
      "node_id": "IC_kwDOAP4Jqs7CL_8j",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3257925411",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T10:49:23Z",
      "updated_at": "2025-09-05T10:49:23Z",
      "author_association": "MEMBER",
      "body": "Updated [f3c0ad6](https://github.com/bitcoin-core/secp256k1/commit/f3c0ad6d73bd9adb9cedd7e19a8e0f5545be0b20) -> [aa85bfb](https://github.com/bitcoin-core/secp256k1/commit/aa85bfb530b9ffc3dde6eaa7a976e129b8bd2f58) ([2025_17](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_17) -> [2025_18](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_18), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_17..bip352-silentpayments-module-2025_18))\r\n\r\n* Fix `tests_silentpayments_generate.py` to not skip test case (h/t @real-or-random )\r\n* Refactor `tests_silentpayments_generate.py` to be more idiomatic python/more readable (h/t @real-or-random )\r\n* Fix up `tests_impl.h` to handle extra test case (h/t @real-or-random)\r\n\r\nThanks for the fixup! branch for the test vectors, @real-or-random ! I added you as a coauthor.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3257925411",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19526600841,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASL4EiJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19526600841",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T10:49:24Z"
    },
    {
      "event": "subscribed",
      "id": 19526600871,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASL4Ein",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19526600871",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T10:49:24Z"
    },
    {
      "event": "reviewed",
      "id": 3189856649,
      "node_id": "PRR_kwDOAP4Jqs6-IVmJ",
      "url": null,
      "actor": null,
      "commit_id": "aa85bfb530b9ffc3dde6eaa7a976e129b8bd2f58",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-05T16:03:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "Just noting that the \"public data\" terminology is still used a lot, as shown by `$ git grep -i public.*data`. I think it's not entirely wrong in all cases, as the prevouts summary is indeed public data :-) but instances that say \"public data object\" should probably be changed to \"prevouts_summary object\" for consistency.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3189856649",
      "submitted_at": "2025-09-05T16:03:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3190266602,
      "node_id": "PRR_kwDOAP4Jqs6-J5rq",
      "url": null,
      "actor": null,
      "commit_id": "76a0451c76c8497571cb75f2cb4bdba50c734600",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-05T17:32:24Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3190266602",
      "submitted_at": "2025-09-05T17:32:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19560529772,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASN5f9s",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19560529772",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/09d1aee8300f1d6c4623b1c09cef569826954039",
      "created_at": "2025-09-08T09:41:00Z"
    },
    {
      "event": "commented",
      "id": 3265470649,
      "node_id": "IC_kwDOAP4Jqs7CoyC5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3265470649",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-08T09:46:10Z",
      "updated_at": "2025-09-08T09:46:10Z",
      "author_association": "MEMBER",
      "body": "Updated [aa85bfb](https://github.com/bitcoin-core/secp256k1/commit/aa85bfb530b9ffc3dde6eaa7a976e129b8bd2f58) -> [09d1aee](https://github.com/bitcoin-core/secp256k1/commit/09d1aee8300f1d6c4623b1c09cef569826954039) ([2025_18](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_18) -> [2025_19](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_19), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_18..bip352-silentpayments-module-2025_19))\r\n\r\n* `s/public data/prevouts data/` (h/t @theStack)\r\n* Use `{labeled_, unlabeled_,}spend_pubkey` consistently (h/t @theStack)\r\n* Drop `recipient_` prefix from `scan_key32` arg - this better matches the convention we are using for `scan_pubkey, spend_pubkey`\r\n* Remove unnecessary serialization roundtrip from the constant time tests, now that `prevouts_summary` is a proper lazy evaulation\r\n* Document the sending function to mention `ctx` cannot be static (h/t @theStack)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3265470649",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19560633800,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASN55XI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19560633800",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-08T09:46:11Z"
    },
    {
      "event": "subscribed",
      "id": 19560633847,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASN55X3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19560633847",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-08T09:46:11Z"
    },
    {
      "event": "referenced",
      "id": 19567015561,
      "node_id": "REFE_lADOAP4Jqs6_1gh3zwAAAASOSPaJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19567015561",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4985ac0f89279f1619aafb42705b42c28c963c52",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/4985ac0f89279f1619aafb42705b42c28c963c52",
      "created_at": "2025-09-08T14:45:12Z"
    },
    {
      "event": "milestoned",
      "id": 19567727304,
      "node_id": "MIE_lADOAP4Jqs6_1gh3zwAAAASOU9LI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19567727304",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-08T15:17:17Z",
      "milestone": {
        "title": "0.7.1"
      }
    },
    {
      "event": "reviewed",
      "id": 3197279129,
      "node_id": "PRR_kwDOAP4Jqs6-kpuZ",
      "url": null,
      "actor": null,
      "commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-08T17:27:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Left some more comments below, again mostly about naming and tiny refactoring nits, but also one memory clearing finding.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3197279129",
      "submitted_at": "2025-09-08T17:27:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3199782557,
      "node_id": "PRR_kwDOAP4Jqs6-uM6d",
      "url": null,
      "actor": null,
      "commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-09T07:53:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Some nits in the example file :)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3199782557",
      "submitted_at": "2025-09-09T07:53:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19587031634,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASPemJS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19587031634",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9bf5073e0236319c6cfa62397f0d0e281b248c78",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/9bf5073e0236319c6cfa62397f0d0e281b248c78",
      "created_at": "2025-09-09T11:25:11Z"
    },
    {
      "event": "commented",
      "id": 3270271255,
      "node_id": "IC_kwDOAP4Jqs7C7GEX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3270271255",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T11:32:09Z",
      "updated_at": "2025-09-09T11:32:09Z",
      "author_association": "MEMBER",
      "body": "Updated [09d1aee](https://github.com/bitcoin-core/secp256k1/commit/09d1aee8300f1d6c4623b1c09cef569826954039) -> [9bf5073](https://github.com/bitcoin-core/secp256k1/commit/9bf5073e0236319c6cfa62397f0d0e281b248c78) ([2025_19](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_19) -> [2025_20](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_20), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_19..bip352-silentpayments-module-2025_20))\r\n\r\n* Update `examples/silentpayments.c` per @real-or-random 's review\r\n* Rename the `prevouts_summary` struct to drop the `recipients_` infix (h/t @theStack)\r\n* Move the conversion of input hash into a scalar inside the `_calculate_input_hash` function (h/t @theStack)\r\n  * Update the function signature to name\r\n  * This allows for deduplicating the VERIFY_CHECK and explanatory comment\r\n* `s/t_k/output_tweak/` (h/t @real-or-random)\r\n* Use `prevouts_pubkey_sum` everywhere (as opposed to `input_pubkey_sum`)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3270271255",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19587147398,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASPfCaG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19587147398",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T11:32:11Z"
    },
    {
      "event": "subscribed",
      "id": 19587147424,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASPfCag",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19587147424",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T11:32:11Z"
    },
    {
      "event": "mentioned",
      "id": 19587147454,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASPfCa-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19587147454",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T11:32:11Z"
    },
    {
      "event": "subscribed",
      "id": 19587147478,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASPfCbW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19587147478",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T11:32:11Z"
    },
    {
      "event": "reviewed",
      "id": 3205791238,
      "node_id": "PRR_kwDOAP4Jqs6_FH4G",
      "url": null,
      "actor": null,
      "commit_id": "9bf5073e0236319c6cfa62397f0d0e281b248c78",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-10T12:55:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "One more \"final pedantic nit\" review round :-)\r\n\r\nTwo non-code-comment findings:\r\n* Noted that this PR directly includes the test vectors .json file in the repository, while the musig module doesn't. I'm not sure what is the preferred way (and don't have a strong opinion about it), I guess it's ultimately up to the maintainers.\r\n* The commit message of the receiving commit (afdb7f77249ca7a83cc86c2d2a21309079264c2a) could be updated to reflect the most recent naming changes (s/public_data/prevouts_summary/, s/b_scan/scan_key/, s/A_sum/prevouts_pubkey_sum/ etc.)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3205791238",
      "submitted_at": "2025-09-10T12:55:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19616097637,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASRNeVl",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19616097637",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "64633f42d2e9a26d785115cb2712636cb9d6227e",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/64633f42d2e9a26d785115cb2712636cb9d6227e",
      "created_at": "2025-09-10T15:35:39Z"
    },
    {
      "event": "commented",
      "id": 3275531132,
      "node_id": "IC_kwDOAP4Jqs7DPKN8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3275531132",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-10T15:43:17Z",
      "updated_at": "2025-09-10T15:43:17Z",
      "author_association": "MEMBER",
      "body": "Updated [9bf5073](https://github.com/bitcoin-core/secp256k1/commit/9bf5073e0236319c6cfa62397f0d0e281b248c78) -> [64633f4](https://github.com/bitcoin-core/secp256k1/commit/64633f42d2e9a26d785115cb2712636cb9d6227e) ([2025_20](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_20) -> [2025_21](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_21), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_20..bip352-silentpayments-module-2025_21))\r\n\r\n* Use \"public keys\" in header documentation consistently (h/t @theStack)\r\n* Rename `rsk_scalar` to `scan_key_scalar` (h/t @theStack)\r\n* Typo and formatting fix-ups (h/t @theStack)\r\n\r\nThanks again for catching all the little things, @theStack ! Much appreciated.\r\n\r\n> Noted that this PR directly includes the test vectors .json file in the repository, while the musig module doesn't. I'm not sure what is the preferred way (and don't have a strong opinion about it), I guess it's ultimately up to the maintainers\r\n\r\ncc @jonasnick as the author of the musig module and @real-or-random on this one. I prefer to have the data committed in the repo, but happy to go with whatever the project prefers.\r\n\r\n> The commit message of the receiving commit (https://github.com/bitcoin-core/secp256k1/commit/afdb7f77249ca7a83cc86c2d2a21309079264c2a) could be updated to reflect the most recent naming changes\r\n\r\nApologies! Missed this, will fix in my next push.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3275531132",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19616237487,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASROAev",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19616237487",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-10T15:43:19Z"
    },
    {
      "event": "subscribed",
      "id": 19616237530,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASROAfa",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19616237530",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-10T15:43:19Z"
    },
    {
      "event": "mentioned",
      "id": 19616237571,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASROAgD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19616237571",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-10T15:43:19Z"
    },
    {
      "event": "subscribed",
      "id": 19616237604,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASROAgk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19616237604",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-10T15:43:19Z"
    },
    {
      "event": "mentioned",
      "id": 19616237638,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASROAhG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19616237638",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-10T15:43:19Z"
    },
    {
      "event": "subscribed",
      "id": 19616237662,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASROAhe",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19616237662",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-10T15:43:19Z"
    },
    {
      "event": "reviewed",
      "id": 3212961333,
      "node_id": "PRR_kwDOAP4Jqs6_geY1",
      "url": null,
      "actor": null,
      "commit_id": "64633f42d2e9a26d785115cb2712636cb9d6227e",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-11T18:36:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 64633f42d2e9a26d785115cb2712636cb9d6227e 🤫 \r\n\r\nWith one comment regarding statistically improbable failure cases that we `VERIFY_CHECK`. I initially thought of it as small API docs nit, but I guess it's potentially more than that -- depending on how you look at it, there is big range between \"this is just a documentation inaccuracy\" to \"this is horrible, if the unlikely case ever happens, people could actually lose money\".",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3212961333",
      "submitted_at": "2025-09-11T18:36:33Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "commented",
      "id": 3284849165,
      "node_id": "IC_kwDOAP4Jqs7DytIN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3284849165",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-12T11:11:36Z",
      "updated_at": "2025-09-12T11:11:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "> > Noted that this PR directly includes the test vectors .json file in the repository, while the musig module doesn't. I'm not sure what is the preferred way (and don't have a strong opinion about it), I guess it's ultimately up to the maintainers\r\n> \r\n> cc @jonasnick as the author of the musig module and @real-or-random on this one. I prefer to have the data committed in the repo, but happy to go with whatever the project prefers.\r\n\r\nMy thinking is that having the input JSON makes sense to be able to (re-)create the test vectors in the build system without further dependencies. It also documents which version of JSON we use in the library. Perhaps we should have this in the musig module, too.\r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3284849165",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19658435385,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASTu-s5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19658435385",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-12T11:11:37Z"
    },
    {
      "event": "subscribed",
      "id": 19658435415,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASTu-tX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19658435415",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-12T11:11:37Z"
    },
    {
      "event": "mentioned",
      "id": 19658435440,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASTu-tw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19658435440",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-12T11:11:37Z"
    },
    {
      "event": "subscribed",
      "id": 19658435453,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASTu-t9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19658435453",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-12T11:11:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19661366925,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAAST6KaN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19661366925",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bc716fbcc4b836c490a2c3c1cc87d8c738e2f61b",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/bc716fbcc4b836c490a2c3c1cc87d8c738e2f61b",
      "created_at": "2025-09-12T13:36:41Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGY2ZWZmMTIxYTY3MjQ3OGYxYWNjMDE3YmJmY2M4NjlhYWUxY2U1M2Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f6eff121a672478f1acc017bbfcc869aae1ce53f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f6eff121a672478f1acc017bbfcc869aae1ce53f",
      "tree": {
        "sha": "0ad7242847509438813f97e1346a34abc9bf7031",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/0ad7242847509438813f97e1346a34abc9bf7031"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 0ad7242847509438813f97e1346a34abc9bf7031\nparent b4756543028065b3ae6f30e9e6d7f1ecf2bb08c6\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1695828134 +0200\ncommitter josibake <josibake@protonmail.com> 1757931619 +0100\n\nbuild: add skeleton for new silentpayments (BIP352) module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjH6GMACgkQity1WMTz\nPWW6ww//a9gULsL9ZX8owWvUsP1IC6nRUQOAiuCWIwnGrUn3Qojm43B8/8EGq1t1\nzCNd7W0phw0MubhBdmvjdBRP/+KXRLhLbRw+rGt9Pc0AwLfCs/I2elBnC2R0B7UX\nnLOeggAZXoMGd9tqQiyqBUm7VGzvMpyJSHKA5Tmh5jkRrlp7WK4Mw8ibZy0ZVQg6\nXxlgcSLM+4OTMzuNMW1wjXudT/zgq0Dk83utDg2Bim6i7q0grp0hwnDwnp5Po7Tg\noyRjLe26nUzCdHIXsmBW/kv9wppOSkilE3r7viGJ12kHKsWyoyv9H5E2mHoGWwRR\nD4mGHyo9J5qtyyveuNQq+EgzcFnCGGivxgoPKO/E+Dl8tXwm1RFmY3xND3YzQsY6\nfDKPWqwPug6Ha8w7DY/aacesk4Q1Yzbw2BwAk/wLPF8ZS06phip/kBveCpy03KsC\nT3zXKmh0Mpe+tTEqz3oaDqcVTZRdiJrkP5RXdYYfPxS3ElKGERx4+S5a4fJkuIc0\nTBaqRZ3r5rVscMcTHJMGDFdaaVuwLqEoiyMsc0osy3BcdO/Ef9HFgCrpyxgSSJ2J\n6YbGnVht4FtthLNgrN34RoqGXi0txvSYQ8s3Ck52IEANn1b0vcxL1Zgu2ZRfbuuf\nZ5HkHo3wdMSR70BT1n4IXunA0wMMeuiB/GTJyIo/FjRkUHKkIms=\n=+gAP\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b4756543028065b3ae6f30e9e6d7f1ecf2bb08c6",
          "sha": "b4756543028065b3ae6f30e9e6d7f1ecf2bb08c6",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b4756543028065b3ae6f30e9e6d7f1ecf2bb08c6"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-15T10:20:19Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "f6eff121a672478f1acc017bbfcc869aae1ce53f"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19697708468,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASWEy20",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19697708468",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ff0bb11be82f93b5429f9ad2f9bb984bc08440ff",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/ff0bb11be82f93b5429f9ad2f9bb984bc08440ff",
      "created_at": "2025-09-15T10:22:01Z"
    },
    {
      "event": "commented",
      "id": 3291469635,
      "node_id": "IC_kwDOAP4Jqs7EL9dD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3291469635",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-15T10:26:44Z",
      "updated_at": "2025-09-15T10:26:44Z",
      "author_association": "MEMBER",
      "body": "Rebased [64633f4](https://github.com/bitcoin-core/secp256k1/commit/64633f42d2e9a26d785115cb2712636cb9d6227e) -> [ff0bb11](https://github.com/bitcoin-core/secp256k1/commit/ff0bb11be82f93b5429f9ad2f9bb984bc08440ff) ([2025_21](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_21) -> [2025_21-rebased](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_21-rebased), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_21..bip352-silentpayments-module-2025_21-rebased))\r\n\r\n* Rebased to incorporate `s/secp256k1_memclear/secp256k1_memclear_explicit/`",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3291469635",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19697913951,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASWFlBf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19697913951",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "created_at": "2025-09-15T10:32:10Z"
    },
    {
      "event": "commented",
      "id": 3291515400,
      "node_id": "IC_kwDOAP4Jqs7EMIoI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3291515400",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-15T10:39:30Z",
      "updated_at": "2025-09-15T10:39:30Z",
      "author_association": "MEMBER",
      "body": "Updated [ff0bb11](https://github.com/bitcoin-core/secp256k1/commit/ff0bb11be82f93b5429f9ad2f9bb984bc08440ff) -> [d8d062e](https://github.com/bitcoin-core/secp256k1/commit/d8d062eabbf3a98f717ea7779dddcc9eeea80ef6) ([2025_21-rebased](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_21-rebased) -> [2025_22](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_22), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_21-rebased..bip352-silentpayments-module-2025_22))\r\n\r\n* Check and return an error if the output of a hash function is greater than the curve order. Specifically, this updates the `_calculate_input_hash_scalar` and `_create_output_tweak` functions (h/t @theStack)\r\n* Add comments explaining the newly introduced untestable branches\r\n* Have `ARG_CHECKS` match argument order (h/t @theStack)\r\n\r\nThanks for digging into the API docs @theStack , I think this last push brings the code inline with the documentation, and overall I'm happier with where we landed w.r.t. spec compliance with the BIP.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3291515400",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19698058559,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASWGIU_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19698058559",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-15T10:39:31Z"
    },
    {
      "event": "subscribed",
      "id": 19698058588,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASWGIVc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19698058588",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-15T10:39:31Z"
    },
    {
      "event": "reviewed",
      "id": 3224290742,
      "node_id": "PRR_kwDOAP4Jqs7ALsW2",
      "url": null,
      "actor": null,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-15T13:17:28Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3224290742",
      "submitted_at": "2025-09-15T13:17:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3226689885,
      "node_id": "PRR_kwDOAP4Jqs7AU2Fd",
      "url": null,
      "actor": null,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-16T00:40:22Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3226689885",
      "submitted_at": "2025-09-16T00:40:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3229994641,
      "node_id": "PRR_kwDOAP4Jqs7Ahc6R",
      "url": null,
      "actor": null,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-16T14:01:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "I was able to confirm on my machine that the benchmark numbers are not lower than the benchmarks of the individual components despite the benchmarks using static data (*):\r\n\r\n- silentpayments_output_scan 48us\r\n  - recipient_prevouts_summary_parse\r\n    - 1 pubkey parse (square root): 3us\r\n  - recipient_create_shared_secret\r\n    - 1 ECDH: 28 us\r\n  - recipient_create_output_pubkey\r\n     - pubkey_tweak_add (ecmult (var) with generator): 13us\r\n- silentpayments_full_scan: 47\r\n  - prevouts_summary_create\r\n    - ge_set_gej_var: 1us\r\n  - recipient_scan_outputs\r\n    - ECDH + pubkey_tweak_add: 41us\r\n- silentpayments_full_scan_with_labels: 53\r\n  - prevouts_summary_create\r\n    - ge_set_gej_var: 1us\r\n  - recipient_scan_outputs\r\n    - ECDH + pubkey_tweak_add + 2 * 2 * ge_set_gej_var: 45us\r\n\r\nBy the way, I find it interesting that when scanning outputs without labels, the number of outputs doesn't really matter for scanning performance. However, when scanning with labels, each transaction output requires 2 `ge_set_gej(_var)` and scanning performance is independent of the number of labels (assuming constant time label lookup).\r\n\r\n(*) Tested this with and without changing `ge_set_gej` to `ge_set_gej_var` where possible in main_impl.h.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3229994641",
      "submitted_at": "2025-09-16T14:01:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3231304908,
      "node_id": "PRR_kwDOAP4Jqs7AmczM",
      "url": null,
      "actor": null,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-17T08:16:23Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3231304908",
      "submitted_at": "2025-09-17T08:16:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19750577506,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASZOeVi",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19750577506",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "created_at": "2025-09-17T13:24:04Z"
    },
    {
      "event": "commented",
      "id": 3303036061,
      "node_id": "IC_kwDOAP4Jqs7E4FSd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3303036061",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-17T13:32:31Z",
      "updated_at": "2025-09-17T13:32:31Z",
      "author_association": "MEMBER",
      "body": "Updated [d8d062e](https://github.com/bitcoin-core/secp256k1/commit/d8d062eabbf3a98f717ea7779dddcc9eeea80ef6) -> [fe2cec5](https://github.com/bitcoin-core/secp256k1/commit/fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67) ([2025_22](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_22) -> [2025_23](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_23), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_22..bip352-silentpayments-module-2025_23))\r\n\r\n* Update example to use newlines at the end of printed statements\r\n* Don't assert in example on function that can fail (albeit with negligible probability)\r\n* Remove \"stastically improbable\" wording from API documentation (h/t @jonasnick)\r\n* Clean up benchmark:\r\n  * Add `CHECK(n_found == 0)` (h/t @jonasnick)\r\n  * Use `SECP256K1_CONTEXT_NONE` (h/t @theStack)\r\n* Explicitly verify that scalars produced as a result of hash functions are not zero and return an error otherwise (h/t @jonasnick)\r\n* Prefer `gej_var` where appropriate (h/t @jonasnick)\r\n* Explicitly clear sensitive data everywhere (h/t @jonasnick)\r\n* Various comment updates (h/t @jonasnick)\r\n* Replace custom ORDERC value with global constant (h/t @theStack)\r\n\r\nThanks all for the continued review! I have one remaining todo to add a test case for a maliciously created label tweak value, but wanted to go ahead and push the updates completed so far.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3303036061",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19750770075,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASZPNWb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19750770075",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-17T13:32:32Z"
    },
    {
      "event": "subscribed",
      "id": 19750770116,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASZPNXE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19750770116",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-17T13:32:32Z"
    },
    {
      "event": "mentioned",
      "id": 19750770146,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASZPNXi",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19750770146",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-17T13:32:33Z"
    },
    {
      "event": "subscribed",
      "id": 19750770177,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASZPNYB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19750770177",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-17T13:32:33Z"
    },
    {
      "event": "reviewed",
      "id": 3236276312,
      "node_id": "PRR_kwDOAP4Jqs7A5ahY",
      "url": null,
      "actor": null,
      "commit_id": "fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-17T21:20:23Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3236276312",
      "submitted_at": "2025-09-17T21:20:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19779081240,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASa7NQY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19779081240",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4428fd35f3733ba799da8e45762bdd6d6d8155d1",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/4428fd35f3733ba799da8e45762bdd6d6d8155d1",
      "created_at": "2025-09-18T15:40:04Z"
    },
    {
      "event": "commented",
      "id": 3308209723,
      "node_id": "IC_kwDOAP4Jqs7FL0Y7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3308209723",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-18T15:44:12Z",
      "updated_at": "2025-09-18T15:44:12Z",
      "author_association": "MEMBER",
      "body": "Updated [fe2cec5](https://github.com/bitcoin-core/secp256k1/commit/fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67) -> [4428fd3](https://github.com/bitcoin-core/secp256k1/commit/4428fd35f3733ba799da8e45762bdd6d6d8155d1) ([2025_23](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_23) -> [2025_24](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_24), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_23..bip352-silentpayments-module-2025_24))\r\n\r\n* Clear secret sum in early return (h/t @theStack)\r\n* Fix missed rename of `rsk` (h/t @theStack)\r\n* Remove comment from benchmarks (h/t @theStack)\r\n\r\nAs always, thank you for the incredibly thorough review, @theStack  ❤️ ",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3308209723",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19779184426,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASa7mcq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19779184426",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-18T15:44:13Z"
    },
    {
      "event": "subscribed",
      "id": 19779184471,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASa7mdX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19779184471",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-18T15:44:13Z"
    },
    {
      "event": "reviewed",
      "id": 3239101225,
      "node_id": "PRR_kwDOAP4Jqs7BEMMp",
      "url": null,
      "actor": null,
      "commit_id": "4428fd35f3733ba799da8e45762bdd6d6d8155d1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-18T15:56:51Z",
      "author_association": "MEMBER",
      "body": "Reviewed sending support again in 8c5d3e343feaffcdb902f611d1356ad37de807ac (missed todays push) as well as the new tag test in 8c5d3e343feaffcdb902f611d1356ad37de807ac.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3239101225",
      "submitted_at": "2025-09-18T15:56:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3249258777,
      "node_id": "PRR_kwDOAP4Jqs7Bq8EZ",
      "url": null,
      "actor": null,
      "commit_id": "4428fd35f3733ba799da8e45762bdd6d6d8155d1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-20T21:21:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "Now that there are a good number of practically unreachable code branches (entered if scalars converted from hash results are not in range [1,N-1]), I tried verifying that hitting those would indeed result in API function failures by introducing fake hash values, controlled by global test flags that are selectively turned on/off in the tests: https://github.com/theStack/secp256k1/commit/b64cbb0619b3f2c46a504ff0fbe3aa88e593dc05. This is very ugly and obviously not meant to land in the code base, but seeing that this commit passes the tests gives me at least a one-time confidence that the error propagation works as intended, if any of the statistically improbable cases happened.\r\n\r\nSummary of API functions that can \"untestably\" fail, depending on which hash values are out-of-range (hope I didn't miss any):\r\n\r\n| API function returning 0 in unreachable branches          | input_hash | output_tweak | label_tweak |\r\n|---------------------------------|------------|--------------|-------------|\r\n| `secp256k1_sender_create_outputs`          |     X      |      X       |             |\r\n| `secp256k1_recipient_create_label`         |            |              |      X      |\r\n| `secp256k1_prevouts_summary_create`        |     X      |              |             |\r\n| `secp256k1_recipient_scan_outputs`         |            |      X       |             |\r\n| `secp256k1_recipient_create_output_pubkey` |            |      X       |             |\r\n\r\nThat might be helpful to double-check if the API docs for return value 0 are complete.\r\nThe code looks good to me, happy to re-ACK once the outstanding comments are addressed. :shushing_face: ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3249258777",
      "submitted_at": "2025-09-20T21:21:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "referenced",
      "id": 19834201834,
      "node_id": "REFE_lADOAP4Jqs6_1gh3zwAAAASeNebq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19834201834",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "de6af6ae3568461edc9967500d7a70beeb66a642",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/de6af6ae3568461edc9967500d7a70beeb66a642",
      "created_at": "2025-09-22T10:21:41Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19835021439,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASeQmh_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19835021439",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5fe0d3eccf7d3e6c80ebdd983fc0f8ce8de8786d",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/5fe0d3eccf7d3e6c80ebdd983fc0f8ce8de8786d",
      "created_at": "2025-09-22T10:53:51Z"
    },
    {
      "event": "commented",
      "id": 3318246380,
      "node_id": "IC_kwDOAP4Jqs7FyGvs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3318246380",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T10:59:32Z",
      "updated_at": "2025-09-22T10:59:32Z",
      "author_association": "MEMBER",
      "body": "Updated [4428fd3](https://github.com/bitcoin-core/secp256k1/commit/4428fd35f3733ba799da8e45762bdd6d6d8155d1) -> [5fe0d3e](https://github.com/bitcoin-core/secp256k1/commit/5fe0d3eccf7d3e6c80ebdd983fc0f8ce8de8786d) ([2025_24](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_24) -> [2025_25](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_25), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_24..bip352-silentpayments-module-2025_25))\r\n\r\n* Added comment regarding unstable sort (h/t @Sjors)\r\n* Added documentation to the header regarding using all generated outputs (h/t @Sjors)\r\n* `s/greater than curve order/greater than or equal to the curve order/` (h/t @theStack)\r\n* Added a test case for a maliciously created label tweak\r\n\r\nThanks @Sjors for catching the missed comments; I've added both back in.\r\n\r\n@theStack thanks for the untestable branch checker! After adding the last edge case test, I also re-ran `gcovr` and confirmed only the documented untestable branches are the ones not covered in the coverage report.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3318246380",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19835155077,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASeRHKF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19835155077",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T10:59:33Z"
    },
    {
      "event": "subscribed",
      "id": 19835155115,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASeRHKr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19835155115",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T10:59:33Z"
    },
    {
      "event": "mentioned",
      "id": 19835155140,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASeRHLE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19835155140",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T10:59:34Z"
    },
    {
      "event": "subscribed",
      "id": 19835155153,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASeRHLR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19835155153",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T10:59:34Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGY0NDEyZDNkY2NjNWUwMWY3YTdjMmM0MjRhOWYwMzFhZjdmNTFmY2M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f4412d3dccc5e01f7a7c2c424a9f031af7f51fcc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f4412d3dccc5e01f7a7c2c424a9f031af7f51fcc",
      "tree": {
        "sha": "3fd9e9eefe7ab4ebcd8874c3c5cacb23bfee5b64",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3fd9e9eefe7ab4ebcd8874c3c5cacb23bfee5b64"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 3fd9e9eefe7ab4ebcd8874c3c5cacb23bfee5b64\nparent f6eff121a672478f1acc017bbfcc869aae1ce53f\nauthor josibake <josibake@protonmail.com> 1711383817 +0100\ncommitter josibake <josibake@protonmail.com> 1758540448 +0100\n\nsilentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqEACgkQity1WMTz\nPWVgrg/8Dl+Gp0id7oSZIGNSg6SSdLWhWhxHRkUMINrGu2yziY2XrnMHfqOi0cv1\nkc/LBwGFdZz6abI5w+z9VPUjMWvcTeG6ltEPPamAdxFhSgsgJokXeDo3F/Inzb2A\ndyEIsY/Uq6MVvK7j6iZ6SsD9kDT21H50GLTp9uOaSfZJKC2e63li2+YQYuNOfYBy\nqhnoHQMhL/TSKMQ3xNJnDtvm8Yk8kaWaTwV+yzR+1MbXWGzjqbcy+QXR3/5kXmo+\nwAJvPbauQyErLSg4mZnyE4AqLPR0aI+xQ7YJyPg4AmqYcXYZ11o0baNZ1Ev4TfIq\nl8TOxvcEwMkesQQyMJfkz2gpXlBKIHtJ2ad6dfs+8mvDRAEoH5HHOz+jG44DsyOY\nLDDpPyuyWEe+N20wrR7hqyB73UQIkXGRhYJY44lRa5sBLXX1BmEW9L2eg/GxLcpT\nTc/wWO1d+b3ijdip61v4pEllPthM7DG0FC7FUEltCnrFwFRL3LMB2IR6zfK5vN+0\nC0Vf1eoE0vQXZNc4ipiCRWoxsbF1iiraKuLAXCOjZNIir3dNXTsbX0Gw8JPikitA\n5qDoarguxzdeunmMw4iuEzB+foSTdpw+yD1U0tYnOD4LBViCmi8K4AfkElWZ+bLz\nVpF57MKrEIe659ab04uZo7s3abOJq/b8B3KahPW3O+C2f1zpvoM=\n=KHWj\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f6eff121a672478f1acc017bbfcc869aae1ce53f",
          "sha": "f6eff121a672478f1acc017bbfcc869aae1ce53f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f6eff121a672478f1acc017bbfcc869aae1ce53f"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:28Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "f4412d3dccc5e01f7a7c2c424a9f031af7f51fcc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDEzYWYwOTVhMmYzNTUzZmEwMTczMjA5MzA1MDhlMGJhMjQ1NjA2ZWE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/13af095a2f3553fa017320930508e0ba245606ea",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/13af095a2f3553fa017320930508e0ba245606ea",
      "tree": {
        "sha": "33ef0b5e548e0581fb2494ec587d4f99a3f16eaf",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/33ef0b5e548e0581fb2494ec587d4f99a3f16eaf"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 33ef0b5e548e0581fb2494ec587d4f99a3f16eaf\nparent f4412d3dccc5e01f7a7c2c424a9f031af7f51fcc\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1705946165 +0100\ncommitter josibake <josibake@protonmail.com> 1758540449 +0100\n\nsilentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqIACgkQity1WMTz\nPWXZTA//cX8KRtWBigtj1muSfPiUPHKdU6GyP7sVeO558w9ux9pmPg2e2aYsoy1c\nCGoMT/2g6y3UETO8CBOY7I/sFJe858PbVKxcpo9uNXJM1UTMiSujmmwrJD0vTB3t\na2+fioPxtecMR1eBe4SGsUeeUnbP5iaPysRIJN4CUr+pIDipW/zIedYnn0XM8jTs\nAfdF6wEPraN6Kvkjx4DWdGdDzXLkePZ4MZE1uPk9QNc9ZUGKmXSpzduNtB0GmJUA\nt45Jmur+J0C9r4SONGvObeom6+G4+DiIt/Kaot+534Ngs7/mdJ8fDWdajItXwuyt\nhejO7v35y1JGDhM18tHyLlJ5/J+Xj4Nx+nGGDDbjfp12yA/cXb3UXyMKqHmdZada\nPtS3nwiFlBxWS/vUmGS7hNmYTtQ+GcbuFyAvq1H1VTzRCdklG3nXwe5JyOcnehhb\naLE1al5SsbuMw2d4cKT3oNY3MmtA2MPfz8j/UWbSiAMSYmv3YOR3upDE6R/msXYE\nE6M761xQQEvuKurWNyAacepdmnjTuq28yWR/0LrERNrtbfzoPFEpMLJcX0oLQkTO\nuHo4bEJByxjY3fcBed482t3BKCW+RtCJbd1/XkBtCJhf5n8xzB1jERscPWW3YlBF\nC4XFvoU3IYpfBUpuai3Aj9NaafeSNULe2OlyFaLV572FmXWzBbk=\n=UNAD\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f4412d3dccc5e01f7a7c2c424a9f031af7f51fcc",
          "sha": "f4412d3dccc5e01f7a7c2c424a9f031af7f51fcc",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f4412d3dccc5e01f7a7c2c424a9f031af7f51fcc"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:29Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "13af095a2f3553fa017320930508e0ba245606ea"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDQ0NDU5ZDZlYTgxZDkyMjQ0NmZiOTQ5ZmNhYjMwYTJiZDE5NzU0YjI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/44459d6ea81d922446fb949fcab30a2bd19754b2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/44459d6ea81d922446fb949fcab30a2bd19754b2",
      "tree": {
        "sha": "761aa148e00d142f3d6ab8e059db0893c840d69b",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/761aa148e00d142f3d6ab8e059db0893c840d69b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 761aa148e00d142f3d6ab8e059db0893c840d69b\nparent 13af095a2f3553fa017320930508e0ba245606ea\nauthor josibake <josibake@protonmail.com> 1719660810 +0200\ncommitter josibake <josibake@protonmail.com> 1758540450 +0100\n\nsilentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the prevout public key sum\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply the scan_key * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a prevouts_summary object to\nand from a public key. When serializing a prevouts_summary object, the\ninput_hash is multplied into the prevout public key sum. This is so the\nobject can be stored as public key for wallet rescanning later, or to send\nto light clients. For the light client, a `_parse` function is added which\nparses the compressed public key serialization into a `prevouts_summary`\nobject.\n\nFinally, add test coverage for the receiving API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqMACgkQity1WMTz\nPWW7cg//QRL0Vx8xDGcqOUrbCmobxUaZnOLhbTx7ECGeVlaygx3VtwgRFx1sYwkl\nrIDr/y6an89QHjck86U0yJ5uuiTnz9TszxairP664UBYqr27AaQ1BWnem6qBiHUZ\n0EGxOtHeSlkTnhDYs3vQGcjNEm5W4CY7EqZzw3Vwqfz4uPqhy0t8EVrhPcov7KqZ\n8ix6EpMXS0HIJvarWj5Gt0MzjAuYSNCrhTmikt5K/vf+e6UolqdkL56kMvdXfols\ntZGA65jv16fo/HS+KuWhPi9mN30rFgX446OUwI656E764pKnbXIZdA+1es4h0toO\nGhAj+ONoMNMerM0pjrZCHl6TRbhBg7ipgqmhdS+wc4qLRsxcNYmhZGyWPHa4pF9g\nYflTZlybZbQXoO0WdBmnu3YGARaQx7rkeU7hi0z7EjBD2BCF2dh8pdNxNYX7OJR+\n7e4FsYMn6RRMRXZWpZG7ryy8XPfDk/uqRd4Xtk34qKr4wZeSxsHoSDweHcWXFo5I\nBurPk7wi7Zk42BmpigXfAIAPLw47Wcm27ouKHjsLJzImtWvYIyoPo2qOHT5z5eoa\nhbl3+vSo1VgD1ysAFywOHRTgKHPhNRnC0nnJhxeUi0hVlgJR6uJ/+v4jAu2rAGCG\npgoDY/6D1gSL5YIF7VeUwlhH9IgD5PefFMGp+IrLcxp9ZnnuY7I=\n=T7ZE\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/13af095a2f3553fa017320930508e0ba245606ea",
          "sha": "13af095a2f3553fa017320930508e0ba245606ea",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/13af095a2f3553fa017320930508e0ba245606ea"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the prevout public key sum\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply the scan_key * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a prevouts_summary object to\nand from a public key. When serializing a prevouts_summary object, the\ninput_hash is multplied into the prevout public key sum. This is so the\nobject can be stored as public key for wallet rescanning later, or to send\nto light clients. For the light client, a `_parse` function is added which\nparses the compressed public key serialization into a `prevouts_summary`\nobject.\n\nFinally, add test coverage for the receiving API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:30Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-06-29T11:33:30Z"
      },
      "sha": "44459d6ea81d922446fb949fcab30a2bd19754b2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGI1N2ViOWMyMDQ2YWRlOTMzMzAwNzZiZmRmMzM5N2JkNmU2MGYwYzY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b57eb9c2046ade93330076bfdf3397bd6e60f0c6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b57eb9c2046ade93330076bfdf3397bd6e60f0c6",
      "tree": {
        "sha": "bb0db1d1a5e1b21f870acd570d3b0e21616437a2",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/bb0db1d1a5e1b21f870acd570d3b0e21616437a2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree bb0db1d1a5e1b21f870acd570d3b0e21616437a2\nparent 44459d6ea81d922446fb949fcab30a2bd19754b2\nauthor josibake <josibake@protonmail.com> 1713202589 +0200\ncommitter josibake <josibake@protonmail.com> 1758540452 +0100\n\nsilentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqUACgkQity1WMTz\nPWUETg/6Ak0PjNGCtaDfAh/Jl8eGXVdU/PsMqtuxu1OVwff9nf1vojvSsdkUH2RC\nZmQIkan6z1d9XBCLDqvC+zp/8dCaP+zMgcQcs3C4PtkmKhz4oTCQDl0Dz1sRBu3c\njsgiNCwUfDiwZmG/Gg8htJeclSNy1aGY4lFY1001TvyxtgzGuPr9XmP98t+GLoZK\nNTjkexL1i6vUtSsnrC0g8XF9kcfacfxqrD/Xk47u6y5T58I4sTGKN3iQsT/GP1U5\nXden8kzwQG0+5a0DHBlihpIPdT9JVWEeYx3stQ0qOGPGtcW0UgAAzYbKQUTjYKL9\ngm6N9bsPAG9FNc8lekFrTPYUQ4gjSYO9LlNxK5d9QTRebXOYGHOESu44FUjIimMc\n2d1FhNpq7u0hpJ+juIGwWZ35wcJVLPYpoXYIRkQHi0MsWyu5pU2ZG7wj+RT+VwOz\nIdZREAjg8mtXP+D0B2tbMbP+95nUv3llUJFt6Cgyxf2c3LzDhV6caydcTpwlOG9d\n72QW09NKI2ZOxx+i6dtb2pNujh4jr8jhsEj8WE8iUgPqhUa9Hs5sUD1j5D8BiJ5g\nnGnwKIjvGUI9PWMyqEfTdYnJ4m4OvL4D91Oqe/I0SRxIweoo73glK/Cn1OypUmFl\nS6/wkz1lnqjx4CpE3iPozk8gkRoKEz630ZTFGrJP4guyULf0D6w=\n=nR5g\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/44459d6ea81d922446fb949fcab30a2bd19754b2",
          "sha": "44459d6ea81d922446fb949fcab30a2bd19754b2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/44459d6ea81d922446fb949fcab30a2bd19754b2"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:32Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "b57eb9c2046ade93330076bfdf3397bd6e60f0c6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDdhNDMwZWRmZDlkNmUyZDUzYTNjMTdjYzcyMjhkNTY5Y2M2NzUxNzE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7a430edfd9d6e2d53a3c17cc7228d569cc675171",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7a430edfd9d6e2d53a3c17cc7228d569cc675171",
      "tree": {
        "sha": "0b961ce88d468d003b97c5c178d353663ec9c0a1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/0b961ce88d468d003b97c5c178d353663ec9c0a1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 0b961ce88d468d003b97c5c178d353663ec9c0a1\nparent b57eb9c2046ade93330076bfdf3397bd6e60f0c6\nauthor josibake <josibake@protonmail.com> 1714066415 +0200\ncommitter josibake <josibake@protonmail.com> 1758540453 +0100\n\nsilentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqYACgkQity1WMTz\nPWVcKxAAguRQovZHaVQnurk+yNECnNI4D1+dISZ7Fu/GttdYCn4PbW5yoyqwB8W9\nLOGxSu3PA99oUWL+BsDiqw7PyFdu726FYBljc3RPWIUQs9t25uyZ8YU3jQWJ+YKl\nE4Hbb6If4ZFZA/8Z/nYqyvmj8B0X0TeB9AgfoMd26Eoq8U/38PA+Lueb4y6EY87r\nHCad8hDZWhovAFKF7KGDVs/k2ARvvoCKhhSlQjjLiC2ZO/5tTwctmrozyuquYhM3\ngqYp7Hpi0mcpeHGL1010e1o9WxpjCCgVBQflIWg2VjGCJ+BahxyIcqvHHd4MhIsx\n7vbKwuldmRZLkbcJVs9xeRcGjcwi8lK90Np6KX7ir8ZnhXR///TVw2SFVB/fLlHl\n/YTtd3W/wkHf30QYdwftWa3O0UiDmokMSc+M/cw+2qVCq1JgiV/b3cflLuReYSkp\nAFt+hZ3Xk7a5CMzBzyMzB/DcUIsM3Htz0q6HQgorCjEe5Q6prKAbr2/wFOWZ44Dz\nCy8V6c3hGyGORBUkEOn+1grkhe8sv/u1CxbNdByshVSonl2QUvMJZl0WL4AQUHIm\n7XlzkJbGFi2Cr093AXreS/DIeoVQuxpSejPp0n1kBA/EeIoAuIvewthnDQN+GJ5H\nzITpjQENq+irKtfG2+uhKMa6sO3ob7pmyJ/yw0lKEMih5VpVTEU=\n=0QNI\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b57eb9c2046ade93330076bfdf3397bd6e60f0c6",
          "sha": "b57eb9c2046ade93330076bfdf3397bd6e60f0c6",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b57eb9c2046ade93330076bfdf3397bd6e60f0c6"
        }
      ],
      "message": "silentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:33Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "7a430edfd9d6e2d53a3c17cc7228d569cc675171"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDIyYTMwN2FiNmIzNTRkZDNjODM4ZTViZGQ1MjRjNmNkYmVjNmM4YTU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/22a307ab6b354dd3c838e5bdd524c6cdbec6c8a5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/22a307ab6b354dd3c838e5bdd524c6cdbec6c8a5",
      "tree": {
        "sha": "e84112872df3658144b1a987dd5eb8ac48dd1557",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e84112872df3658144b1a987dd5eb8ac48dd1557"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e84112872df3658144b1a987dd5eb8ac48dd1557\nparent 7a430edfd9d6e2d53a3c17cc7228d569cc675171\nauthor josibake <josibake@protonmail.com> 1719942343 +0200\ncommitter josibake <josibake@protonmail.com> 1758540454 +0100\n\ntests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n\nCo-authored-by: Ron <4712150+macgyver13@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\nCo-authored-by: Tim Ruffing <1071625+real-or-random@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqcACgkQity1WMTz\nPWVMJhAAgilPzC853XUyy+nIOlGddMSiEiIfvBjZ4yj2pHr+iAvz1BSpwaQWpRYM\nTSXj2c3/Xj5gIRWoL/5opc4Iid4A2nV7Ca/a+1ijSeBPM2sLiwF0PTrX7k4YsQQ5\n1S7k2DR6IIIAUjnDhRC9vCzCiVyz8jsV0CcejJziT0SoPzapnJ12sxCsCe3qrKSP\nDsvQaIlmyrtSz0KmEuBneq8t7WTHh0zitGvHET9O1NIauvMiOrXMuOmytcK6vcSI\nS7FnfIm6asPeVSr6bcjqM5rFvzEMlV7umrL4dz2JG0Rh75AiQ8+4K6196Y8+KhLi\nW8M1i/xDA11zDqRaqHa0NUiUzjV9+PR6VEW3rXSeToChA5IuZTnLNxsORpD8OE9G\naAZoKBdhjBLyOTE9UsAwewokyaqkrBzX8GS2MVU9aD6sW32ydypt+uOleuYZWlTH\npfefcTdzsgVPmIFlM5o6K74AYSqquD1SAigW3SJfETKg5bo1EQ9uJcD5taLjyC0t\ngBnBFlr/JxWe6VCpDXxZ0Ijbb+Mkj/2tP1CX0/cfkdFeDhFfS/NzMVjrTso7PA30\njTqY8MH00E31ySBBXkBKDk/wwJpxEinzyXOUNbkUpVxpGr5tKKakB46uh/JvCNWu\n9Cw12pAoam54sGJlIVQzdtEvlcUjEpkgbtNBkbjt2HSdt0jWLFw=\n=uwab\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7a430edfd9d6e2d53a3c17cc7228d569cc675171",
          "sha": "7a430edfd9d6e2d53a3c17cc7228d569cc675171",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7a430edfd9d6e2d53a3c17cc7228d569cc675171"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n\nCo-authored-by: Ron <4712150+macgyver13@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\nCo-authored-by: Tim Ruffing <1071625+real-or-random@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:34Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "22a307ab6b354dd3c838e5bdd524c6cdbec6c8a5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDY1NmQ0MDI3MjNkYWI4NDIyY2UyNWI4YTE5Y2ZiZjljMTNlMWQ5YWY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/656d402723dab8422ce25b8a19cfbf9c13e1d9af",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/656d402723dab8422ce25b8a19cfbf9c13e1d9af",
      "tree": {
        "sha": "e5e58da68e924116621adb9551591b9de042c496",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e5e58da68e924116621adb9551591b9de042c496"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e5e58da68e924116621adb9551591b9de042c496\nparent 22a307ab6b354dd3c838e5bdd524c6cdbec6c8a5\nauthor josibake <josibake@protonmail.com> 1730981939 +0100\ncommitter josibake <josibake@protonmail.com> 1758540455 +0100\n\ntests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqgACgkQity1WMTz\nPWVAOhAAg5mkbgcJAe6mGcGsF+sL8/dyRah8RYRNHjnCND1+6WuNEMvt36KGv7C1\npjR1QS1ff0X9jrMgsEXe5ab0cjWTX6tXOrCOqo8OV/ht1fVuXj/mpSDaMIZWOtHC\n0NzC6c82BvsoHcS6NElov3IM3P+167K7P609sfKCF9yP0a9u6xCMNV+M/I2wkhAO\nJSPW1M7auwvpIf31rJR8T78q6vrFTOyrwXBrZutxkGqsSBwMMVQEYHBpi0nSorSl\nR40aNrCkdI6bNZC3EIlD3oUnsj3qHJ1LE2yqZ/zFDV2EPnsOcm5rsuNY78ToW/Mv\n7El9rZhRVnZU2buthWW3CJIsNNxBw9f9hBOv3WEnUN2PjqXLmA1Lal2hoRyqa+Ku\ngTaHj6wtBhhULE/Pe4TujG/mAMLCLodcn6urqKsYvyPqXYYplC8BwiDP9CyIGGWq\nm0Q6V0Sr3O6O2sIdcknqGJsOMb1iy5CA2Du/0T9YZpbiV07E9CwGgDIPUv4jvH7Y\nQ0tO951cZQkw4oGopH/8AQffGWDsw2QTXZHIP7Za54brzQmXu6yoWdB+KfbOts7m\nz2vJjo1Nr9/rcZFobUbwGAExSAV/5gP3VkhDeZUpEmhhlUbHbSw8V5LAjnjE0Mre\njnox/SlSLG3LUNxLIq9R1QmdmM7Ga39TxjY2FezrhbQBMSbdEHY=\n=99qX\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/22a307ab6b354dd3c838e5bdd524c6cdbec6c8a5",
          "sha": "22a307ab6b354dd3c838e5bdd524c6cdbec6c8a5",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/22a307ab6b354dd3c838e5bdd524c6cdbec6c8a5"
        }
      ],
      "message": "tests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:35Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-11-07T12:18:59Z"
      },
      "sha": "656d402723dab8422ce25b8a19cfbf9c13e1d9af"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGFmMmU2NzQ3Yjg3MDBmY2IwY2I1YzY3NGU0Zjc5MmIzNTFjNGIwMTg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/af2e6747b8700fcb0cb5c674e4f792b351c4b018",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/af2e6747b8700fcb0cb5c674e4f792b351c4b018",
      "tree": {
        "sha": "1306444c51f64ba8bb365369c8e3fa62bf80ef8f",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/1306444c51f64ba8bb365369c8e3fa62bf80ef8f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 1306444c51f64ba8bb365369c8e3fa62bf80ef8f\nparent 656d402723dab8422ce25b8a19cfbf9c13e1d9af\nauthor josibake <josibake@protonmail.com> 1755247606 +0100\ncommitter josibake <josibake@protonmail.com> 1758540456 +0100\n\ntests: add sha256 tag test\n\nTest midstate tags used in silent payments.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqkACgkQity1WMTz\nPWXMXg//SsB1Ey2HTbKDAsveTmyz65ZyNIDVJGcdtiDO9yEkeX9j1ryoLjVaedcO\nhhhysMrBQU3v53fAcflxm7QmvyxZXlZTEqZkX4jDwRAiktOlvTJjkyW2Li/+YpvF\nblNoaAyqBRNnNTADtgnPJ6cvCF+DjyBR4UX77m3eCt8iWW1C2hX7Oh9ykrFS6xBH\n2NozKYRumhHnje4f2uT0SeopGz2fabu7Ti+D3/IaA7EkAHj96K9HZxi+3fcqqsPE\nlOyuBdjVFsey5HCW92fxHsrY+ja3M1M4NhegIoexA1jpUIRxUWhvEHJCte24BZXa\nK0iPei+vFqxUJLoZsUwKE3k1W33gwg4yUWFis+nk8/ItQ2UIqSUQNyyqkMV49uoa\nYVJlck5lRyOb5ftNkormR68V6IJmf1z9y/RiqS6EDD/cs89cm5FRz93rTyeX/tcm\nnSGmcXQHzXXv7+ytWQTDmGcy4CeW+1H78ZvlnuFJbZSZHLWtVm2Fds7vLinLpfxu\nqhHrn6YWx21WjSW62SE5UPjIk9vio0HbjtIGM1ZBZDzH5ySkyAIhU8nJIS8QDkjk\n9fuMqiewSaMrhvQrxqZrSzadZyIcbzEBKSJCeOH9v9iEbbAuIJWGmNILbpWvyXoo\nvp/tF+YPaMgshoKYvcckba0g6rmnR+wmQvpthbaVFxsu4T6tM0M=\n=RSy1\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/656d402723dab8422ce25b8a19cfbf9c13e1d9af",
          "sha": "656d402723dab8422ce25b8a19cfbf9c13e1d9af",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/656d402723dab8422ce25b8a19cfbf9c13e1d9af"
        }
      ],
      "message": "tests: add sha256 tag test\n\nTest midstate tags used in silent payments.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:36Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T08:46:46Z"
      },
      "sha": "af2e6747b8700fcb0cb5c674e4f792b351c4b018"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGNkN2Y5M2ViMmQxYjg2YjA4YzE0MzNhYmMxMmM0YjJhMGZkOGM3ZTc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/cd7f93eb2d1b86b08c1433abc12c4b2a0fd8c7e7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/cd7f93eb2d1b86b08c1433abc12c4b2a0fd8c7e7",
      "tree": {
        "sha": "e354fe42f95655f17aef732a71d84aaaa3d37b0b",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e354fe42f95655f17aef732a71d84aaaa3d37b0b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e354fe42f95655f17aef732a71d84aaaa3d37b0b\nparent af2e6747b8700fcb0cb5c674e4f792b351c4b018\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1708644341 +0100\ncommitter josibake <josibake@protonmail.com> 1758540457 +0100\n\nci: enable silentpayments module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqoACgkQity1WMTz\nPWV02g//SnbmFJH5Wy96u4bFwUyPME280Gc0C8cnSKcVXgVRLo6BRHRQyX16+cqK\nMH2BCs40recD3pjgOhvr8LS/0Q6hfPPcK1/KVj26iD9XrZlGA/ev3mkhjrYHGwuw\nTIsSdG6mUKrO+O4tM2IA5UU1FjIS0Gk9pU0ZqUt1vyDUinrDMmjuu9LUVHZMoW4B\nlLweDlxFp6r01Ea4ItdUPGAqrqOvw7wIxb6aKsjMWgqPtwrhJstRn067Vz/AJHx8\ngg4wvGoerQ7uHawJfGx7dhR8U3Znoz02ZxTmi2m6xuiXoegyzNd2zAIiJDHckPxO\nCX12ov9hib8UUyy8FzlKKQiolDT9kBFrzYL5ffR9nJJnc7LW4jjQ2mlCNHZHZazd\nVwxW1CsLDRRSrN8Qq13gk7W3C2aIUwJytQ9B8+r2dmxecgJZImRbosG5+1ES039B\nfkeQczWaQQ2NJvKC2qxYzFVjwobCv74nyPv5attJRxudgskGzDwEU+vXCj42gIZe\nhy+d6rVNiHUl+Y572/sbDqaMxcahIQesIhdBj5z4fGXq8sgpHS4LRScYEIEH6MYt\nzX9/5AQzS91ljTihQF91bXQ3KV9M9FNqhUX1ZpcriduMia1dkN7Pj0/2yFgN+s3C\nUJAObB1ZPcxES6lEvNzFunO4hbD/2mLW+Q8zyoMciigzJO6EMGU=\n=+qj0\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/af2e6747b8700fcb0cb5c674e4f792b351c4b018",
          "sha": "af2e6747b8700fcb0cb5c674e4f792b351c4b018",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/af2e6747b8700fcb0cb5c674e4f792b351c4b018"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:37Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "cd7f93eb2d1b86b08c1433abc12c4b2a0fd8c7e7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDFhMjFjZjE5NDVhZDg3MTJhMzJmZjU3NjViYzQ2Y2YyY2IyYTU3ZWI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "tree": {
        "sha": "ef849ada6e1be8102ec6e7fa3afcc22664c9843a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ef849ada6e1be8102ec6e7fa3afcc22664c9843a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ef849ada6e1be8102ec6e7fa3afcc22664c9843a\nparent cd7f93eb2d1b86b08c1433abc12c4b2a0fd8c7e7\nauthor josibake <josibake@protonmail.com> 1720789074 +0200\ncommitter josibake <josibake@protonmail.com> 1758540458 +0100\n\ndocs: update README\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmjRMqsACgkQity1WMTz\nPWWupA/+Lql+ImoG+sTmLq6J80YZbPEl3CMUtmnr2Tkg/38BIKazxUlpb5d0uFSm\nM4H3DVuhOGRcuCmUhDeVWrh2U7x1aNfXe2uNcAWdxUrY7pH8iwbryakwYDJEmueD\n6PfZc5bvdvprfdxW9LmRElMoJPvf231Jd6Qs885+uULtv6lhr/Hrz72sxCjg7WZA\nGLViS9OajY2tRBldgu6gVBmidiRy5cq9TvZ37dYIpR2cbhCtDpOx0FAl/G02nPwt\nXXt43xWQXCszENLqAO8hdD/So14ddjSGkWkVB2k0K9cUpaBpohf6G4RYMiD6Cf/G\n071MuA5MVP+8DkQyxz/zHKykrBgSCuqTfmHeZRnWIKSHJNt4ywxR0UU1iiipIpd1\npPiMRbt9Z7TX5SsVg2NJrnys3MzIQX2zUT6NJqSDfeQvq0uUAJb57H3ZIzOYwCwG\nNDQa4OfwvXctLH+oOICCAMRabwpXbWGpv0ASBvQnZNzFSmfmTFrpyvO890vDmfUD\nHf8nM9MeCVgM8Z3LDOStHFe00495xxoJ5DfEFLJhEiiOtWcJvwDFjxQ7x7rkrPKE\nhBPX5h74HoSky1bgSnB/pDecAH1J2lufuU4p36spGsXSy6Qfu0M1dF5kP7Ta60OS\n0XMFI2tuydUIuBdahUbSqTg8WRsSCwSYYnCDoqkEuX6oT3xv3Ic=\n=p4MR\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/cd7f93eb2d1b86b08c1433abc12c4b2a0fd8c7e7",
          "sha": "cd7f93eb2d1b86b08c1433abc12c4b2a0fd8c7e7",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/cd7f93eb2d1b86b08c1433abc12c4b2a0fd8c7e7"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-09-22T11:27:38Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19835868729,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAASeT1Y5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19835868729",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "created_at": "2025-09-22T11:30:30Z"
    },
    {
      "event": "commented",
      "id": 3318426320,
      "node_id": "IC_kwDOAP4Jqs7FyyrQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3318426320",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T11:32:59Z",
      "updated_at": "2025-09-22T11:37:11Z",
      "author_association": "MEMBER",
      "body": "Updated [5fe0d3e](https://github.com/bitcoin-core/secp256k1/commit/5fe0d3eccf7d3e6c80ebdd983fc0f8ce8de8786d) -> [1a21cf1](https://github.com/bitcoin-core/secp256k1/commit/1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb) ([2025_25](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_25) -> [2025_26](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_26), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_25..bip352-silentpayments-module-2025_26))\r\n\r\n* Update example to no longer assert on functions that can return errors (h/t @jonasnick)\r\n* Update send API docs to document all possible failure cases\r\n\r\nI believe this push addresses all of the remaining outstanding feedback, except for https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2353403082. It is my belief that the check for the secret key sum being zero is sufficient, but waiting on @jonasnick to confirm. If there is any other outstanding feedback I have missed, please let me know!",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3318426320",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19835924156,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAASeUC68",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19835924156",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T11:33:00Z"
    },
    {
      "event": "subscribed",
      "id": 19835924191,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAASeUC7f",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19835924191",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T11:33:00Z"
    },
    {
      "event": "commented",
      "id": 3320053087,
      "node_id": "IC_kwDOAP4Jqs7F4_1f",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3320053087",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-22T16:30:22Z",
      "updated_at": "2025-09-22T16:30:22Z",
      "author_association": "MEMBER",
      "body": "The `UBSan` failure seems to be happening due to the newly introduced test case; will troubleshoot in the morning. Just wanted to mention that its caused by the tests, in case anyone is willing to review the other changes but dissuaded by the red CI 😅 ",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3320053087",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2197616199",
      "pull_request_review_id": 3005508488,
      "id": 2197616199,
      "node_id": "PRRC_kwDOAP4Jqs6C_PZH",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 342,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *                label_context: pointer to a label context object (NULL if\r\n *                               labels are not used or context is not needed)\r\n```\r\n\r\n(was changed after https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832632525)",
      "created_at": "2025-07-10T12:37:09Z",
      "updated_at": "2025-07-10T16:26:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2197616199",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2197616199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2198191851",
      "pull_request_review_id": 3005508488,
      "id": 2198191851,
      "node_id": "PRRC_kwDOAP4Jqs6DBb7r",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 340,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it should be documented for how long the returned pointer from `label_lookup` should be valid. I think it is obvious it should be valid until the next call of `label_lookup`, but it is currently not clear (from the docs) whether it should remain valid until `secp256k1_silentpayments_recipient_scan_outputs` returns.\r\nThe current implementation of `secp256k1_silentpayments_recipient_scan_outputs` does not need this (from looking at the code) and in a safe Rust abstraction for this function ([code](https://github.com/antonilol/rust-secp256k1/commit/2b3f63399df449d39d90cd2292a913d2a20136cb), does contain some outdated comments) suggested for https://github.com/rust-bitcoin/rust-secp256k1/pull/721 (WIP bindings to this pull request's code) I relied on this **not** being a requirement (though that can be changed).\r\n",
      "created_at": "2025-07-10T16:26:31Z",
      "updated_at": "2025-07-10T16:26:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2198191851",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2198191851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 357,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 362,
      "original_line": 362,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204412350",
      "pull_request_review_id": 3015616207,
      "id": 2204412350,
      "node_id": "PRRC_kwDOAP4Jqs6DZKm-",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 340,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hi @antonilol , thanks for the review and bindings code! Agreed that this should be documented. How about something like:\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\nindex 2e71405..11fa596 100644\r\n--- a/include/secp256k1_silentpayments.h\r\n+++ b/include/secp256k1_silentpayments.h\r\n@@ -311,6 +311,11 @@ typedef struct secp256k1_silentpayments_found_output {\r\n  *  the recipient uses labels. This allows for checking if a label exists in\r\n  *  the recipients label cache and retrieving the label tweak during scanning.\r\n  *\r\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\r\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\r\n+ *  valid until the next call to `label_lookup` or until the function returns,\r\n+ *  whichever comes first. It is not retained beyond that.\r\n+ *\r\n  *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\r\n  *  can be used.\r\n  *\r\n  ```\r\n  \r\n  I think the above is the most precise requirement, but perhaps a simpler alternative would be to require that the returned pointer (and labels cache, if used) be valid until `_scan_outputs` returns? You mention you rely on this _not_ being the case today, but does this make a material difference if we _do_ require that the returned pointer and labels cache be valid for the lifetime of the `_scan_outputs` function?",
      "created_at": "2025-07-14T09:53:56Z",
      "updated_at": "2025-07-14T09:53:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204412350",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204412350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 357,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 362,
      "original_line": 362,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204418847",
      "pull_request_review_id": 3015624158,
      "id": 2204418847,
      "node_id": "PRRC_kwDOAP4Jqs6DZMMf",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 342,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2197616199,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, I've updated the comment and added a test case for the `(lookup, NULL)` argument combination.",
      "created_at": "2025-07-14T09:55:25Z",
      "updated_at": "2025-07-14T09:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204418847",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204418847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204890211",
      "pull_request_review_id": 3016293957,
      "id": 2204890211,
      "node_id": "PRRC_kwDOAP4Jqs6Da_Rj",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 340,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looks good!\r\n\r\n> I think the above is the most precise requirement, but perhaps a simpler alternative would be to require that the returned pointer (and labels cache, if used) be valid until `_scan_outputs` returns? You mention you rely on this _not_ being the case today, but does this make a material difference if we _do_ require that the returned pointer and labels cache be valid for the lifetime of the `_scan_outputs` function?\r\n\r\nThis depends on the function signature on the Rust side, I have considered 2 cases. The difference is in what the user has to return from `label_lookup`.\r\n\r\nFirst, there is the one in the proof of concept binding I mentioned here, the user has to return any byte array of length 32 or nothing (translates to NULL pointer).\r\nThe C side accepts a pointer so the Rust side stores this byte array on the stack and gives the C side a pointer to that. This place on the stack is reused, so requiring that the pointer lives for longer than until the next call of `label_lookup` means that previous return values need to be kept and some dynamic allocation would be needed.\r\nI see this as the easiest for user to use. As far as I can tell no borrow checker issues can arise from this design.\r\n\r\nSecond, the user has to return a reference to a byte array of length 32 or nothing. The reference is required to live for as long as the function runs. This is because in Rust it is not (yet) possible to declare the reference is only required to live until the next call of `label_lookup`.\r\nThis is simple to implement because it is basically a pointer cast and is compatible with `_scan_outputs` needing pointers to be valid for the lifetime of the function.\r\nThis one is harder to use, especially for `label_lookup`s that are not simply looking up in a data structure. Returning a reference to any byte array that is not stored outside the function's stack frame is not allowed and storing it on the fly like the first case here probably requires the user to use unsafe code (needs a data structure that allows adding elements while there exist references to its existing elements because the reference is required to live for as long as the function runs) and has the same need for dynamic allocation like the first case can have.\r\n\r\nThe validity of the context pointer should be completely up to the users of the C library (I consider the Rust binding to also be a user of the C library).\r\n\r\nI will also link this discussion in the Rust bindings pull request.",
      "created_at": "2025-07-14T13:00:14Z",
      "updated_at": "2025-07-14T13:00:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204890211",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204890211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 357,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 362,
      "original_line": 362,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2205138710",
      "pull_request_review_id": 3016682153,
      "id": 2205138710,
      "node_id": "PRRC_kwDOAP4Jqs6Db78W",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 340,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the detailed explanation! As I was thinking through this, it also occurred to me requiring the pointers to be valid for the lifetime of `_scan_outputs` would require keeping around pointers to every label found, even after they had been used by `_scan_outputs`. This seems undesirable, e.g., imagine a transaction with ~15k labeled outputs all paying to a single recipient. Your explanation seems to confirm my understanding.",
      "created_at": "2025-07-14T14:50:29Z",
      "updated_at": "2025-07-14T14:50:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2205138710",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2205138710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 357,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 362,
      "original_line": 362,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219105417",
      "pull_request_review_id": 3037944552,
      "id": 2219105417,
      "node_id": "PRRC_kwDOAP4Jqs6ERNyJ",
      "diff_hunk": "@@ -263,5 +286,61 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n         CHECK(ret == 1);\n     }\n \n+#endif\n+\n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    SECP256K1_CHECKMEM_DEFINE(key, 32);\n+\n+    generated_outputs[0] = &generated_output;\n+\n+    /* Initialize recipient */\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.scan_pubkey, key));\n+    key[31] ^= 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.labeled_spend_pubkey, key));\n+    key[31] ^= (1 << 1);\n+    recipient.index = 0;\n+    recipients[0] = &recipient;\n+\n+    /* Set up secret keys */\n+    SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &taproot_seckey, key);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret);\n+    key[31] ^= (1 << 2);\n+    taproot_seckeys[0] = &taproot_seckey;\n+    plain_seckeys[0] = key;\n+\n+    ret = secp256k1_silentpayments_sender_create_outputs(ctx, generated_outputs, recipients, 1, outpoint_smallest, taproot_seckeys, 1, plain_seckeys, 1);\n+    CHECK(ret == 1);\n+\n+    /* TODO: use non-confusing public key */\n+    ret = secp256k1_silentpayments_recipient_create_label(ctx, &recipient.labeled_spend_pubkey, label_tweak, key, 0);\n+    key[31] ^= (1 << 3);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey, NULL, &taproot_seckey));\n+    SECP256K1_CHECKMEM_DEFINE(&xonly_pubkey, sizeof(xonly_pubkey));\n+    xonly_pubkeys[0] = &xonly_pubkey;\n+    ret = secp256k1_ec_pubkey_create(ctx, &plain_pubkey, plain_seckeys[0]);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    SECP256K1_CHECKMEM_DEFINE(&plain_pubkey, sizeof(plain_pubkey));\n+    plain_pubkeys[0] = &plain_pubkey;\n+\n+    ret = secp256k1_silentpayments_recipient_public_data_create(ctx, &public_data, outpoint_smallest, xonly_pubkeys, 1, plain_pubkeys, 1);\n+    CHECK(ret == 1);\n+\n+    tx_outputs[0] = generated_outputs[0];\n+    n_found_outputs = 1;\n+    SECP256K1_CHECKMEM_DEFINE(&recipient.labeled_spend_pubkey, sizeof(recipient.labeled_spend_pubkey));\n+    /* TODO: make sure we're actually go through all relevant code paths */\n+    ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\n+    CHECK(ret == 1);\n+\n+    /* TODO: this fails */\n+    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\n+    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */",
      "path": "src/ctime_tests.c",
      "position": 1,
      "original_position": 95,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit de508a78ac66b93b0ff83b419cc6e149950ecc25: took a look into these TODOs, I think the following patch would tackle them (note that the serialize/parse-roundtrip looks superfluous at first sight, but it is needed to set the \"combined\" flag in the public data, which is ARG_CHECKEDed for 1 in _recipient_create_shared_secret):\r\n```diff\r\ndiff --git a/src/ctime_tests.c b/src/ctime_tests.c\r\nindex 17964b9..83596a3 100644\r\n--- a/src/ctime_tests.c\r\n+++ b/src/ctime_tests.c\r\n@@ -116,6 +116,8 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\r\n     const secp256k1_xonly_pubkey *xonly_pubkeys[1];\r\n     secp256k1_pubkey plain_pubkey;\r\n     const secp256k1_pubkey *plain_pubkeys[1];\r\n+    unsigned char public_data_ser[33] = { 0 };\r\n+    unsigned char shared_secret[33] = { 0 };\r\n #endif\r\n \r\n     for (i = 0; i < 32; i++) {\r\n@@ -338,9 +340,10 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\r\n     ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\r\n     CHECK(ret == 1);\r\n \r\n-    /* TODO: this fails */\r\n-    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\r\n-    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */\r\n+    CHECK(secp256k1_silentpayments_recipient_public_data_serialize(ctx, public_data_ser, &public_data));\r\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, public_data_ser));\r\n+    CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data));\r\n+    CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(ctx, &xonly_pubkey, shared_secret, &recipient.labeled_spend_pubkey, 0));\r\n \r\n #endif\r\n }\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex 3fc42f5..7d3ad41 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -708,6 +708,7 @@ int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_cont\r\n     ret &= secp256k1_scalar_set_b32_seckey(&rsk, recipient_scan_key32);\r\n     ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_tweaked_ge, public_data);\r\n     /* If there are any issues with the recipient scan key or public data, return early */\r\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\r\n     if (!ret) {\r\n         return 0;\r\n     }\r\n```",
      "created_at": "2025-07-21T12:45:14Z",
      "updated_at": "2025-07-21T12:45:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2219105417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219105417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219368126",
      "pull_request_review_id": 3038350839,
      "id": 2219368126,
      "node_id": "PRRC_kwDOAP4Jqs6ESN6-",
      "diff_hunk": "@@ -263,5 +286,61 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n         CHECK(ret == 1);\n     }\n \n+#endif\n+\n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    SECP256K1_CHECKMEM_DEFINE(key, 32);\n+\n+    generated_outputs[0] = &generated_output;\n+\n+    /* Initialize recipient */\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.scan_pubkey, key));\n+    key[31] ^= 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.labeled_spend_pubkey, key));\n+    key[31] ^= (1 << 1);\n+    recipient.index = 0;\n+    recipients[0] = &recipient;\n+\n+    /* Set up secret keys */\n+    SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &taproot_seckey, key);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret);\n+    key[31] ^= (1 << 2);\n+    taproot_seckeys[0] = &taproot_seckey;\n+    plain_seckeys[0] = key;\n+\n+    ret = secp256k1_silentpayments_sender_create_outputs(ctx, generated_outputs, recipients, 1, outpoint_smallest, taproot_seckeys, 1, plain_seckeys, 1);\n+    CHECK(ret == 1);\n+\n+    /* TODO: use non-confusing public key */\n+    ret = secp256k1_silentpayments_recipient_create_label(ctx, &recipient.labeled_spend_pubkey, label_tweak, key, 0);\n+    key[31] ^= (1 << 3);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey, NULL, &taproot_seckey));\n+    SECP256K1_CHECKMEM_DEFINE(&xonly_pubkey, sizeof(xonly_pubkey));\n+    xonly_pubkeys[0] = &xonly_pubkey;\n+    ret = secp256k1_ec_pubkey_create(ctx, &plain_pubkey, plain_seckeys[0]);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    SECP256K1_CHECKMEM_DEFINE(&plain_pubkey, sizeof(plain_pubkey));\n+    plain_pubkeys[0] = &plain_pubkey;\n+\n+    ret = secp256k1_silentpayments_recipient_public_data_create(ctx, &public_data, outpoint_smallest, xonly_pubkeys, 1, plain_pubkeys, 1);\n+    CHECK(ret == 1);\n+\n+    tx_outputs[0] = generated_outputs[0];\n+    n_found_outputs = 1;\n+    SECP256K1_CHECKMEM_DEFINE(&recipient.labeled_spend_pubkey, sizeof(recipient.labeled_spend_pubkey));\n+    /* TODO: make sure we're actually go through all relevant code paths */\n+    ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\n+    CHECK(ret == 1);\n+\n+    /* TODO: this fails */\n+    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\n+    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */",
      "path": "src/ctime_tests.c",
      "position": 1,
      "original_position": 95,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "in_reply_to_id": 2219105417,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the patch! I've updated the ctime tests to use this, and also removed the remaining TODOs from the test file (with comments where appropriate).",
      "created_at": "2025-07-21T14:18:16Z",
      "updated_at": "2025-07-21T14:18:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2219368126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219368126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2225857523",
      "pull_request_review_id": 3047815175,
      "id": 2225857523,
      "node_id": "PRRC_kwDOAP4Jqs6Eq-Pz",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 144,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 896e0af2f883d21ba3540290f176dcaa7f57272d: As for those TODOs, probably the safest option is to return an error if `_pubkey_tweak_add` indeed fails? Initially I assumed that doing that would introduce a branch that can't be tested in practice, but I think it is: by picking arbitrary `shared_secret33` and `k` values, and calculating `recipient_labeled_spend_pubkey` as `-G^(_create_t_k(shared_secret33, k))` the tweaking should fail with these three values. Will try to come up with some test code later to verify.",
      "created_at": "2025-07-23T14:51:40Z",
      "updated_at": "2025-07-23T14:51:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2225857523",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2225857523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2226200883",
      "pull_request_review_id": 3048350883,
      "id": 2226200883,
      "node_id": "PRRC_kwDOAP4Jqs6EsSEz",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 144,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, managed to come up with a test that makes the VERIFY_CHECK on the `_pubkey_tweak_add` return value fail:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/tests_impl.h b/src/modules/silentpayments/tests_impl.h\r\nindex a1acab7..2a10791 100644\r\n--- a/src/modules/silentpayments/tests_impl.h\r\n+++ b/src/modules/silentpayments/tests_impl.h\r\n@@ -367,6 +367,23 @@ static void test_recipient_api(void) {\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_output_pubkey(CTX, &t, NULL, &p, 0));\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_output_pubkey(CTX, &t, o, NULL, 0));\r\n \r\n+    /* check the _recipient_create_output_pubkey cornercase where internal tweaking would fail;\r\n+       this is the case if the recipient spend public key is P = -(create_t_k(shared_secret, k))*G */\r\n+    {\r\n+        const unsigned char *shared_secret = o;\r\n+        const uint32_t k = 0;\r\n+        secp256k1_scalar t_k;\r\n+        unsigned char t_k_ser[32];\r\n+        secp256k1_pubkey fake_spend_pubkey;\r\n+        secp256k1_xonly_pubkey output_xonly;\r\n+\r\n+        secp256k1_silentpayments_create_t_k(&t_k, shared_secret, k);\r\n+        secp256k1_scalar_get_b32(t_k_ser, &t_k);\r\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &fake_spend_pubkey, t_k_ser));\r\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &fake_spend_pubkey));\r\n+        CHECK(secp256k1_silentpayments_create_output_pubkey(CTX, &output_xonly, shared_secret, &fake_spend_pubkey, k) == 0);\r\n+    }\r\n+\r\n     n_f = 0;\r\n     labels_cache.entries_used = 0;\r\n     CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, &labels_cache));\r\n```\r\n</details>\r\n\r\nI assume that in practice a user can't be tricked into such a scenario though, as the recipient spend public key is known/generated before the shared secret is.",
      "created_at": "2025-07-23T17:14:12Z",
      "updated_at": "2025-07-23T17:14:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2226200883",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2226200883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2228336402",
      "pull_request_review_id": 3051391771,
      "id": 2228336402,
      "node_id": "PRRC_kwDOAP4Jqs6E0bcS",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 144,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Awesome! IIRC, the initial hesitance to returning a value was adding an untestable branch in the code. But considering this can be exercised in a test (which indicates its not inconceivable that someone could be tricked into calling this function with a maliciously crafted spend pubkey), I removed the VERIFY_CHECK in favour of returning the value and added your test case. Thanks for working on this!",
      "created_at": "2025-07-24T12:10:33Z",
      "updated_at": "2025-07-24T12:10:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2228336402",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2228336402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229570600",
      "pull_request_review_id": 3053302400,
      "id": 2229570600,
      "node_id": "PRRC_kwDOAP4Jqs6E5Iwo",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 246,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Suggestion for the comment to tackle another TODO 🔫  (IIUC, the non-constant timing of group element serialization seems to ultimately be caused by [variable-time normalization of field elements](https://github.com/bitcoin-core/secp256k1/blob/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d/src/eckey_impl.h#L44-L45)):\r\n```suggestion\r\n    /* Need to declassify the pubkey sum because serializing a group element (done in the\r\n       `_calculate_input_hash` call following) is not a constant-time operation */\r\n    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\r\n```",
      "created_at": "2025-07-24T21:04:03Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229570600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229570600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229577936",
      "pull_request_review_id": 3053302400,
      "id": 2229577936,
      "node_id": "PRRC_kwDOAP4Jqs6E5KjQ",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 141,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "only noticing now that in one of my [earlier comments](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2225857523) I was using multiplicative notation (cryptocamp leaving its marks already I guess 😁)\r\n```suggestion\r\n     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\r\n```",
      "created_at": "2025-07-24T21:07:46Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229577936",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229577936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229609301",
      "pull_request_review_id": 3053302400,
      "id": 2229609301,
      "node_id": "PRRC_kwDOAP4Jqs6E5SNV",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 282,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should also memclear the shared secret here and in the error path a few lines above (admitedly a bit annoying though that this leads to so much code duplication :/)",
      "created_at": "2025-07-24T21:22:37Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229609301",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229609301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229624153",
      "pull_request_review_id": 3053302400,
      "id": 2229624153,
      "node_id": "PRRC_kwDOAP4Jqs6E5V1Z",
      "diff_hunk": "@@ -0,0 +1,618 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 151,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "72489a733c81153782eba2e4dded316dccc55c99",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could update the `main` return values in the example to use `EXIT_FAILURE`/`EXIT_SUCCESS` (done for other examples in #1654)",
      "created_at": "2025-07-24T21:32:44Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229624153",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229624153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230327932",
      "pull_request_review_id": 3054340559,
      "id": 2230327932,
      "node_id": "PRRC_kwDOAP4Jqs6E8Bp8",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 141,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229577936,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was about to ask what this strange \"`-`\" symbol in `-G^(_create_t_k(shared_secret33, k))` is supposed to mean. :stuck_out_tongue:  ",
      "created_at": "2025-07-25T07:04:44Z",
      "updated_at": "2025-07-25T07:04:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230327932",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230327932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230609936",
      "pull_request_review_id": 3054721891,
      "id": 2230609936,
      "node_id": "PRRC_kwDOAP4Jqs6E9GgQ",
      "diff_hunk": "@@ -0,0 +1,618 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 151,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "72489a733c81153782eba2e4dded316dccc55c99",
      "in_reply_to_id": 2229624153,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-07-25T09:20:32Z",
      "updated_at": "2025-07-25T09:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230609936",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230609936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230612333",
      "pull_request_review_id": 3054725418,
      "id": 2230612333,
      "node_id": "PRRC_kwDOAP4Jqs6E9HFt",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 282,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229609301,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, also slightly reworded the comment. Overall, while slightly annoying, the code duplication doesn't seem too bad to me and I don't see a clever way to DRY it up.",
      "created_at": "2025-07-25T09:21:26Z",
      "updated_at": "2025-07-25T09:21:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230612333",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230612333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230613364",
      "pull_request_review_id": 3054726664,
      "id": 2230613364,
      "node_id": "PRRC_kwDOAP4Jqs6E9HV0",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 141,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229577936,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Team additive 💪 ",
      "created_at": "2025-07-25T09:21:56Z",
      "updated_at": "2025-07-25T09:21:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230613364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230613364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230614608",
      "pull_request_review_id": 3054728553,
      "id": 2230614608,
      "node_id": "PRRC_kwDOAP4Jqs6E9HpQ",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 246,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229570600,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for digging into this! Added the comment with some slight formatting changes.",
      "created_at": "2025-07-25T09:22:25Z",
      "updated_at": "2025-07-25T09:22:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230614608",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230614608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230617988",
      "pull_request_review_id": 3054733915,
      "id": 2230617988,
      "node_id": "PRRC_kwDOAP4Jqs6E9IeE",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 144,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated this to actually calculate the shared secret from the public data object, to make valgrind happy.",
      "created_at": "2025-07-25T09:23:51Z",
      "updated_at": "2025-07-25T09:23:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230617988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230617988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236470910",
      "pull_request_review_id": 3062729343,
      "id": 2236470910,
      "node_id": "PRRC_kwDOAP4Jqs6FTdZ-",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 111,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It might make sense to split this benchmark into \"labeled\" and \"unlabeled\" variants in order to also get a feeling how overhead the labels scanning causes, with something like e.g.:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/bench_impl.h b/src/modules/silentpayments/bench_impl.h\r\nindex 1dd1e5a..366d172 100644\r\n--- a/src/modules/silentpayments/bench_impl.h\r\n+++ b/src/modules/silentpayments/bench_impl.h\r\n@@ -108,7 +108,7 @@ static void bench_silentpayments_output_scan(void* arg, int iters) {\r\n     }\r\n }\r\n \r\n-static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\r\n     int i;\r\n     size_t n_found = 0;\r\n     secp256k1_silentpayments_found_output *found_output_ptrs[2];\r\n@@ -116,6 +116,8 @@ static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n     const secp256k1_xonly_pubkey *tx_input_ptrs[2];\r\n     bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\r\n     secp256k1_silentpayments_recipient_public_data public_data;\r\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\r\n+    const void *label_context = use_labels ? label_cache : NULL;\r\n \r\n     for (i = 0; i < 2; i++) {\r\n         found_output_ptrs[i] = &data->found_outputs[i];\r\n@@ -135,11 +137,19 @@ static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n             data->scan_key,\r\n             &public_data,\r\n             &data->spend_pubkey,\r\n-            label_lookup, label_cache)\r\n+            label_lookup_fn, label_context)\r\n         );\r\n     }\r\n }\r\n \r\n+static void bench_silentpayments_full_tx_scan_unlabeled(void *arg, int iters) {\r\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\r\n+}\r\n+\r\n+static void bench_silentpayments_full_tx_scan_labeled(void *arg, int iters) {\r\n+    bench_silentpayments_full_tx_scan(arg, iters, 1);\r\n+}\r\n+\r\n static void run_silentpayments_bench(int iters, int argc, char** argv) {\r\n     bench_silentpayments_data data;\r\n     int d = argc == 1;\r\n@@ -147,7 +157,8 @@ static void run_silentpayments_bench(int iters, int argc, char** argv) {\r\n     /* create a context with no capabilities */\r\n     data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\r\n \r\n-    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan\", bench_silentpayments_full_tx_scan, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n+    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan_labeled\", bench_silentpayments_full_tx_scan_labeled, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n+    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan_unlabeled\", bench_silentpayments_full_tx_scan_unlabeled, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n     if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_output_scan\", bench_silentpayments_output_scan, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n \r\n     secp256k1_context_destroy(data.ctx);\r\n\r\n```\r\n</details>\r\nResults on my machine:\r\n\r\n```\r\nBenchmark                     ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\n\r\nsilentpayments_full_tx_scan_labeled,    94.6       ,    96.6       ,   101.0\r\nsilentpayments_full_tx_scan_unlabeled,    82.7       ,    84.2       ,    85.9\r\nsilentpayments_output_scan    ,    85.3       ,    87.5       ,    90.7\r\n```",
      "created_at": "2025-07-28T13:27:27Z",
      "updated_at": "2025-07-28T13:27:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2236470910",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236470910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236659827",
      "pull_request_review_id": 3062979375,
      "id": 2236659827,
      "node_id": "PRRC_kwDOAP4Jqs6FULhz",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 111,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed. I added the dummy labels originally to make sure I was reporting worst-case[^1] numbers for the full scan benchmark, and the idea was to add more benchmarks in a follow-up that more accurately benchmark labels. However, I think what you have here is nicer and we can still leave a TODO comment to add a more representative benchmark for scanning _with_ labels.\r\n\r\n[^1]: worst case in the sense that all of the scan-with-labels code paths are hit during the benchmark. Its not an actual worst case in that you could have a very large, poorly implemented labels cache which would necessarily slow down scanning",
      "created_at": "2025-07-28T14:11:33Z",
      "updated_at": "2025-07-28T14:11:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2236659827",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236659827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2237486984",
      "pull_request_review_id": 3064088495,
      "id": 2237486984,
      "node_id": "PRRC_kwDOAP4Jqs6FXVeI",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 111,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added your diff with a few minor naming differences and left a TODO comment for filling out the labels benchmark in a follow-up. In particular, I would be interested to see a benchmark that demonstrates that scan time is largely unaffected by label cache size, e.g., scanning with 10 labels vs 100,000 labels shouldn't make a difference. I think this should be a follow-up, however, since it's not strictly necessary and will likely require dedicated review of its own to get things right. ",
      "created_at": "2025-07-28T18:09:35Z",
      "updated_at": "2025-07-28T18:09:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2237486984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2237486984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2240863450",
      "pull_request_review_id": 3069025328,
      "id": 2240863450,
      "node_id": "PRRC_kwDOAP4Jqs6FkNza",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 111,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems fine to limit the scanning-with-labels benchmark to the cryptography-related parts for now. The planned extended benchmark doesn't even necessarily have to live in the secp repo IMHO, it could as well be in a project using the module (i.e. Bitcoin Core in our case), where a labels cache has to be implemented anyways and we wouldn't have to fake it (which might be non-trivial in C to achieve something representative, as I guess we'd need to implement some hashmap-like data structure a la `std::unordered_map`?). But no hard feelings on the details of where/how, I agree that seeing such a followup would be very interesting indeed.",
      "created_at": "2025-07-29T20:08:33Z",
      "updated_at": "2025-07-29T20:08:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2240863450",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2240863450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2242248473",
      "pull_request_review_id": 3070874257,
      "id": 2242248473,
      "node_id": "PRRC_kwDOAP4Jqs6Fpf8Z",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 111,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Excellent point regarding the hashmap. I'll leave the TODO comment for now, but it might be that the follow-up is simply to remove the comment in favour of, as you suggest, benchmarking this in a more realistic setting like Bitcoin Core.",
      "created_at": "2025-07-30T10:48:11Z",
      "updated_at": "2025-07-30T10:48:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2242248473",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2242248473"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244025546",
      "pull_request_review_id": 3073577403,
      "id": 2244025546,
      "node_id": "PRRC_kwDOAP4Jqs6FwRzK",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return EXIT_SUCCESS;",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 35,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "070ea002339bf10603da5dd772795c7ccae3af51",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in 070ea002339bf10603da5dd772795c7ccae3af51, function `my_memcmp_var`\r\n```suggestion\r\n    return 0;\r\n```\r\nas this doesn't indicate a process execution status",
      "created_at": "2025-07-30T23:05:57Z",
      "updated_at": "2025-07-30T23:49:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2244025546",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244025546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244864246",
      "pull_request_review_id": 3074665943,
      "id": 2244864246,
      "node_id": "PRRC_kwDOAP4Jqs6Fzej2",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return EXIT_SUCCESS;",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 35,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "070ea002339bf10603da5dd772795c7ccae3af51",
      "in_reply_to_id": 2244025546,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, good catch!",
      "created_at": "2025-07-31T09:33:28Z",
      "updated_at": "2025-07-31T09:33:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2244864246",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244864246"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245393152",
      "pull_request_review_id": 3075428613,
      "id": 2245393152,
      "node_id": "PRRC_kwDOAP4Jqs6F1fsA",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 36,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: it may be worth reminding the reader why there's never more than one secret key per input; BIP352 excludes inputs \"with conditional branches or multiple public keys\". ",
      "created_at": "2025-07-31T13:23:55Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245393152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245393152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245418259",
      "pull_request_review_id": 3075428613,
      "id": 2245418259,
      "node_id": "PRRC_kwDOAP4Jqs6F1l0T",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 47,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: the taproot secret keys",
      "created_at": "2025-07-31T13:33:02Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245418259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245418259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245425545",
      "pull_request_review_id": 3075428613,
      "id": 2245425545,
      "node_id": "PRRC_kwDOAP4Jqs6F1nmJ",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 68,
      "original_position": 45,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: I still think it would be nice to have a helper for this, but it can be introduced in a later PR.",
      "created_at": "2025-07-31T13:35:58Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245425545",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245425545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245490407",
      "pull_request_review_id": 3075428613,
      "id": 2245490407,
      "node_id": "PRRC_kwDOAP4Jqs6F13bn",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 9,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: from offline conversation my understanding is as follows:\r\n\r\nWe don't add a tie breaker here (e.g. `->index`) because:\r\n\r\n1. The protocol doesn't require it\r\n2. It would break the constant time property of heap sort\r\n\r\nIf so, it would be good to say this in a comment so nobody is a) confused b) tempted later to introduce a footgun.\r\n\r\n(the temptation might come from a user of this library who finds that their tests are breaking half of the time because they had an ordering related bug - or just natural programmer desire for deterministic sort ) ",
      "created_at": "2025-07-31T14:00:45Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245490407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245490407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245508149",
      "pull_request_review_id": 3075428613,
      "id": 2245508149,
      "node_id": "PRRC_kwDOAP4Jqs6F17w1",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 48,
      "original_position": 33,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: anyone have a nice Python / Ruby incantation to derive the midstates of `BIP0352/...`?",
      "created_at": "2025-07-31T14:07:45Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245508149",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245508149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245582298",
      "pull_request_review_id": 3075428613,
      "id": 2245582298,
      "node_id": "PRRC_kwDOAP4Jqs6F2N3a",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 311,
      "original_position": 293,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: it's worth noting somewhere, maybe in the BIP, that _removing_ (omitting) any output `k` later will cause the recipient to not find outputs `> k`  ",
      "created_at": "2025-07-31T14:34:23Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245582298",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245582298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 311,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245635733",
      "pull_request_review_id": 3075428613,
      "id": 2245635733,
      "node_id": "PRRC_kwDOAP4Jqs6F2a6V",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 16,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: \"is set to\" -> \"must be set to ... starting with 0\" (since it's checked).",
      "created_at": "2025-07-31T14:54:50Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245635733",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245635733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245675709",
      "pull_request_review_id": 3075428613,
      "id": 2245675709,
      "node_id": "PRRC_kwDOAP4Jqs6F2kq9",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 265,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: so the last shall be first, and the first last :-)\r\n\r\nI think it would be more clear to store `recipients[0]->scan_pubkey` instead and call it `current_scan_pubkey`.",
      "created_at": "2025-07-31T15:10:30Z",
      "updated_at": "2025-07-31T15:27:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245675709",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245675709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245789470",
      "pull_request_review_id": 3076017194,
      "id": 2245789470,
      "node_id": "PRRC_kwDOAP4Jqs6F3Ace",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 48,
      "original_position": 33,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wrote one in C using secp256k1 itself a while ago, see https://github.com/bitcoin-core/secp256k1/issues/1653 (regarding Python, the thread suggests using the https://github.com/cloudtools/sha256 library, but didn't try that yet; with the standard library implementation in `hashlib` it's unfortunately not possible to access the internal state :/).",
      "created_at": "2025-07-31T15:57:43Z",
      "updated_at": "2025-07-31T15:57:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245789470",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245789470"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247461288",
      "pull_request_review_id": 3078444703,
      "id": 2247461288,
      "node_id": "PRRC_kwDOAP4Jqs6F9Ymo",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 9,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245490407,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Following up on this, I misspoke regarding 2). Its not about being constant time (heapsort is $O(n\\log{}n)$ time, $O(1)$ space), but rather heapsort is unstable so there isn't a straightforward way to do a stable, e.g., multi-key, sort.\r\n\r\nEven if there were a straightforward way, I'd still push back since the protocol is _designed_ to not rely on ordering. Rather, the BIP only specifies grouping by scan key and sorting is just our way of implementing \"grouping.\" I'll flesh out the comment to make this more clear.",
      "created_at": "2025-08-01T09:35:28Z",
      "updated_at": "2025-08-01T09:35:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247461288",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247461288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247485588",
      "pull_request_review_id": 3078478732,
      "id": 2247485588,
      "node_id": "PRRC_kwDOAP4Jqs6F9eiU",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 48,
      "original_position": 33,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've had this thought a few times in the past. Opened https://github.com/secp256k1lab/secp256k1lab/issues/10 to discuss further, as that seems like the most natural place to me for an example/script to live.",
      "created_at": "2025-08-01T09:45:47Z",
      "updated_at": "2025-08-01T09:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247485588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247485588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247487614",
      "pull_request_review_id": 3078481228,
      "id": 2247487614,
      "node_id": "PRRC_kwDOAP4Jqs6F9fB-",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 311,
      "original_position": 293,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245582298,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Great point! I'll add a footnote to the BIP.",
      "created_at": "2025-08-01T09:46:19Z",
      "updated_at": "2025-08-01T09:46:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247487614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247487614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 311,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247625218",
      "pull_request_review_id": 3078686422,
      "id": 2247625218,
      "node_id": "PRRC_kwDOAP4Jqs6F-AoC",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 265,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245675709,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-01T10:35:07Z",
      "updated_at": "2025-08-01T10:35:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247625218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247625218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247629863",
      "pull_request_review_id": 3078693598,
      "id": 2247629863,
      "node_id": "PRRC_kwDOAP4Jqs6F-Bwn",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 16,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245635733,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. I also took out the first sentence, as it seemed to imply we only need to set the index field in certain situations (the index field must always be set, even if only sending to one silent payment recipient).",
      "created_at": "2025-08-01T10:36:24Z",
      "updated_at": "2025-08-01T10:36:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247629863",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247629863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247633383",
      "pull_request_review_id": 3078699912,
      "id": 2247633383,
      "node_id": "PRRC_kwDOAP4Jqs6F-Cnn",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 9,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245490407,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated the comment to indicate developers cannot and should not rely on deterministic sorting of the recipients.",
      "created_at": "2025-08-01T10:37:16Z",
      "updated_at": "2025-08-01T10:37:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247633383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247633383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247638059",
      "pull_request_review_id": 3078708175,
      "id": 2247638059,
      "node_id": "PRRC_kwDOAP4Jqs6F-Dwr",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 68,
      "original_position": 45,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245425545,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think this module should include a helper function for this, but we can debate this in a later PR 😉 ",
      "created_at": "2025-08-01T10:39:16Z",
      "updated_at": "2025-08-01T10:39:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247638059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247638059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680706",
      "pull_request_review_id": 3078762032,
      "id": 2247680706,
      "node_id": "PRRC_kwDOAP4Jqs6F-OLC",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 311,
      "original_position": 293,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245582298,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in https://github.com/bitcoin/bips/pull/1908",
      "created_at": "2025-08-01T10:53:04Z",
      "updated_at": "2025-08-01T10:53:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247680706",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 311,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680951",
      "pull_request_review_id": 3078762423,
      "id": 2247680951,
      "node_id": "PRRC_kwDOAP4Jqs6F-OO3",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 47,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245418259,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-01T10:53:14Z",
      "updated_at": "2025-08-01T10:53:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247680951",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247682028",
      "pull_request_review_id": 3078764200,
      "id": 2247682028,
      "node_id": "PRRC_kwDOAP4Jqs6F-Ofs",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 36,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245393152,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a reminder, with a prompt to review the BIP for more details.",
      "created_at": "2025-08-01T10:53:46Z",
      "updated_at": "2025-08-01T10:53:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247682028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247682028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254104769",
      "pull_request_review_id": 3087942073,
      "id": 2254104769,
      "node_id": "PRRC_kwDOAP4Jqs6GWujB",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].labeled_spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 252,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "e0c225c047645ae92db877f661ede385f4f8603d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in e0c225c047645ae92db877f661ede385f4f8603d: this comment seems outdated? the cast for `tx_output_ptrs` is now happening at the scan function below (from non-const to const rather than the other way round)",
      "created_at": "2025-08-05T11:47:25Z",
      "updated_at": "2025-08-05T13:33:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2254104769",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254104769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 248,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254202085",
      "pull_request_review_id": 3087942073,
      "id": 2254202085,
      "node_id": "PRRC_kwDOAP4Jqs6GXGTl",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].labeled_spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the public data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that public_data_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the public data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the public data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 459,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "e0c225c047645ae92db877f661ede385f4f8603d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in e0c225c047645ae92db877f661ede385f4f8603d:\r\n```suggestion\r\n                    ret = secp256k1_xonly_pubkey_serialize(ctx,\r\n                        serialized_xonly,\r\n                        &found_outputs[i].output\r\n                    );\r\n                    assert(ret);\r\n```\r\njust to evaluate all API call return values for consistency (here and in the light client scanning loop below)",
      "created_at": "2025-08-05T12:30:39Z",
      "updated_at": "2025-08-05T13:33:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2254202085",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254202085"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 456,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 439,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254258008",
      "pull_request_review_id": 3087942073,
      "id": 2254258008,
      "node_id": "PRRC_kwDOAP4Jqs6GXT9Y",
      "diff_hunk": "@@ -25,6 +26,94 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the secret keys correspond to x-only\n+ *  (taproot) outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 75,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "e0c7a09415de00e94e8a8c8fc3c5154d00cc0739",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in e0c7a09415de00e94e8a8c8fc3c5154d00cc0739:\r\n```suggestion\r\n *       outpoint_smallest36: serialized (36-byte) smallest outpoint\r\n```\r\n(also in the description above)",
      "created_at": "2025-08-05T12:53:43Z",
      "updated_at": "2025-08-05T13:33:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2254258008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254258008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254306773",
      "pull_request_review_id": 3087942073,
      "id": 2254306773,
      "node_id": "PRRC_kwDOAP4Jqs6GXf3V",
      "diff_hunk": "@@ -165,6 +168,256 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used or context is not needed)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n+    SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n+\n+/** Create Silent Payment shared secret.\n+ *\n+ *  Given the public input data (secp256k1_silentpayments_recipient_public_data),\n+ *  and the recipient's 32 byte scan key, calculate the shared secret.\n+ *\n+ *  The resulting shared secret is needed as input for creating silent payments\n+ *  outputs belonging to the same recipient scan public key. This function is\n+ *  intended for light clients, i.e., scenarios where the caller does not have\n+ *  access to the full transaction. If the caller does have access to the full\n+ *  transaction, `secp256k1_silentpayments_recipient_scan_outputs` should be\n+ *  used instead.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occurred.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:       shared_secret33: pointer to the resulting 33-byte shared secret\n+ *  In:   recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                 public_data: pointer to the public_data object, loaded using\n+ *                              `_recipient_public_data_parse`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_shared_secret(\n+    const secp256k1_context *ctx,\n+    unsigned char *shared_secret33,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment output public key.\n+ *\n+ *  Given a shared_secret, a public key B_spend, and an output counter k,\n+ *  create an output public key.\n+ *\n+ *  This function is used by the recipient when scanning for outputs without\n+ *  access to the transaction outputs (e.g., using BIP158 block filters). When\n+ *  scanning with this function, it is the scanners responsibility to determine\n+ *  if the generated output exists in a block before proceeding to the next\n+ *  value of `k`.\n+ *\n+ *  Returns: 1 if output creation was successful. 0 if an error occurred.\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:         P_output_xonly: pointer to the resulting output x-only pubkey\n+ *  In:         shared_secret33: shared secret, derived from either sender's\n+ *                               or recipient's perspective with routines from\n+ *                               above\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                               (labeled or unlabeled)\n+ *                            k: output counter (initially set to 0, must be\n+ *                               incremented for each additional output created\n+ *                               or after each output found when scanning)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_output_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *P_output_xonly,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 274,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "0a79d3a2e516d7dea07023e68a94aa37842f9be5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could maybe consider removing the `P_` prefix as we don't use this naming scheme anywhere else in this or other modules (I think I introduced that in the first take of the BIP352 module for some reason)",
      "created_at": "2025-08-05T13:12:28Z",
      "updated_at": "2025-08-05T13:33:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2254306773",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254306773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 415,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263241107",
      "pull_request_review_id": 3101192531,
      "id": 2263241107,
      "node_id": "PRRC_kwDOAP4Jqs6G5lGT",
      "diff_hunk": "@@ -53,7 +56,7 @@ typedef struct secp256k1_silentpayments_recipient {\n  *  public keys are excluded from silent payments eligible inputs; see BIP352\n  *  for more information.\n  *\n- *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 22,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "32d8077cb7d288c7114dcf8d7b831d7ada590bd0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 32d8077cb7d288c7114dcf8d7b831d7ada590bd0: minimum-diff pedantic nit: this change, as well as all other single-line changes in the same commit below should already be part of an earlier commit",
      "created_at": "2025-08-08T15:09:42Z",
      "updated_at": "2025-08-08T15:58:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2263241107",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263241107"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 56,
      "start_side": "LEFT",
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263288446",
      "pull_request_review_id": 3101192531,
      "id": 2263288446,
      "node_id": "PRRC_kwDOAP4Jqs6G5wp-",
      "diff_hunk": "@@ -25,6 +26,97 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the secret keys correspond to x-only\n+ *  (taproot) outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (stastically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 56,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d176c1e5d83298e9f60e4d34fe6f40b1a4e679c5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *             (statistically improbable).\r\n```\r\n(here and in many other instances)",
      "created_at": "2025-08-08T15:30:40Z",
      "updated_at": "2025-08-08T15:58:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2263288446",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263288446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263308971",
      "pull_request_review_id": 3101192531,
      "id": 2263308971,
      "node_id": "PRRC_kwDOAP4Jqs6G51qr",
      "diff_hunk": "@@ -25,6 +26,97 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 48,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d176c1e5d83298e9f60e4d34fe6f40b1a4e679c5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Not knowing the answer myself, but I'm wondering now whether internal details like this should be part of the header API documentation (that's slightly related to the questions brought up at https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3159769239 about the proper detail level of error case documentation), or if it's just sufficient to say that there are two secret key types that are somehow treated differently. Or even just remove the sentence completely (and the \"For that reason\" part). Maybe it's not a big deal to keep it, but I'd assume the user of the module likely doesn't care (and shouldn't) what exactly is going on under the hood at this detail level. That sentence was already part of the first take at #1471, so all the blame goes to me anyways :sweat_smile: ",
      "created_at": "2025-08-08T15:41:05Z",
      "updated_at": "2025-08-08T15:58:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2263308971",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263308971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2265970427",
      "pull_request_review_id": 3104590579,
      "id": 2265970427,
      "node_id": "PRRC_kwDOAP4Jqs6HD_b7",
      "diff_hunk": "@@ -25,6 +26,97 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 48,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d176c1e5d83298e9f60e4d34fe6f40b1a4e679c5",
      "in_reply_to_id": 2263308971,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch, I think keeping the API documentation focused on usage makes sense. In this case, I think we can safely drop line 65 to the end. `libsecp256k1` already has different data types for plain keys and taproot keys, which I think is explanation enough for a user as to why we have two different arguments for accepting secret keys in this function.",
      "created_at": "2025-08-11T08:06:55Z",
      "updated_at": "2025-08-11T08:06:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2265970427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2265970427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2265971983",
      "pull_request_review_id": 3104592755,
      "id": 2265971983,
      "node_id": "PRRC_kwDOAP4Jqs6HD_0P",
      "diff_hunk": "@@ -25,6 +26,97 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the secret keys correspond to x-only\n+ *  (taproot) outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (stastically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 56,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d176c1e5d83298e9f60e4d34fe6f40b1a4e679c5",
      "in_reply_to_id": 2263288446,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Turns out I am not as good a typist as I thought I was 😅 ",
      "created_at": "2025-08-11T08:07:46Z",
      "updated_at": "2025-08-11T08:07:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2265971983",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2265971983"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268166071",
      "pull_request_review_id": 3107973701,
      "id": 2268166071,
      "node_id": "PRRC_kwDOAP4Jqs6HMXe3",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *             Seckey: secret key for Alice\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46,0x0d,0x68,0x08,0x65,0x64,0x45,0xee,\n+    0x4d,0x4e,0xc0,0x8e,0xba,0x8a,0x66,0xea,\n+    0x66,0x8e,0x4e,0x12,0x98,0x9a,0x0e,0x60,\n+    0x4b,0x5c,0x36,0x0e,0x43,0xf5,0x5a,0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7,0xf3,0xc6,0x79,0x30,0x4a,0xef,0x8c,\n+    0xc0,0xc7,0x61,0xf1,0x00,0x99,0xdd,0x7b,\n+    0x20,0x65,0x20,0xd7,0x11,0x6f,0xb7,0x91,\n+    0xee,0x74,0x54,0xa2,0xfc,0x22,0x79,0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b,0x81,0x34,0x5d,0x53,0x89,0xba,0xa3,\n+    0xd8,0x93,0xe2,0xfb,0xe7,0x08,0xdd,0x6d,\n+    0x82,0xdc,0xd8,0x49,0xab,0x03,0xc1,0xdb,\n+    0x68,0xbe,0xc7,0xe9,0x2a,0x45,0xfa,0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea,0xdc,0x78,0x16,0x5f,0xf1,0xf8,0xea,\n+    0x94,0xad,0x7c,0xfd,0xc5,0x49,0x90,0x73,\n+    0x8a,0x4c,0x53,0xf6,0xe0,0x50,0x7b,0x42,\n+    0x15,0x42,0x01,0xb8,0xe5,0xdf,0xf3,0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}\n+\n+static void test_send_api(void) {\n+    unsigned char (*sp_addresses[2])[2][33];\n+    unsigned char const *p[1];\n+    secp256k1_keypair const *t[1];\n+    secp256k1_silentpayments_recipient r[2];\n+    const secp256k1_silentpayments_recipient *rp[2];\n+    secp256k1_xonly_pubkey o[2];\n+    secp256k1_xonly_pubkey *op[2];\n+    secp256k1_keypair taproot;\n+    size_t i;\n+\n+    /* Set up Bob and Carol as the recipients */\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        /* Set the index value incorrectly */\n+        r[i].index = 0;\n+        rp[i] = &r[i];\n+        op[i] = &o[i];\n+    }\n+    /* Set up a taproot key and a plain key for Alice */\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    t[0] = &taproot;\n+    p[0] = ALICE_SECKEY;\n+\n+    /* Fails if the index is set incorrectly */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Set the index correctly for the next tests */\n+    for (i = 0; i < 2; i++) {\n+        r[i].index = i;\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that null arguments are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, NULL, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, NULL, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, NULL, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 1));\n+\n+    /* Check correct context is used */\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_silentpayments_sender_create_outputs(STATIC_CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that array arguments are verified */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, NULL, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 0, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 0));\n+\n+    /* Create malformed keys for Alice by using a key that will overflow */\n+    p[0] = ORDERC;\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    /* Malleate the keypair object so that the secret key is all zeros. We need to keep\n+     * public key as is since it is loaded first and would hit an ARG_CHECK if invalid.\n+     */\n+    memset(&taproot.data[0], 0, 32);\n+    /* Check that an invalid plain secret key is caught */\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    /* Check that an invalid keypair is caught */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 0));\n+    /* Create malformed keys for Alice by using a zero'd seckey */\n+    p[0] = MALFORMED_SECKEY;\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    p[0] = ALICE_SECKEY;\n+    /* Create malformed recipients by setting all of the public key bytes to zero.\n+     * Realistically, this would never happen since a bad public key would get caught when\n+     * trying to parse the public key with _ec_pubkey_parse\n+     */\n+    memset(&r[1].labeled_spend_pubkey.data, 0, sizeof(secp256k1_pubkey));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    {\n+         secp256k1_pubkey tmp = r[1].labeled_spend_pubkey;\n+         memset(&r[1].labeled_spend_pubkey, 0, sizeof(r[1].labeled_spend_pubkey));\n+         CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 237,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "051ad339427fa7e69246e372b98d61c5a0e04ab0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems like this `memset` is a no-op and the test a repetition of the one four lines above. Was the idea here to run the previous test without damaging the spend pubkey of `r[1]` first? (would make sense considering that it is saved and restored via `tmp`)",
      "created_at": "2025-08-11T22:43:06Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268166071",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268166071"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 236,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268167935",
      "pull_request_review_id": 3107973701,
      "id": 2268167935,
      "node_id": "PRRC_kwDOAP4Jqs6HMX7_",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *             Seckey: secret key for Alice\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 19,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "051ad339427fa7e69246e372b98d61c5a0e04ab0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nitty nit: for easier matching for the reader, could sort these constant descriptions in the same order as they appear in the array definitions below",
      "created_at": "2025-08-11T22:44:43Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268167935",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268167935"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 13,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268208257",
      "pull_request_review_id": 3107973701,
      "id": 2268208257,
      "node_id": "PRRC_kwDOAP4Jqs6HMhyB",
      "diff_hunk": "@@ -164,6 +167,262 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 135,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: slightly more specific (as the current wording implies that the actual cache data structure can be created with this module)\r\n```suggestion\r\n *  For creating the labels cache data (label public key and label tweak),\r\n```\r\nor just\r\n```suggestion\r\n *  For creating the labels cache data,\r\n```",
      "created_at": "2025-08-11T23:20:14Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268208257",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268208257"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268232573",
      "pull_request_review_id": 3107973701,
      "id": 2268232573,
      "node_id": "PRRC_kwDOAP4Jqs6HMnt9",
      "diff_hunk": "@@ -131,28 +131,28 @@ static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, co\n     secp256k1_sha256_clear(&hash);\n }\n \n-static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n-    secp256k1_ge P_output_ge;\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "reviewer-friendliness nit: the P_ prefix removal should be part of an earlier commit already to not create extra diff lines",
      "created_at": "2025-08-11T23:37:16Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268232573",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268232573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268236399",
      "pull_request_review_id": 3107973701,
      "id": 2268236399,
      "node_id": "PRRC_kwDOAP4Jqs6HMopv",
      "diff_hunk": "@@ -375,4 +375,350 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(pubkeylen == 33);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 167,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "for consistency, could still `VERIFY_CHECK` the return values of these two function calls",
      "created_at": "2025-08-11T23:41:50Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268236399",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268236399"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 503,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 505,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268250793",
      "pull_request_review_id": 3107973701,
      "id": 2268250793,
      "node_id": "PRRC_kwDOAP4Jqs6HMsKp",
      "diff_hunk": "@@ -375,4 +375,350 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(pubkeylen == 33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided) */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge P_output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&P_output_negated_ge, &P_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 * label1 = tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* serialize must succeed because the point was just loaded */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 * label2 = -tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* serialize must succeed because the point was just loaded */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[n_found]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[n_found]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 */\n+                ret = secp256k1_ec_seckey_tweak_add(ctx, found_outputs[n_found]->tweak, label_tweak);\n+                VERIFY_CHECK(ret);\n+                secp256k1_pubkey_save(&found_outputs[n_found]->label, &label_ge);\n+            } else {\n+                found_outputs[n_found]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value */\n+                secp256k1_memclear(&found_outputs[n_found]->label, sizeof(secp256k1_pubkey));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 328,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: a regular `memset` is sufficient here, as this is no stack data (and not secret data either)",
      "created_at": "2025-08-11T23:56:57Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268250793",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268250793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 666,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268254431",
      "pull_request_review_id": 3107973701,
      "id": 2268254431,
      "node_id": "PRRC_kwDOAP4Jqs6HMtDf",
      "diff_hunk": "@@ -375,4 +375,350 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(pubkeylen == 33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided) */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge P_output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&P_output_negated_ge, &P_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 * label1 = tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* serialize must succeed because the point was just loaded */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 * label2 = -tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* serialize must succeed because the point was just loaded */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[n_found]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[n_found]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 */\n+                ret = secp256k1_ec_seckey_tweak_add(ctx, found_outputs[n_found]->tweak, label_tweak);\n+                VERIFY_CHECK(ret);\n+                secp256k1_pubkey_save(&found_outputs[n_found]->label, &label_ge);\n+            } else {\n+                found_outputs[n_found]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value */\n+                secp256k1_memclear(&found_outputs[n_found]->label, sizeof(secp256k1_pubkey));\n+            }\n+            /* Set everything for the next round of scanning */\n+            label_tweak = NULL;\n+            n_found++;\n+            k++;\n+        } else {\n+            break;\n+        }\n+    }\n+    *n_found_outputs = n_found;\n+    /* Explicitly clear secrets. Recall that the scan key is not quite \"secret\" in that leaking the scan key\n+     * results in a loss of privacy, not a loss of funds\n+     */\n+    secp256k1_scalar_clear(&rsk_scalar);\n+    /* Explicitly clear the shared secret. While this isn't technically \"secret data,\" any third party\n+     * with access to the shared secret could potentially identify and link the transaction back to the\n+     * recipient address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    secp256k1_memclear(shared_secret, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const unsigned char *recipient_scan_key32, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_scalar rsk;\n+    secp256k1_ge A_tweaked_ge;\n+    int ret;\n+    /* Sanity check inputs */\n+    ARG_CHECK(shared_secret33 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(public_data->data[4] == 1);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(&A_tweaked_ge, &public_data->data[5]);\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk, recipient_scan_key32);\n+    /* If there are any issues with the recipient scan key, return early */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret33, &rsk, &A_tweaked_ge);\n+\n+    /* Explicitly clear secrets */\n+    secp256k1_scalar_clear(&rsk);\n+    return ret;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 373,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "equivalent but more explicit (ret can only be 1 at this point)\r\n```suggestion\r\n    return 1;\r\n```",
      "created_at": "2025-08-12T00:00:18Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268254431",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268254431"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 711,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268280579",
      "pull_request_review_id": 3107973701,
      "id": 2268280579,
      "node_id": "PRRC_kwDOAP4Jqs6HMzcD",
      "diff_hunk": "@@ -273,6 +274,10 @@ src/wycheproof/ecdh_secp256k1_test.h:\n \tmkdir -p $(@D)\n \tpython3 $(top_srcdir)/tools/tests_wycheproof_generate_ecdh.py $(top_srcdir)/src/wycheproof/ecdh_secp256k1_test.json > $@\n \n+src/modules/silentpayments/vectors.h:\n+\tmkdir -p $(@D)\n+\tpython3 $(top_srcdir)/tools/tests_silentpayments_generate.py $(top_srcdir)/src/modules/silentpayments/bip352_send_and_receive_test_vectors.json > $@",
      "path": "Makefile.am",
      "position": 32,
      "original_position": 14,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "b1138b20a45adff4818b023d7ea80569e3dacaba",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "unrelated nit: noted that there is no CMake-equivalent for that, but it's not for any other generated test vectors either, so probably a topic for a different PR (if at all, I assume test vectors are usually just updated by manual script runs rather than involving the build system)",
      "created_at": "2025-08-12T00:23:41Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268280579",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268280579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 277,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269183460",
      "pull_request_review_id": 3109372347,
      "id": 2269183460,
      "node_id": "PRRC_kwDOAP4Jqs6HQP3k",
      "diff_hunk": "@@ -164,6 +167,262 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 135,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": 2268208257,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think \"data\" should be sufficient, considering the data is better explained in the documentation for the `_create_label` function.",
      "created_at": "2025-08-12T08:59:10Z",
      "updated_at": "2025-08-12T08:59:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269183460",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269183460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269244971",
      "pull_request_review_id": 3109482971,
      "id": 2269244971,
      "node_id": "PRRC_kwDOAP4Jqs6HQe4r",
      "diff_hunk": "@@ -273,6 +274,10 @@ src/wycheproof/ecdh_secp256k1_test.h:\n \tmkdir -p $(@D)\n \tpython3 $(top_srcdir)/tools/tests_wycheproof_generate_ecdh.py $(top_srcdir)/src/wycheproof/ecdh_secp256k1_test.json > $@\n \n+src/modules/silentpayments/vectors.h:\n+\tmkdir -p $(@D)\n+\tpython3 $(top_srcdir)/tools/tests_silentpayments_generate.py $(top_srcdir)/src/modules/silentpayments/bip352_send_and_receive_test_vectors.json > $@",
      "path": "Makefile.am",
      "position": 32,
      "original_position": 14,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "b1138b20a45adff4818b023d7ea80569e3dacaba",
      "in_reply_to_id": 2268280579,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Would consider this a follow-up as a more general build system improvement.",
      "created_at": "2025-08-12T09:22:31Z",
      "updated_at": "2025-08-12T09:22:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269244971",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269244971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 277,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269261738",
      "pull_request_review_id": 3109526848,
      "id": 2269261738,
      "node_id": "PRRC_kwDOAP4Jqs6HQi-q",
      "diff_hunk": "@@ -273,6 +274,10 @@ src/wycheproof/ecdh_secp256k1_test.h:\n \tmkdir -p $(@D)\n \tpython3 $(top_srcdir)/tools/tests_wycheproof_generate_ecdh.py $(top_srcdir)/src/wycheproof/ecdh_secp256k1_test.json > $@\n \n+src/modules/silentpayments/vectors.h:\n+\tmkdir -p $(@D)\n+\tpython3 $(top_srcdir)/tools/tests_silentpayments_generate.py $(top_srcdir)/src/modules/silentpayments/bip352_send_and_receive_test_vectors.json > $@",
      "path": "Makefile.am",
      "position": 32,
      "original_position": 14,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "b1138b20a45adff4818b023d7ea80569e3dacaba",
      "in_reply_to_id": 2268280579,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> (if at all, I assume test vectors are usually just updated by manual script runs rather than involving the build system)\r\n\r\nThe current idea is that you can manually delete the files, and the build system will then regenerate them (and you don't need to worry about how this is done). And yes, that's restricted to autotools, which is fine because it's a developer-only thing. Decoupling this from the build system entirely would also be an option.\r\n\r\nAnyway, none of this is related to this PR.",
      "created_at": "2025-08-12T09:29:18Z",
      "updated_at": "2025-08-12T09:29:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269261738",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269261738"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 277,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269272477",
      "pull_request_review_id": 3109559266,
      "id": 2269272477,
      "node_id": "PRRC_kwDOAP4Jqs6HQlmd",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *             Seckey: secret key for Alice\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46,0x0d,0x68,0x08,0x65,0x64,0x45,0xee,\n+    0x4d,0x4e,0xc0,0x8e,0xba,0x8a,0x66,0xea,\n+    0x66,0x8e,0x4e,0x12,0x98,0x9a,0x0e,0x60,\n+    0x4b,0x5c,0x36,0x0e,0x43,0xf5,0x5a,0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7,0xf3,0xc6,0x79,0x30,0x4a,0xef,0x8c,\n+    0xc0,0xc7,0x61,0xf1,0x00,0x99,0xdd,0x7b,\n+    0x20,0x65,0x20,0xd7,0x11,0x6f,0xb7,0x91,\n+    0xee,0x74,0x54,0xa2,0xfc,0x22,0x79,0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b,0x81,0x34,0x5d,0x53,0x89,0xba,0xa3,\n+    0xd8,0x93,0xe2,0xfb,0xe7,0x08,0xdd,0x6d,\n+    0x82,0xdc,0xd8,0x49,0xab,0x03,0xc1,0xdb,\n+    0x68,0xbe,0xc7,0xe9,0x2a,0x45,0xfa,0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea,0xdc,0x78,0x16,0x5f,0xf1,0xf8,0xea,\n+    0x94,0xad,0x7c,0xfd,0xc5,0x49,0x90,0x73,\n+    0x8a,0x4c,0x53,0xf6,0xe0,0x50,0x7b,0x42,\n+    0x15,0x42,0x01,0xb8,0xe5,0xdf,0xf3,0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}\n+\n+static void test_send_api(void) {\n+    unsigned char (*sp_addresses[2])[2][33];\n+    unsigned char const *p[1];\n+    secp256k1_keypair const *t[1];\n+    secp256k1_silentpayments_recipient r[2];\n+    const secp256k1_silentpayments_recipient *rp[2];\n+    secp256k1_xonly_pubkey o[2];\n+    secp256k1_xonly_pubkey *op[2];\n+    secp256k1_keypair taproot;\n+    size_t i;\n+\n+    /* Set up Bob and Carol as the recipients */\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        /* Set the index value incorrectly */\n+        r[i].index = 0;\n+        rp[i] = &r[i];\n+        op[i] = &o[i];\n+    }\n+    /* Set up a taproot key and a plain key for Alice */\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    t[0] = &taproot;\n+    p[0] = ALICE_SECKEY;\n+\n+    /* Fails if the index is set incorrectly */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Set the index correctly for the next tests */\n+    for (i = 0; i < 2; i++) {\n+        r[i].index = i;\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that null arguments are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, NULL, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, NULL, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, NULL, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 1));\n+\n+    /* Check correct context is used */\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_silentpayments_sender_create_outputs(STATIC_CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that array arguments are verified */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, NULL, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 0, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 0));\n+\n+    /* Create malformed keys for Alice by using a key that will overflow */\n+    p[0] = ORDERC;\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    /* Malleate the keypair object so that the secret key is all zeros. We need to keep\n+     * public key as is since it is loaded first and would hit an ARG_CHECK if invalid.\n+     */\n+    memset(&taproot.data[0], 0, 32);\n+    /* Check that an invalid plain secret key is caught */\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    /* Check that an invalid keypair is caught */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 0));\n+    /* Create malformed keys for Alice by using a zero'd seckey */\n+    p[0] = MALFORMED_SECKEY;\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    p[0] = ALICE_SECKEY;\n+    /* Create malformed recipients by setting all of the public key bytes to zero.\n+     * Realistically, this would never happen since a bad public key would get caught when\n+     * trying to parse the public key with _ec_pubkey_parse\n+     */\n+    memset(&r[1].labeled_spend_pubkey.data, 0, sizeof(secp256k1_pubkey));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    {\n+         secp256k1_pubkey tmp = r[1].labeled_spend_pubkey;\n+         memset(&r[1].labeled_spend_pubkey, 0, sizeof(r[1].labeled_spend_pubkey));\n+         CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 237,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "051ad339427fa7e69246e372b98d61c5a0e04ab0",
      "in_reply_to_id": 2268166071,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I believe the lines above were a leftover. The idea, as you mention, was to add coverage for a damaged spend pubkey and a damaged scan pubkey. I removed the old lines in favour of the two test cases using the tmp values.",
      "created_at": "2025-08-12T09:33:21Z",
      "updated_at": "2025-08-12T09:33:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269272477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269272477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 236,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269287929",
      "pull_request_review_id": 3109600166,
      "id": 2269287929,
      "node_id": "PRRC_kwDOAP4Jqs6HQpX5",
      "diff_hunk": "@@ -397,6 +401,19 @@ SECP_CFLAGS=\"$SECP_CFLAGS $WERROR_CFLAGS\"\n \n # Processing must be done in a reverse topological sorting of the dependency graph\n # (dependent module first).\n+if test x\"$enable_module_silentpayments\" = x\"yes\"; then\n+  if test x\"$enable_module_schnorrsig\" = x\"no\"; then\n+    AC_MSG_ERROR([Module dependency error: You have disabled the schnorrsig module explicitly, but it is required by the silentpayments module.])\n+  fi\n+  enable_module_schnorrsig=yes\n+\n+  if test x\"$enable_module_extrakeys\" = x\"no\"; then\n+    AC_MSG_ERROR([Module dependency error: You have disabled the extrakeys module explicitly, but it is required by the silentpayments module.])\n+  fi\n+  enable_module_extrakeys=yes",
      "path": "configure.ac",
      "position": 1,
      "original_position": 24,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "ca2538a8782628437488ca32c49f52957aff5f69",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/1698/commits/ca2538a8782628437488ca32c49f52957aff5f69 I'd drop this check for consistency. (But nothing bad happens if we keep it.) \r\n - Musig also depends on schnorrsig and thus transitively on extrakeys, but we don't check for this.\r\n - You don't add an equivalent check to CMake\r\n\r\n```suggestion\r\n```",
      "created_at": "2025-08-12T09:38:46Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269287929",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269287929"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 409,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 413,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269412021",
      "pull_request_review_id": 3109600166,
      "id": 2269412021,
      "node_id": "PRRC_kwDOAP4Jqs6HRHq1",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 224,
      "original_position": 203,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nIs there a reason why we require the user to set this instead of setting it ourselves? This would make the API simpler and easier to explain.",
      "created_at": "2025-08-12T10:28:51Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269412021",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269412021"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 222,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269421036",
      "pull_request_review_id": 3109600166,
      "id": 2269421036,
      "node_id": "PRRC_kwDOAP4Jqs6HRJ3s",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 24,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nsome writing improvements. if you take them, please reformat \r\n\r\n```suggestion\r\n/** The data from a single recipient address\r\n *\r\n *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\r\n *\r\n *  `index` must be set to the position (starting with 0) of this recipient in the\r\n *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\r\n *  used to map the returned generated outputs back to the original recipient.\r\n *\r\n *  Note:\r\n *  The spend public key field is named `labeled_spend_pubkey` to indicate that this\r\n *  spend public key may have been optionally tweaked with a label by the sender.  \r\n *  This is purely a documentation convention to differentiate \r\n *  between other uses of `spend_pubkey` in this API, where it is meant to refer\r\n *  to the unlabeled spend public key.\r\n *  Whether `labeled_spend_pubkey` has actually been tagged is irrelevant\r\n *  for the sender and\r\n */\r\n```\r\n\r\n - Would it be nicer for the user if we had `spend_pubkey` and `unlabeled_spend_pubkey` or (`raw_` or whatever) instead?",
      "created_at": "2025-08-12T10:32:55Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269421036",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269421036"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269422761",
      "pull_request_review_id": 3109600166,
      "id": 2269422761,
      "node_id": "PRRC_kwDOAP4Jqs6HRKSp",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 13,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nwant to add a test for this property? (this also makes review easier)",
      "created_at": "2025-08-12T10:33:40Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269422761",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269422761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269424684",
      "pull_request_review_id": 3109600166,
      "id": 2269424684,
      "node_id": "PRRC_kwDOAP4Jqs6HRKws",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 35,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nnit: inconsistent spacing",
      "created_at": "2025-08-12T10:34:30Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269424684",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269424684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 23,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269446844",
      "pull_request_review_id": 3109862400,
      "id": 2269446844,
      "node_id": "PRRC_kwDOAP4Jqs6HRQK8",
      "diff_hunk": "@@ -273,6 +274,10 @@ src/wycheproof/ecdh_secp256k1_test.h:\n \tmkdir -p $(@D)\n \tpython3 $(top_srcdir)/tools/tests_wycheproof_generate_ecdh.py $(top_srcdir)/src/wycheproof/ecdh_secp256k1_test.json > $@\n \n+src/modules/silentpayments/vectors.h:\n+\tmkdir -p $(@D)\n+\tpython3 $(top_srcdir)/tools/tests_silentpayments_generate.py $(top_srcdir)/src/modules/silentpayments/bip352_send_and_receive_test_vectors.json > $@",
      "path": "Makefile.am",
      "position": 32,
      "original_position": 14,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "b1138b20a45adff4818b023d7ea80569e3dacaba",
      "in_reply_to_id": 2268280579,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I opened https://github.com/bitcoin-core/secp256k1/issues/1723 as a follow-up. Mostly because I think it would be really nice to keep the build systems consistent, and I got curious on what this would look like for CMake.",
      "created_at": "2025-08-12T10:44:16Z",
      "updated_at": "2025-08-12T10:44:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269446844",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269446844"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 277,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269449070",
      "pull_request_review_id": 3109600166,
      "id": 2269449070,
      "node_id": "PRRC_kwDOAP4Jqs6HRQtu",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 48,
      "original_position": 33,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "see https://gist.github.com/real-or-random/a4aaae5d04eee9f63e7a2e43d25bc2b1#file-sha256_midstate-py\r\n\r\nBut I think the \"proper\"TM way is that josie adds a test that checks if the finalized hash is the same as when recomputed from scratch, see https://github.com/bitcoin-core/secp256k1/blob/e523e4f90e1b1c0fba49cd8a08016e1a8dff9232/src/modules/musig/tests_impl.h#L551-L586. Then the reviewer only needs to review this check.",
      "created_at": "2025-08-12T10:45:14Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269449070",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269449070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269451956",
      "pull_request_review_id": 3109600166,
      "id": 2269451956,
      "node_id": "PRRC_kwDOAP4Jqs6HRRa0",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46,0x0d,0x68,0x08,0x65,0x64,0x45,0xee,\n+    0x4d,0x4e,0xc0,0x8e,0xba,0x8a,0x66,0xea,\n+    0x66,0x8e,0x4e,0x12,0x98,0x9a,0x0e,0x60,\n+    0x4b,0x5c,0x36,0x0e,0x43,0xf5,0x5a,0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7,0xf3,0xc6,0x79,0x30,0x4a,0xef,0x8c,\n+    0xc0,0xc7,0x61,0xf1,0x00,0x99,0xdd,0x7b,\n+    0x20,0x65,0x20,0xd7,0x11,0x6f,0xb7,0x91,\n+    0xee,0x74,0x54,0xa2,0xfc,0x22,0x79,0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b,0x81,0x34,0x5d,0x53,0x89,0xba,0xa3,\n+    0xd8,0x93,0xe2,0xfb,0xe7,0x08,0xdd,0x6d,\n+    0x82,0xdc,0xd8,0x49,0xab,0x03,0xc1,0xdb,\n+    0x68,0xbe,0xc7,0xe9,0x2a,0x45,0xfa,0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea,0xdc,0x78,0x16,0x5f,0xf1,0xf8,0xea,\n+    0x94,0xad,0x7c,0xfd,0xc5,0x49,0x90,0x73,\n+    0x8a,0x4c,0x53,0xf6,0xe0,0x50,0x7b,0x42,\n+    0x15,0x42,0x01,0xb8,0xe5,0xdf,0xf3,0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret);",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 114,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\n```suggestion\r\n    CHECK(ret == 1);\r\n```\r\nthis is what the docs promise.",
      "created_at": "2025-08-12T10:46:31Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269451956",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269451956"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269487878",
      "pull_request_review_id": 3109923614,
      "id": 2269487878,
      "node_id": "PRRC_kwDOAP4Jqs6HRaMG",
      "diff_hunk": "@@ -22,6 +22,7 @@ Features:\n * Optional module for Schnorr signatures according to [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n * Optional module for ElligatorSwift key exchange according to [BIP-324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki).\n * Optional module for MuSig2 Schnorr multi-signatures according to [BIP-327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki).\n+* Optional module for Silent Payments send and receive according to [BIP-352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki).",
      "path": "README.md",
      "position": 1,
      "original_position": 4,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/2b57d2ad8964e536508fae0b6ab1331396fe0308\r\nnit: I suggest \"sending and receiving\"",
      "created_at": "2025-08-12T11:01:38Z",
      "updated_at": "2025-08-12T11:01:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269487878",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269487878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2270403564",
      "pull_request_review_id": 3111636132,
      "id": 2270403564,
      "node_id": "PRRC_kwDOAP4Jqs6HU5vs",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 61,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nsorted by what?\r\nAnd do we want to make this guarantee in the API?",
      "created_at": "2025-08-12T15:57:00Z",
      "updated_at": "2025-08-12T15:59:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2270403564",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2270403564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2270416794",
      "pull_request_review_id": 3111636132,
      "id": 2270416794,
      "node_id": "PRRC_kwDOAP4Jqs6HU8-a",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 12,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nrelated to the other comment in this review: Are you saying here that the user should not rely on int `secp256k1_silentpayments_sender_create_outputs` sorting the recipients? If yes, this contradicts the API docs. (And  the implementation file is the wrong place to make such a statement.)\r\n ",
      "created_at": "2025-08-12T15:59:38Z",
      "updated_at": "2025-08-12T15:59:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2270416794",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2270416794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273846219",
      "pull_request_review_id": 3116575816,
      "id": 2273846219,
      "node_id": "PRRC_kwDOAP4Jqs6HiCPL",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 35,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269424684,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Took a moment to look how secret keys and public keys are formatted in the other tests, will update these to match the rest of the library.",
      "created_at": "2025-08-13T15:34:59Z",
      "updated_at": "2025-08-13T15:34:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2273846219",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273846219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 23,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273870546",
      "pull_request_review_id": 3116608081,
      "id": 2273870546,
      "node_id": "PRRC_kwDOAP4Jqs6HiILS",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 13,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269422761,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I copied this value from https://github.com/bitcoin-core/secp256k1/blob/d599714147b20dda092ec4af44ef4174d584bb7d/src/tests.c#L6031-L6037 , where it is comprehensively tested. Would a comment pointing the reviewer to the edge case test be sufficient? Also happy to duplicate a subset of the edge case test over here if that's preferred.",
      "created_at": "2025-08-13T15:44:28Z",
      "updated_at": "2025-08-13T15:44:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2273870546",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273870546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273874700",
      "pull_request_review_id": 3116613458,
      "id": 2273874700,
      "node_id": "PRRC_kwDOAP4Jqs6HiJMM",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 48,
      "original_position": 33,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree on the \"proper\" approach, thanks for the pointer to the musig test. I'll add the same here.",
      "created_at": "2025-08-13T15:46:05Z",
      "updated_at": "2025-08-13T15:46:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2273874700",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273874700"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273887476",
      "pull_request_review_id": 3116629861,
      "id": 2273887476,
      "node_id": "PRRC_kwDOAP4Jqs6HiMT0",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 24,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269421036,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think what you're suggesting makes more sense. As the comment already mentions, from the senders perspective it is always just a spend public key. Using this naming convention, we could simplify the docs here and instead move the explainer to the label API docs, where it is actually important that the user of the API understand the distinction. ",
      "created_at": "2025-08-13T15:51:08Z",
      "updated_at": "2025-08-13T15:51:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2273887476",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273887476"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276141026",
      "pull_request_review_id": 3119903531,
      "id": 2276141026,
      "node_id": "PRRC_kwDOAP4Jqs6Hqyfi",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 13,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269422761,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, I see. Then I suggest copying the line `    CHECK(secp256k1_ec_seckey_verify(CTX, orderc) == 0);` . This saves the reviewer from looking up the group order and doing the comparison manually.  ",
      "created_at": "2025-08-14T09:49:18Z",
      "updated_at": "2025-08-14T09:49:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276141026",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276141026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276470356",
      "pull_request_review_id": 3120376843,
      "id": 2276470356,
      "node_id": "PRRC_kwDOAP4Jqs6HsC5U",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 224,
      "original_position": 203,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269412021,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I vaguely remember discussing this with you and @jonasnick previously where we were debating back and forth on whether the caller should set this or we should set it internally. The preference was to have the caller set the value as this seemed the least confusing of our options, but I can't recall the reasons why 😅 .\r\n\r\nIf we keep the `index` field in the struct, then I do think we should have the caller set it, as it seems even more confusing to have the caller create the recipient structs without fully initialising them. That leaves removing the field entirely from the struct, but I don't think there is a (sane) way to keep track of the original ordering internally so that we can ensure we map the generated outputs back to the original ordering.\r\n\r\nSo I'd prefer to leave it as-is, but perhaps we can better explain this in the API documentation?\r\n\r\n",
      "created_at": "2025-08-14T12:18:31Z",
      "updated_at": "2025-08-14T12:18:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276470356",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276470356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 222,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276476304",
      "pull_request_review_id": 3120385029,
      "id": 2276476304,
      "node_id": "PRRC_kwDOAP4Jqs6HsEWQ",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 61,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270403564,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"Sorting\" is an implementation detail, since sorting is simply the method we are using to \"group\" the addresses by scan key. Given that, its probably better to remove all references to sorting from the API docs and instead use \"grouping\" to match the language in the BIP?",
      "created_at": "2025-08-14T12:21:11Z",
      "updated_at": "2025-08-14T12:21:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276476304",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276476304"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276490048",
      "pull_request_review_id": 3120403417,
      "id": 2276490048,
      "node_id": "PRRC_kwDOAP4Jqs6HsHtA",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 61,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270403564,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What about:\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\nindex f547207..108c61c 100644\r\n--- a/include/secp256k1_silentpayments.h\r\n+++ b/include/secp256k1_silentpayments.h\r\n@@ -80,14 +80,15 @@ typedef struct secp256k1_silentpayments_recipient {\r\n  *                            recipients, where each recipient is a scan public\r\n  *                            key, a spend public key, and an index indicating\r\n  *                            its position in the original ordering. The\r\n- *                            recipient array will be sorted in place, but\r\n- *                            generated outputs are saved in the\r\n- *                            `generated_outputs` array to match the ordering\r\n- *                            from the index field. This ensures the caller is\r\n- *                            able to match the generated outputs to the\r\n- *                            correct silent payment addresses. The same\r\n- *                            recipient can be passed multiple times to create\r\n- *                            multiple outputs for the same recipient.\r\n+ *                            recipient array will be grouped by scan public key\r\n+ *                            in place (as specified in BIP0352), but generated\r\n+ *                            outputs are saved in the `generated_outputs` array\r\n+ *                            to match the original ordering (using the index\r\n+ *                            field). This ensures the caller is able to match\r\n+ *                            the generated outputs to the correct silent\r\n+ *                            payment addresses. The same recipient can be\r\n+ *                            passed multiple times to create multiple outputs\r\n+ *                            for the same recipient.\r\n  *              n_recipients: the number of recipients. This is equal to the\r\n  *                            total number of outputs to be generated as each\r\n  *                            recipient may passed multiple times to generate",
      "created_at": "2025-08-14T12:27:37Z",
      "updated_at": "2025-08-14T12:27:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276490048",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276490048"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276501470",
      "pull_request_review_id": 3120418978,
      "id": 2276501470,
      "node_id": "PRRC_kwDOAP4Jqs6HsKfe",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 12,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270416794,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looking at this with fresh eyes, I think the need for this comment arose from the fact the API docs were perhaps giving too much information about the sorting implementation and creating confusion.\r\n\r\nI think it would be better to remove any mentions of sorting from the API, e.g., https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276490048, and then remove the \"Note: \" clarifying comment.",
      "created_at": "2025-08-14T12:32:44Z",
      "updated_at": "2025-08-14T12:33:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276501470",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276501470"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276546031",
      "pull_request_review_id": 3120477921,
      "id": 2276546031,
      "node_id": "PRRC_kwDOAP4Jqs6HsVXv",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 61,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270403564,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Pushed a slight variant of this, lmk what you think.",
      "created_at": "2025-08-14T12:52:12Z",
      "updated_at": "2025-08-14T12:52:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276546031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276546031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276547977",
      "pull_request_review_id": 3120480364,
      "id": 2276547977,
      "node_id": "PRRC_kwDOAP4Jqs6HsV2J",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 13,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269422761,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added!",
      "created_at": "2025-08-14T12:52:58Z",
      "updated_at": "2025-08-14T12:52:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276547977",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276547977"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276549549",
      "pull_request_review_id": 3120482368,
      "id": 2276549549,
      "node_id": "PRRC_kwDOAP4Jqs6HsWOt",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 24,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269421036,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated to use `spend_pubkey` and `unlabeled_spend_pubkey`, which I think is much better than what we had before.",
      "created_at": "2025-08-14T12:53:37Z",
      "updated_at": "2025-08-14T12:53:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276549549",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276549549"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276550991",
      "pull_request_review_id": 3120484014,
      "id": 2276550991,
      "node_id": "PRRC_kwDOAP4Jqs6HsWlP",
      "diff_hunk": "@@ -397,6 +401,19 @@ SECP_CFLAGS=\"$SECP_CFLAGS $WERROR_CFLAGS\"\n \n # Processing must be done in a reverse topological sorting of the dependency graph\n # (dependent module first).\n+if test x\"$enable_module_silentpayments\" = x\"yes\"; then\n+  if test x\"$enable_module_schnorrsig\" = x\"no\"; then\n+    AC_MSG_ERROR([Module dependency error: You have disabled the schnorrsig module explicitly, but it is required by the silentpayments module.])\n+  fi\n+  enable_module_schnorrsig=yes\n+\n+  if test x\"$enable_module_extrakeys\" = x\"no\"; then\n+    AC_MSG_ERROR([Module dependency error: You have disabled the extrakeys module explicitly, but it is required by the silentpayments module.])\n+  fi\n+  enable_module_extrakeys=yes",
      "path": "configure.ac",
      "position": 1,
      "original_position": 24,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "ca2538a8782628437488ca32c49f52957aff5f69",
      "in_reply_to_id": 2269287929,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed.",
      "created_at": "2025-08-14T12:54:08Z",
      "updated_at": "2025-08-14T12:54:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276550991",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276550991"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 409,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 413,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2278732752",
      "pull_request_review_id": 3123521055,
      "id": 2278732752,
      "node_id": "PRRC_kwDOAP4Jqs6H0rPQ",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 48,
      "original_position": 33,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Considering we are using optimised tagged hashes in a majority of the modules, this seemed like a good opportunity to DRY up the code and propose a convention for testing tagged hash midstates: https://github.com/bitcoin-core/secp256k1/pull/1725",
      "created_at": "2025-08-15T10:07:28Z",
      "updated_at": "2025-08-15T10:07:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2278732752",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2278732752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2282964041",
      "pull_request_review_id": 3129198442,
      "id": 2282964041,
      "node_id": "PRRC_kwDOAP4Jqs6IE0RJ",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 224,
      "original_position": 203,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269412021,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fwiw, I remember thinking about this idea while reviewing at least once, but always ended up on dropping the suggestion as I found it strange that users would pass in input parameters that can be partly uninitialized (haven't checked, but I assume that none of the existing API functions allow this). Users have to fill in the recipients in a loop anyway, so this should usually need one extra line of code. I agree though that the current solution is not ideal either, so no strong opinion. As a compromise, to not allow uninitialized values, one could require that the `index` field is always zero (maybe renaming it to something like `_internal`, to express that the user doesn't have to care what it is used for), and then set it internally, but not sure if that is better.",
      "created_at": "2025-08-18T17:02:11Z",
      "updated_at": "2025-08-18T17:02:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2282964041",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2282964041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 222,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284517322",
      "pull_request_review_id": 3131271276,
      "id": 2284517322,
      "node_id": "PRRC_kwDOAP4Jqs6IKvfK",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 12,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270416794,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed",
      "created_at": "2025-08-19T08:25:15Z",
      "updated_at": "2025-08-19T08:25:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2284517322",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284517322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284518900",
      "pull_request_review_id": 3131273523,
      "id": 2284518900,
      "node_id": "PRRC_kwDOAP4Jqs6IKv30",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 61,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270403564,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "looks good. I think I'll do an entire review pass over the API docs once I've finished looking at the actual code",
      "created_at": "2025-08-19T08:25:55Z",
      "updated_at": "2025-08-19T08:25:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2284518900",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284518900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284527016",
      "pull_request_review_id": 3131284890,
      "id": 2284527016,
      "node_id": "PRRC_kwDOAP4Jqs6IKx2o",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 224,
      "original_position": 203,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269412021,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Okay, yes. My thinking was that I prefer an API in which the user passes a data structure which doesn't even have an `index` field, but this seems hard in C (or at least, it comes with a bunch of other disadvantages). So yes, let's keep this unless someone has a great idea to get rid of this field without introducing any other overhead. In any case, having the field is safe because we check that the value is set correctly. It's just a minor annoyance for the caller.",
      "created_at": "2025-08-19T08:29:09Z",
      "updated_at": "2025-08-19T08:29:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2284527016",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284527016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 222,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284547348",
      "pull_request_review_id": 3131312139,
      "id": 2284547348,
      "node_id": "PRRC_kwDOAP4Jqs6IK20U",
      "diff_hunk": "@@ -0,0 +1,723 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    ret = secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+    (void)ret;\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 598,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Couldn't we also in this case (like on the sending side) construct inputs to the functions that hit this? (Did we discuss this on the BIP? I vaguely remember having thought about this before.)",
      "created_at": "2025-08-19T08:35:52Z",
      "updated_at": "2025-08-19T08:35:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2284547348",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284547348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 594,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 594,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287467872",
      "pull_request_review_id": 3135479839,
      "id": 2287467872,
      "node_id": "PRRC_kwDOAP4Jqs6IV_1g",
      "diff_hunk": "@@ -0,0 +1,723 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    ret = secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+    (void)ret;\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 598,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "in_reply_to_id": 2284547348,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We did discuss this and decided it was improbable due to `t_k_scalar` being the output of a hash function, where the allowable hash preimage values can only come from the senders spendable UTXOs.\r\n\r\nThat being said, you're right that we can create a test case for this by first picking a `t_k_scalar` value and then choosing a `B_spend` that is the negation of `t_k_scalar`. In practice, I don't think this could ever happen since the sender is not in control of `B_spend`, but you could have a malicious receiver that puts out silent payment addresses with maliciously crafted `B_spends`. Based on that, I think it's worth adding a test case and handling the error in this function.",
      "created_at": "2025-08-20T08:54:41Z",
      "updated_at": "2025-08-20T08:54:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2287467872",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287467872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 594,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 594,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287599563",
      "pull_request_review_id": 3135696764,
      "id": 2287599563,
      "node_id": "PRRC_kwDOAP4Jqs6IWf_L",
      "diff_hunk": "@@ -253,9 +253,47 @@ static void test_send_api(void) {\n     }\n }\n \n+static void test_label_api(void) {\n+    secp256k1_pubkey l, s, ls, e; /* label pk, spend pk, labeled spend pk, expected labeled spend pk */\n+    unsigned char lt[32];         /* label tweak */\n+    const unsigned char expected[33] = {\n+        0x03, 0xdc, 0x7f, 0x09, 0x9a, 0xbe, 0x95, 0x7a,\n+        0x58, 0x43, 0xd2, 0xb6, 0xbb, 0x35, 0x79, 0x61,\n+        0x5c, 0x60, 0x36, 0xa4, 0x9b, 0x86, 0xf4, 0xbe,\n+        0x46, 0x38, 0x60, 0x28, 0xa8, 0x1a, 0x77, 0xd4,\n+        0x91\n+    };\n+\n+    /* Create a label and labeled spend public key, verify we get the expected result */\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &s, BOB_ADDRESS[1], 33));\n+    CHECK(secp256k1_silentpayments_recipient_create_label(CTX, &l, lt, ALICE_SECKEY, 1));\n+    CHECK(secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &e, expected, 33));\n+    CHECK(secp256k1_ec_pubkey_cmp(CTX, &ls, &e) == 0);\n+\n+    /* Check null values are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_label(CTX, NULL, lt, ALICE_SECKEY, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_label(CTX, &l, NULL, ALICE_SECKEY, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_label(CTX, &l, lt, NULL, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, NULL, &s, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, NULL, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, NULL));\n+    /* Check for malformed spend and label public keys, i.e., any single pubkey is malformed or the public\n+     * keys are valid but sum up to zero.\n+     */\n+    {\n+        secp256k1_pubkey neg_spend_pubkey = s;\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\n+        CHECK(secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &neg_spend_pubkey) == 0);\n+        memset(&l, 0, sizeof(l));\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+    }\n+}",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 39,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "090f3839637c2be990e283360aaa639c0018e288",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This could also test with an illegal s, I think.",
      "created_at": "2025-08-20T09:41:22Z",
      "updated_at": "2025-08-20T09:41:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2287599563",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287599563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 314,
      "original_start_line": 281,
      "start_side": "RIGHT",
      "line": 760,
      "original_line": 760,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287600454",
      "pull_request_review_id": 3135698020,
      "id": 2287600454,
      "node_id": "PRRC_kwDOAP4Jqs6IWgNG",
      "diff_hunk": "@@ -0,0 +1,723 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    ret = secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+    (void)ret;\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 598,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "in_reply_to_id": 2284547348,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, we use `VERIFY_CHECK` like an assertion, i.e., there should be no API calls that make the asserted condition false. Now, we make an exception for inputs that are \"cryptographically hard to find\" (i.e., a computationally limited adversary will find them only with negligible probability under hardness assumptions that we accept). This is justified because noone will actually be able to hit the assertion in the real world (unless our assumptions turn out to be wrong).\r\n\r\nBut I think we should not extend our set of assumptions to things like \"the API function is called on inputs created from spendable UTXOs in some existing blockchain\" or similar. Or in other words: if you can come up with a test case against the public API that triggers that VERIFY_CHECK, then it should not be a VERIFY_CHECK.",
      "created_at": "2025-08-20T09:41:40Z",
      "updated_at": "2025-08-20T09:41:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2287600454",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287600454"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 594,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 594,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287615275",
      "pull_request_review_id": 3135721975,
      "id": 2287615275,
      "node_id": "PRRC_kwDOAP4Jqs6IWj0r",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 224,
      "original_position": 203,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269412021,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> API in which the user passes a data structure which doesn't even have an index field, but this seems hard in C (or at least, it comes with a bunch of other disadvantages).\r\n\r\nJust wanted to confirm this is where I landed as well, i.e., its annoying to have the field but trying to work around the field is even more annoying. ",
      "created_at": "2025-08-20T09:46:29Z",
      "updated_at": "2025-08-20T09:46:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2287615275",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287615275"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 222,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287709916",
      "pull_request_review_id": 3135872201,
      "id": 2287709916,
      "node_id": "PRRC_kwDOAP4Jqs6IW67c",
      "diff_hunk": "@@ -0,0 +1,723 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    ret = secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+    (void)ret;\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 598,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "in_reply_to_id": 2284547348,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Or in other words: if you can come up with a test case against the public API that triggers that VERIFY_CHECK, then it should not be a VERIFY_CHECK.\r\n\r\nThanks for the explanation, I've always been a bit hazy on when/how to use VERIFY_CHECK appropriately; this cleared it up for me! Will add a test for this and remove the VERIFY_CHECK in my next push.",
      "created_at": "2025-08-20T10:23:27Z",
      "updated_at": "2025-08-20T10:23:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2287709916",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287709916"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 594,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 594,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2297369597",
      "pull_request_review_id": 3150297518,
      "id": 2297369597,
      "node_id": "PRRC_kwDOAP4Jqs6I7xP9",
      "diff_hunk": "@@ -0,0 +1,617 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 23,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The Valgrind bug has been fixed: https://github.com/LouisBrunner/valgrind-macos#135",
      "created_at": "2025-08-25T07:45:47Z",
      "updated_at": "2025-08-25T07:45:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2297369597",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2297369597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 21,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2297503970",
      "pull_request_review_id": 3150490792,
      "id": 2297503970,
      "node_id": "PRRC_kwDOAP4Jqs6I8SDi",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 189,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I suggest calling this a `_transaction_summary`. This is more descriptive. \n\nPerhaps then `public` can be dropped because it's a bit more implied from the name. And this is also implied because the function that creates it doesn't get secret data. I think I slightly tend to drop `public` then. (My thinking is that, if it was secret data, then `secret` should totally be an explicit part of the name to warn the user, but it's okay to drop `public`.) It should still be mentioned in the docs that this is just public data.\n\n - `secp256k1_silentpayments_recipient_transaction_summary` (my favorite)\n - `secp256k1_silentpayments_recipient_public_transaction_summary`\n - `secp256k1_silentpayments_recipient_public_tx_summary`\n - `secp256k1_silentpayments_recipient_public_tx_summary`\n",
      "created_at": "2025-08-25T08:51:24Z",
      "updated_at": "2025-08-25T10:33:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2297503970",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2297503970"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2297699344",
      "pull_request_review_id": 3150490792,
      "id": 2297699344,
      "node_id": "PRRC_kwDOAP4Jqs6I9BwQ",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 397,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I find this unexpected. What I expect from any data structure that comes with `serialize` and `parse` methods is that serializing and re-parsing it doesn't make a functional difference.\n\nThe need for boolean indicates that there should perhaps be two different data structures. Or, simpler: declare the serialized thing to be something else. This means that one way to get this cleaner is to split the scan function into two, one that takes `recipient_public_data` and one that takes serialized public data. But wait, we already have it like that: `secp256k1_silentpayments_recipient_create_shared_secret` is purely for light clients.\n\nThat suggests dropping `_recpient_public_data_parse` (and perhaps renaming `_recipient_public_data_serialize` to `_recipient_public_data_export`).\n\nThere's a slight loss of functionality: The docs of `_recipient_public_data_create` say: \"If calling this function for simply aggregating the public transaction data for later use, the caller can save the result with `silentpayments_recipient_public_data_serialize`\". Is this really a use case we'd like to offer? It's not great in terms of performance. It will double the amount of necessary EC mults. Note that the caller could simply store the opaque data structure in memory for later use. Only if the caller wants to write it to permanent storage, then serialization will be necessary. \n\nMy thinking is that if this is not an important use case, then we should just drop it. But if we want this use case, then we suggest just that there should be a serialization function that serializes the \"uncombined\" variant for saving EC mults at the cost of increased storage requirements.     \n\n\n---\n\nAlternative way: I can see why you want just one data structure. This is simply about lazy evaluation of the EC mult, and whether it has already happened or not is merely an implementation detail and should not make an observable difference to the API caller (except in terms of performance). But then I suggest implementing it like a real lazy evaluation:\n\n *  `_recipient_public_data_create` always creates a public_data object with combined = false\n *  `_recipient_public_data_serialize` accepts any public_data object. If combined = false, it performs the EC mult  before serializing the resulting public key as a compressed public key. **If combined = true, it simply serializes**\n *  `_recpient_public_data_parse` assumes the input represents a previously serialized public_data object and always deserializes into a public_data object with combined = true (and the input_hash portion zeroed out).\n * **`_recipient_create_shared_secret` can also accept both combined = true and combined = false**. But if we think that calling `_create_shared_secret latter` necessarily implies the caller is doing something wrong, then my first suggestion above is probably better.",
      "created_at": "2025-08-25T10:10:43Z",
      "updated_at": "2025-08-25T10:33:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2297699344",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2297699344"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 380,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 416,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2313736277",
      "pull_request_review_id": 3173333257,
      "id": 2313736277,
      "node_id": "PRRC_kwDOAP4Jqs6J6NBV",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 189,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297503970,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree with dropping \"public.\" My only nit with calling this a transaction summary is that it contains data not found in a transaction, i.e., the prevout scriptPubKeys. The prevouts are _referenced_ in a transaction (by outpoint). I think this is important because calling it transaction summary to me implies that I can create this with only the transaction itself (which is not true).\r\n\r\nWhat about `_recipient_inputs_summary`? , or `_prevouts_summary`? ",
      "created_at": "2025-09-01T11:48:00Z",
      "updated_at": "2025-09-01T11:48:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2313736277",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2313736277"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2313764858",
      "pull_request_review_id": 3173370620,
      "id": 2313764858,
      "node_id": "PRRC_kwDOAP4Jqs6J6T_6",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 397,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297699344,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree that having `_serialize` and `_parse` methods that do not roundtrip is a bit code smelly.\r\n\r\n> If calling this function for simply aggregating the public transaction data for later use ... Only if the caller wants to write it to permanent storage, then serialization will be necessary.\r\n\r\nThe comment in the code is a bit confusing. The only reason a caller would want to \"aggregate for later use\" is when building a silent payments index, for personal use (e.g., fast wallet rescans), or for serving the data to external light clients.\r\n\r\nI much prefer your alternative suggestion, as this seems simpler than having multiple data structures and easier to document. I also think full nodes keeping their own silent payments index for fast wallet rescans and for supporting light clients will be a very common (and important!) use case to support.",
      "created_at": "2025-09-01T12:02:00Z",
      "updated_at": "2025-09-01T12:02:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2313764858",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2313764858"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 380,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 416,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2313783082",
      "pull_request_review_id": 3173397055,
      "id": 2313783082,
      "node_id": "PRRC_kwDOAP4Jqs6J6Ycq",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 189,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297503970,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, good point! I think then `recipient_prevouts_summary` is the right name. Technically speaking, what references a prevout is a transaction *input*, so `_recipient_inputs_summary` is similarly imprecise (though already much better than `transaction_summary`).",
      "created_at": "2025-09-01T12:11:06Z",
      "updated_at": "2025-09-01T12:11:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2313783082",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2313783082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2313786283",
      "pull_request_review_id": 3173401373,
      "id": 2313786283,
      "node_id": "PRRC_kwDOAP4Jqs6J6ZOr",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 397,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297699344,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Makes sense to me. We should then make sure to document the performance implications of the API calls.",
      "created_at": "2025-09-01T12:12:42Z",
      "updated_at": "2025-09-01T12:12:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2313786283",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2313786283"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 380,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 416,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2320423769",
      "pull_request_review_id": 3182825179,
      "id": 2320423769,
      "node_id": "PRRC_kwDOAP4Jqs6KTttZ",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 69,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Just a minor typo, yet it causes a sanity check for pubkey serialization to be skipped without warning.\r\n\r\n```suggestion\r\n#ifdef VERIFY\r\n```",
      "created_at": "2025-09-03T22:58:41Z",
      "updated_at": "2025-09-03T22:58:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2320423769",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2320423769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2320441355",
      "pull_request_review_id": 3182850012,
      "id": 2320441355,
      "node_id": "PRRC_kwDOAP4Jqs6KTyAL",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 438,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What happens if parsing fails and an `addend` other than expected (maybe invalid) is supplied to `secp256k1_gej_add_ge_var`?",
      "created_at": "2025-09-03T23:12:53Z",
      "updated_at": "2025-09-03T23:13:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2320441355",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2320441355"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2320483973",
      "pull_request_review_id": 3182904552,
      "id": 2320483973,
      "node_id": "PRRC_kwDOAP4Jqs6KT8aF",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 350,
      "original_position": 333,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit (in `int secp256k1_silentpayments_recipient_create_label`):\r\n```suggestion\r\nsecp256k1_memclear(m_serialized, sizeof(m_serialized));\r\nsecp256k1_sha256_clear(&hash);\r\n```",
      "created_at": "2025-09-03T23:43:13Z",
      "updated_at": "2025-09-03T23:43:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2320483973",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2320483973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 350,
      "original_line": 350,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2320509569",
      "pull_request_review_id": 3182935500,
      "id": 2320509569,
      "node_id": "PRRC_kwDOAP4Jqs6KUCqB",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 311,
      "original_position": 294,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: ensure there's room for the increment\r\n\r\n```suggestion\r\n        VERIFY_CHECK(k < SIZE_MAX);\r\n        k++;\r\n        \r\n```",
      "created_at": "2025-09-04T00:11:19Z",
      "updated_at": "2025-09-04T00:11:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2320509569",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2320509569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 311,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321481259",
      "pull_request_review_id": 3184358211,
      "id": 2321481259,
      "node_id": "PRRC_kwDOAP4Jqs6KXv4r",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 438,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": 2320441355,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "From what I can tell, nothing. If any single public key fails to parse, we will catch it a few lines down. Arguably, we could return early to avoid doing extra work when a single public key is bad, which seems preferable.",
      "created_at": "2025-09-04T09:52:27Z",
      "updated_at": "2025-09-04T09:52:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321481259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321481259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321731305",
      "pull_request_review_id": 3184710790,
      "id": 2321731305,
      "node_id": "PRRC_kwDOAP4Jqs6KYs7p",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 311,
      "original_position": 294,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": 2320509569,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-09-04T11:25:57Z",
      "updated_at": "2025-09-04T11:25:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321731305",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321731305"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 311,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321731607",
      "pull_request_review_id": 3184711175,
      "id": 2321731607,
      "node_id": "PRRC_kwDOAP4Jqs6KYtAX",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 350,
      "original_position": 333,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": 2320483973,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-09-04T11:26:05Z",
      "updated_at": "2025-09-04T11:26:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321731607",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321731607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 350,
      "original_line": 350,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321735997",
      "pull_request_review_id": 3184716563,
      "id": 2321735997,
      "node_id": "PRRC_kwDOAP4Jqs6KYuE9",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 438,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": 2320441355,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Update to return as soon as a bad pubkey is encountered. This avoids calling `_gej_add_ge_var` with a bad addend and fails early on the first bad key, instead of wasting the callers time with additional work. Also updated the tests to explicitly test both bad plain pubkeys and bad taproot x-only pubkeys.",
      "created_at": "2025-09-04T11:27:25Z",
      "updated_at": "2025-09-04T11:27:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321735997",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321735997"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321736498",
      "pull_request_review_id": 3184717179,
      "id": 2321736498,
      "node_id": "PRRC_kwDOAP4Jqs6KYuMy",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 69,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": 2320423769,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Great catch!",
      "created_at": "2025-09-04T11:27:36Z",
      "updated_at": "2025-09-04T11:27:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321736498",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321736498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321744450",
      "pull_request_review_id": 3184727012,
      "id": 2321744450,
      "node_id": "PRRC_kwDOAP4Jqs6KYwJC",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 397,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297699344,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I updated this per your suggestion to make this a proper lazy evaluation. Also documented that calling `_serialize` can incur an EC mult in some cases. I don't think there are any other performance implications that need documenting, since calling `_recipient_create_shared_secret` will always involve one EC mult, and sometimes a scalar mult, depending on the value of combined. But a scalar mult seems negligible enough that it shouldn't warrant documenting.",
      "created_at": "2025-09-04T11:30:17Z",
      "updated_at": "2025-09-04T11:30:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321744450",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321744450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 380,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 416,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321745910",
      "pull_request_review_id": 3184729008,
      "id": 2321745910,
      "node_id": "PRRC_kwDOAP4Jqs6KYwf2",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 189,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297503970,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Renamed to `prevout_summary`.",
      "created_at": "2025-09-04T11:30:46Z",
      "updated_at": "2025-09-04T11:30:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321745910",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321745910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321749282",
      "pull_request_review_id": 3184733301,
      "id": 2321749282,
      "node_id": "PRRC_kwDOAP4Jqs6KYxUi",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 189,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297503970,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Just realised `prevouts_summary` is probably more correct 😅 Not sure why I didn't make it plural. Can update in a later push to `prevouts_summary` if we feel that would be better.",
      "created_at": "2025-09-04T11:31:58Z",
      "updated_at": "2025-09-04T11:31:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321749282",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321749282"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321750631",
      "pull_request_review_id": 3184734983,
      "id": 2321750631,
      "node_id": "PRRC_kwDOAP4Jqs6KYxpn",
      "diff_hunk": "@@ -0,0 +1,617 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 23,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297369597,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Amazing! Thanks for digging into that.",
      "created_at": "2025-09-04T11:32:25Z",
      "updated_at": "2025-09-04T11:32:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321750631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321750631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 21,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321752012",
      "pull_request_review_id": 3184736870,
      "id": 2321752012,
      "node_id": "PRRC_kwDOAP4Jqs6KYx_M",
      "diff_hunk": "@@ -253,9 +253,47 @@ static void test_send_api(void) {\n     }\n }\n \n+static void test_label_api(void) {\n+    secp256k1_pubkey l, s, ls, e; /* label pk, spend pk, labeled spend pk, expected labeled spend pk */\n+    unsigned char lt[32];         /* label tweak */\n+    const unsigned char expected[33] = {\n+        0x03, 0xdc, 0x7f, 0x09, 0x9a, 0xbe, 0x95, 0x7a,\n+        0x58, 0x43, 0xd2, 0xb6, 0xbb, 0x35, 0x79, 0x61,\n+        0x5c, 0x60, 0x36, 0xa4, 0x9b, 0x86, 0xf4, 0xbe,\n+        0x46, 0x38, 0x60, 0x28, 0xa8, 0x1a, 0x77, 0xd4,\n+        0x91\n+    };\n+\n+    /* Create a label and labeled spend public key, verify we get the expected result */\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &s, BOB_ADDRESS[1], 33));\n+    CHECK(secp256k1_silentpayments_recipient_create_label(CTX, &l, lt, ALICE_SECKEY, 1));\n+    CHECK(secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &e, expected, 33));\n+    CHECK(secp256k1_ec_pubkey_cmp(CTX, &ls, &e) == 0);\n+\n+    /* Check null values are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_label(CTX, NULL, lt, ALICE_SECKEY, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_label(CTX, &l, NULL, ALICE_SECKEY, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_label(CTX, &l, lt, NULL, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, NULL, &s, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, NULL, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, NULL));\n+    /* Check for malformed spend and label public keys, i.e., any single pubkey is malformed or the public\n+     * keys are valid but sum up to zero.\n+     */\n+    {\n+        secp256k1_pubkey neg_spend_pubkey = s;\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\n+        CHECK(secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &neg_spend_pubkey) == 0);\n+        memset(&l, 0, sizeof(l));\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+    }\n+}",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 39,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "090f3839637c2be990e283360aaa639c0018e288",
      "in_reply_to_id": 2287599563,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated the tests to cover both the negation case and malformed public keys cases.",
      "created_at": "2025-09-04T11:32:54Z",
      "updated_at": "2025-09-04T11:32:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2321752012",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2321752012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 314,
      "original_start_line": 281,
      "start_side": "RIGHT",
      "line": 760,
      "original_line": 760,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322478494",
      "pull_request_review_id": 3185761940,
      "id": 2322478494,
      "node_id": "PRRC_kwDOAP4Jqs6KbjWe",
      "diff_hunk": "@@ -119,6 +119,58 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(recipient_scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = recipient_spend_pubkey + label * G",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 33,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "163dc82627e864b202b1e919ee39d69df89f12f8",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in 163dc82627e864b202b1e919ee39d69df89f12f8:\r\n```suggestion\r\n *      labeled_spend_pubkey = recipient_spend_pubkey + label\r\n```\r\n(as `label` is already a pubkey, not a scalar)",
      "created_at": "2025-09-04T14:58:28Z",
      "updated_at": "2025-09-04T15:35:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2322478494",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322478494"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322483015",
      "pull_request_review_id": 3185761940,
      "id": 2322483015,
      "node_id": "PRRC_kwDOAP4Jqs6KbkdH",
      "diff_hunk": "@@ -294,4 +294,74 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = recipient_spend_pubkey + label * G",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "163dc82627e864b202b1e919ee39d69df89f12f8",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    /* Calculate labeled_spend_pubkey = recipient_spend_pubkey + label\r\n```",
      "created_at": "2025-09-04T15:00:17Z",
      "updated_at": "2025-09-04T15:35:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2322483015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322483015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322491048",
      "pull_request_review_id": 3185761940,
      "id": 2322491048,
      "node_id": "PRRC_kwDOAP4Jqs6Kbmao",
      "diff_hunk": "@@ -7,10 +7,291 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 94,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "a7017e766a130e1c606eb5c36ae3d3b7d49530e8",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n   /* Leaking these values would break indistinguishability of the transaction, so clear them. */\r\n```\r\n(here and in 5 other instances, in both the sending and receiving commits)",
      "created_at": "2025-09-04T15:03:31Z",
      "updated_at": "2025-09-04T15:35:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2322491048",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322491048"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322529325",
      "pull_request_review_id": 3185761940,
      "id": 2322529325,
      "node_id": "PRRC_kwDOAP4Jqs6Kbvwt",
      "diff_hunk": "@@ -171,6 +173,265 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevout_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevout_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevout_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_prevout_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_prevout_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevout_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevout_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:      prevout_summary: pointer to prevout_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevout_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevout_summary *prevout_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_prevout_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevout_summary object created with `_recipent_prevout_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_recipient_prevout_summary` in\n+ *  In:  prevout_summary: pointer to an initialized silentpayments_recipient_prevout_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevout_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_prevout_summary *prevout_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevout_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_prevout_summary object. If 1 is",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 113,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "cb53ab5d05049527ff3d6be30144c188263b1192",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  Out:  prevout_summary: pointer to a silentpayments_recipient_prevout_summary object. If 1 is\r\n```",
      "created_at": "2025-09-04T15:18:19Z",
      "updated_at": "2025-09-04T15:35:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2322529325",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322529325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322534704",
      "pull_request_review_id": 3185761940,
      "id": 2322534704,
      "node_id": "PRRC_kwDOAP4Jqs6KbxEw",
      "diff_hunk": "@@ -171,6 +173,265 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevout_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevout_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevout_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_prevout_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_prevout_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevout_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevout_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:      prevout_summary: pointer to prevout_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevout_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevout_summary *prevout_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_prevout_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevout_summary object created with `_recipent_prevout_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_recipient_prevout_summary` in\n+ *  In:  prevout_summary: pointer to an initialized silentpayments_recipient_prevout_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevout_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_prevout_summary *prevout_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevout_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_prevout_summary object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_prevout_summary.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevout_summary_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevout_summary *prevout_summary,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a prevout_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if any combination of the shared secret, label and spend pubkey\n+ *             sum to zero (statistically improbable).\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *              prevout_summary: pointer to the transaction public data\n+ *                               (see `_recipient_prevout_summary_create`).\n+ *       unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used or context is not needed)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_prevout_summary *prevout_summary,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n+    SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n+\n+/** Create Silent Payment shared secret.\n+ *\n+ *  Given the public input data (secp256k1_silentpayments_recipient_prevout_summary),\n+ *  and the recipient's 32 byte scan key, calculate the shared secret.\n+ *\n+ *  The resulting shared secret is needed as input for creating silent payments\n+ *  outputs belonging to the same recipient scan public key. This function is\n+ *  intended for light clients, i.e., scenarios where the caller does not have\n+ *  access to the full transaction. If the caller does have access to the full\n+ *  transaction, `secp256k1_silentpayments_recipient_scan_outputs` should be\n+ *  used instead.\n+ *\n+ *  Returns: 1 if shared secret creation was successful.\n+ *           0 if the recipient scan key is invalid.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:       shared_secret33: pointer to the resulting 33-byte shared secret\n+ *  In:   recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                 public_data: pointer to the public_data object, loaded using\n+ *                              `_recipient_public_data_parse`",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 237,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "cb53ab5d05049527ff3d6be30144c188263b1192",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *             prevout_summary: pointer to the public_data object, loaded using\r\n *                              `_recipient_prevout_summary_parse`\r\n```",
      "created_at": "2025-09-04T15:20:16Z",
      "updated_at": "2025-09-04T15:35:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2322534704",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322534704"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 392,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322541261",
      "pull_request_review_id": 3185761940,
      "id": 2322541261,
      "node_id": "PRRC_kwDOAP4Jqs6KbyrN",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevout_summary object and its usage:\n+ *\n+ *  The prevout_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevout_summary object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_prevout_summary_create` always creates a prevout_summary object with combined = false\n+ *  - `_recipient_prevout_summary_serialize` only accepts a prevout_summary object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_prevout_summary_parse` assumes the input represents a previously serialized",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 29,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "cb53ab5d05049527ff3d6be30144c188263b1192",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  - `_recipient_prevout_summary_parse` assumes the input represents a previously serialized\r\n```",
      "created_at": "2025-09-04T15:22:25Z",
      "updated_at": "2025-09-04T15:35:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2322541261",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2322541261"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 392,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2324464726",
      "pull_request_review_id": 3188485074,
      "id": 2324464726,
      "node_id": "PRRC_kwDOAP4Jqs6KjIRW",
      "diff_hunk": "@@ -0,0 +1,713 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistiguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+/** Calculate and return output_xonly = B_spend + t_k * G.\n+ *\n+ * This will fail (return 0) if B_spend or B_spend + t_k*G is the point at infinity.\n+ */\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k*G = -B_spend. But since t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created B_spend, but we handle this\n+     * error anyway to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    sum_is_zero = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this happens only\n+     * with negligible probability, so we only do a VERIFY_CHECK here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                /* Leaking this value would break indistiguishability of the transaction, so clear it. */\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 438,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "bd745e1a06e85d121faacd020709303f62a55766",
      "in_reply_to_id": 2320441355,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> From what I can tell, nothing.\r\n\r\nIndeed. `secp256k1_gej_add_ge_var` will compute garbage (garbage in, garbage out), but there won't be any crashes or UB. But when looking deeper, there's an interesting question; see #1736.",
      "created_at": "2025-09-05T08:34:10Z",
      "updated_at": "2025-09-05T08:34:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2324464726",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2324464726"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2324552111",
      "pull_request_review_id": 3188600436,
      "id": 2324552111,
      "node_id": "PRRC_kwDOAP4Jqs6Kjdmv",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 189,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "2164d5cfe15ad92641d3ddbf9f664af088a33578",
      "in_reply_to_id": 2297503970,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed in the latest push; now using `prevouts_summary` everywhere.",
      "created_at": "2025-09-05T09:13:23Z",
      "updated_at": "2025-09-05T09:13:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2324552111",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2324552111"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325428198",
      "pull_request_review_id": 3189856649,
      "id": 2325428198,
      "node_id": "PRRC_kwDOAP4Jqs6Kmzfm",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` only accepts a prevouts_summary object with combined = false",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 26,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "22b20fd6177ec8a2b71b0849b933a7b0987cf3fa",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "with the recent change to use lazy evaluation (see https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2297699344 ff.), this comment needs to be updated (the ones for `_create` and `_parse` are still correct, I think)",
      "created_at": "2025-09-05T15:38:18Z",
      "updated_at": "2025-09-05T16:03:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2325428198",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325428198"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 389,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325436634",
      "pull_request_review_id": 3189856649,
      "id": 2325436634,
      "node_id": "PRRC_kwDOAP4Jqs6Km1ja",
      "diff_hunk": "@@ -294,4 +294,74 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 41,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "df1de937650519112a665c82d3e355a21fce696d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nint secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\r\n```\r\nto match the parameter name in the API header",
      "created_at": "2025-09-05T15:41:50Z",
      "updated_at": "2025-09-05T16:03:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2325436634",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325436634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325448482",
      "pull_request_review_id": 3189856649,
      "id": 2325448482,
      "node_id": "PRRC_kwDOAP4Jqs6Km4ci",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` only accepts a prevouts_summary object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge input_pubkey_sum_ge, addend;\n+    secp256k1_gej input_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: input_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&input_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&input_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&input_pubkey_sum_ge, &input_pubkey_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &input_pubkey_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &input_pubkey_sum_ge);\n+    memcpy(&prevouts_summary->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, input_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&input_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &input_pubkey_sum_ge, &rsk_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = recipient_spend_pubkey_ge;\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate output = recipient_spend_pubkey + t_k * G.\n+         * This can fail if t_k is the negation of recipient_spend_pubkey, but this happens only\n+         * with negligible probability as t_k is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+            secp256k1_scalar_clear(&rsk_scalar);\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 *     label2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[n_found]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[n_found]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 */\n+                ret = secp256k1_ec_seckey_tweak_add(ctx, found_outputs[n_found]->tweak, label_tweak);\n+                VERIFY_CHECK(ret);\n+                secp256k1_pubkey_save(&found_outputs[n_found]->label, &label_ge);\n+            } else {\n+                found_outputs[n_found]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value. */\n+                memset(&found_outputs[n_found]->label, 0, sizeof(secp256k1_pubkey));\n+            }\n+            /* Reset everything for the next round of scanning. */\n+            label_tweak = NULL;\n+            n_found++;\n+            k++;\n+        } else {\n+            break;\n+        }\n+    }\n+    *n_found_outputs = n_found;\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_scalar_clear(&rsk_scalar);\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    secp256k1_memclear(shared_secret, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const unsigned char *recipient_scan_key32, const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary) {\n+    secp256k1_scalar rsk;\n+    secp256k1_ge input_pubkey_ge;\n+    int ret, combined;\n+    /* Sanity check inputs */\n+    ARG_CHECK(shared_secret33 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk, recipient_scan_key32);\n+    /* If there are any issues with the recipient scan key, return early. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&input_pubkey_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk, &rsk, &input_hash_scalar);\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret33, &input_pubkey_ge, &rsk);\n+\n+    secp256k1_scalar_clear(&rsk);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, const uint32_t k)",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 347,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "22b20fd6177ec8a2b71b0849b933a7b0987cf3fa",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nint secp256k1_silentpayments_recipient_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, const uint32_t k)\r\n```\r\nto match the parameter name in the API header",
      "created_at": "2025-09-05T15:47:34Z",
      "updated_at": "2025-09-05T16:03:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2325448482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325448482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325460044",
      "pull_request_review_id": 3189856649,
      "id": 2325460044,
      "node_id": "PRRC_kwDOAP4Jqs6Km7RM",
      "diff_hunk": "@@ -119,6 +119,58 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(recipient_scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = recipient_spend_pubkey + label",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 33,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "df1de937650519112a665c82d3e355a21fce696d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\r\n```\r\nsorry to dig into the same line once again, missed this in the last review round :sweat_smile: \r\nmight be worth it to grep for `recipient_spend` occurences in general, if the plan is to get rid of that terminology completely (and only use `{labeled_,unlabeled_,}spend_pubkey`)",
      "created_at": "2025-09-05T15:52:35Z",
      "updated_at": "2025-09-05T16:03:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2325460044",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325460044"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325675833",
      "pull_request_review_id": 3190266602,
      "id": 2325675833,
      "node_id": "PRRC_kwDOAP4Jqs6Knv85",
      "diff_hunk": "@@ -25,6 +26,99 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object",
      "path": "include/secp256k1_silentpayments.h",
      "position": 79,
      "original_position": 55,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "76a0451c76c8497571cb75f2cb4bdba50c734600",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion \r\n *  Args:                ctx: pointer to a context object (not secp256k1_context_static)\r\n ```\r\nas the sending function needs the generator point multiplication context (for calculating the pubkey sum from the seckey sum), and this is how we usually denote that in the API header (see also #1737)",
      "created_at": "2025-09-05T17:32:24Z",
      "updated_at": "2025-09-07T22:34:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2325675833",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2325675833"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 79,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2329724145",
      "pull_request_review_id": 3195780280,
      "id": 2329724145,
      "node_id": "PRRC_kwDOAP4Jqs6K3MTx",
      "diff_hunk": "@@ -119,6 +119,58 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(recipient_scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = recipient_spend_pubkey + label",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 33,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "df1de937650519112a665c82d3e355a21fce696d",
      "in_reply_to_id": 2325460044,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No worries! I went ahead and updated all instances to use `{labeled_,unlabeled_,}spend_pubkey` and also update the scan_key32 argument to remove the `recipient_` prefix. Much cleaner, imo.",
      "created_at": "2025-09-08T09:47:13Z",
      "updated_at": "2025-09-08T09:47:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2329724145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2329724145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2329727521",
      "pull_request_review_id": 3195784733,
      "id": 2329727521,
      "node_id": "PRRC_kwDOAP4Jqs6K3NIh",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` only accepts a prevouts_summary object with combined = false",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 26,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "22b20fd6177ec8a2b71b0849b933a7b0987cf3fa",
      "in_reply_to_id": 2325428198,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated, and also updated the `ctime_tests`, where we were doing a serialization roundtrip to get the prevouts summary object into a `combined = true` state.",
      "created_at": "2025-09-08T09:48:29Z",
      "updated_at": "2025-09-08T09:48:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2329727521",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2329727521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 389,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330765130",
      "pull_request_review_id": 3197279129,
      "id": 2330765130,
      "node_id": "PRRC_kwDOAP4Jqs6K7KdK",
      "diff_hunk": "@@ -7,10 +7,291 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar*G = -spend_pubkey. Considering t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge input_pubkey_sum_ge;\n+    secp256k1_gej input_pubkey_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 222,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b802ecfd6cdf855938ada68a7322321aca5f7d41",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "seems that this declassify call is a duplicate from the one a few lines above and can be removed\r\n```suggestion\r\n```\r\n(ctime tests still pass for me locally)",
      "created_at": "2025-09-08T16:29:50Z",
      "updated_at": "2025-09-08T17:27:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330765130",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330765130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330776489",
      "pull_request_review_id": 3197279129,
      "id": 2330776489,
      "node_id": "PRRC_kwDOAP4Jqs6K7NOp",
      "diff_hunk": "@@ -120,6 +120,58 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object",
      "path": "include/secp256k1_silentpayments.h",
      "position": 140,
      "original_position": 14,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "afe3aa01cbf9edcf2fd5795eac562c70f51320b8",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in the `_create_label` API header:\r\n```suggestion\r\n *  Args:                ctx: pointer to a context object (not secp256k1_context_static)\r\n```\r\ncompared to the sending function it's a bit less obvious that a static context can't be used, as we don't check that `ecmult_gen_ctx` is built manually, but call another API function `ec_pubkey_create` which requires this",
      "created_at": "2025-09-08T16:34:13Z",
      "updated_at": "2025-09-08T17:27:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330776489",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330776489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 140,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330785557",
      "pull_request_review_id": 3197279129,
      "id": 2330785557,
      "node_id": "PRRC_kwDOAP4Jqs6K7PcV",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge input_pubkey_sum_ge, addend;\n+    secp256k1_gej input_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: input_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&input_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&input_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&input_pubkey_sum_ge, &input_pubkey_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &input_pubkey_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &input_pubkey_sum_ge);\n+    memcpy(&prevouts_summary->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, input_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&input_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &input_pubkey_sum_ge, &rsk_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate output = spend_pubkey + t_k * G.\n+         * This can fail if t_k is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as t_k is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+            secp256k1_scalar_clear(&rsk_scalar);\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 *     label2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[n_found]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[n_found]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 */\n+                ret = secp256k1_ec_seckey_tweak_add(ctx, found_outputs[n_found]->tweak, label_tweak);\n+                VERIFY_CHECK(ret);\n+                secp256k1_pubkey_save(&found_outputs[n_found]->label, &label_ge);\n+            } else {\n+                found_outputs[n_found]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value. */\n+                memset(&found_outputs[n_found]->label, 0, sizeof(secp256k1_pubkey));\n+            }\n+            /* Reset everything for the next round of scanning. */\n+            label_tweak = NULL;\n+            n_found++;\n+            k++;\n+        } else {\n+            break;\n+        }\n+    }\n+    *n_found_outputs = n_found;\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_scalar_clear(&rsk_scalar);\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    secp256k1_memclear(shared_secret, sizeof(shared_secret));\n+    return ret;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 316,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in `_recipient_scan_outputs`:\r\n```suggestion\r\n    return 1;\r\n```\r\nas the \"single point of return\" approach isn't followed anymore and any failures return early",
      "created_at": "2025-09-08T16:38:56Z",
      "updated_at": "2025-09-08T17:27:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330785557",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330785557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 679,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330788051",
      "pull_request_review_id": 3197279129,
      "id": 2330788051,
      "node_id": "PRRC_kwDOAP4Jqs6K7QDT",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge input_pubkey_sum_ge, addend;\n+    secp256k1_gej input_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: input_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&input_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&input_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&input_pubkey_sum_ge, &input_pubkey_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &input_pubkey_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &input_pubkey_sum_ge);\n+    memcpy(&prevouts_summary->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, input_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&input_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 211,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\r\n```\r\n(as the previous failure would return early)",
      "created_at": "2025-09-08T16:40:05Z",
      "updated_at": "2025-09-08T17:28:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330788051",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330788051"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 574,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330790125",
      "pull_request_review_id": 3197279129,
      "id": 2330790125,
      "node_id": "PRRC_kwDOAP4Jqs6K7Qjt",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge input_pubkey_sum_ge, addend;\n+    secp256k1_gej input_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: input_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&input_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&input_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&input_pubkey_sum_ge, &input_pubkey_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &input_pubkey_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &input_pubkey_sum_ge);\n+    memcpy(&prevouts_summary->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, input_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&input_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &input_pubkey_sum_ge, &rsk_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate output = spend_pubkey + t_k * G.\n+         * This can fail if t_k is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as t_k is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+            secp256k1_scalar_clear(&rsk_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 230,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should securely erase the `shared_secret` and `t_k_scalar` here",
      "created_at": "2025-09-08T16:41:06Z",
      "updated_at": "2025-09-08T17:27:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330790125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330790125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 591,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 620,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330794123",
      "pull_request_review_id": 3197279129,
      "id": 2330794123,
      "node_id": "PRRC_kwDOAP4Jqs6K7RiL",
      "diff_hunk": "@@ -294,4 +294,74 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 60,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "afe3aa01cbf9edcf2fd5795eac562c70f51320b8",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit, `ret` is always zero here:\r\n```suggestion\r\n        return 0;\r\n```",
      "created_at": "2025-09-08T16:43:00Z",
      "updated_at": "2025-09-08T17:27:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330794123",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330794123"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330804325",
      "pull_request_review_id": 3197279129,
      "id": 2330804325,
      "node_id": "PRRC_kwDOAP4Jqs6K7UBl",
      "diff_hunk": "@@ -172,6 +174,265 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_prevouts_summary {",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "naming nit: I wonder if we could drop the `recipient` part of the structure (especially considering that the prevout information actually represents key/input material from the sender side, so it could be even potentially confusing?)\r\n```suggestion\r\ntypedef struct secp256k1_silentpayments_prevouts_summary {\r\n```",
      "created_at": "2025-09-08T16:47:47Z",
      "updated_at": "2025-09-08T17:27:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330804325",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330804325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330825167",
      "pull_request_review_id": 3197279129,
      "id": 2330825167,
      "node_id": "PRRC_kwDOAP4Jqs6K7ZHP",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge input_pubkey_sum_ge, addend;\n+    secp256k1_gej input_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: input_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&input_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&input_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&input_pubkey_sum_ge, &input_pubkey_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &input_pubkey_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &input_pubkey_sum_ge);\n+    memcpy(&prevouts_summary->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, input_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&input_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &input_pubkey_sum_ge, &rsk_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate output = spend_pubkey + t_k * G.\n+         * This can fail if t_k is the negation of spend_pubkey, but this happens only",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 226,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n         * This can fail if t_k * G is the negation of spend_pubkey, but this happens only\r\n```\r\n(or alternatively, s/spend_pubkey/spend_seckey/, though that would more abstractly refer to a scalar that is not in the scope of this function)",
      "created_at": "2025-09-08T16:57:56Z",
      "updated_at": "2025-09-08T17:27:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330825167",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330825167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 589,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330843301",
      "pull_request_review_id": 3197279129,
      "id": 2330843301,
      "node_id": "PRRC_kwDOAP4Jqs6K7dil",
      "diff_hunk": "@@ -7,10 +7,291 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar*G = -spend_pubkey. Considering t_k is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge input_pubkey_sum_ge;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 170,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b802ecfd6cdf855938ada68a7322321aca5f7d41",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "consistent naming nit: the `prevouts_summary` struct description above uses `prevout_pubkey_sum`",
      "created_at": "2025-09-08T17:06:45Z",
      "updated_at": "2025-09-08T17:27:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330843301",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330843301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330860594",
      "pull_request_review_id": 3197279129,
      "id": 2330860594,
      "node_id": "PRRC_kwDOAP4Jqs6K7hwy",
      "diff_hunk": "@@ -7,10 +7,291 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 56,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b802ecfd6cdf855938ada68a7322321aca5f7d41",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "potential follow-up deduplication idea: could include the hash -> scalar conversion in this function (including the `VERIFY_CHECK` and comments), so the two call-sites in sending/receiving don't have to do it",
      "created_at": "2025-09-08T17:14:07Z",
      "updated_at": "2025-09-08T17:28:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2330860594",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2330860594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332195607",
      "pull_request_review_id": 3199629969,
      "id": 2332195607,
      "node_id": "PRRC_kwDOAP4Jqs6LAnsX",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge input_pubkey_sum_ge, addend;\n+    secp256k1_gej input_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: input_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&input_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&input_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&input_pubkey_sum_ge, &input_pubkey_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &input_pubkey_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &input_pubkey_sum_ge);\n+    memcpy(&prevouts_summary->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, input_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&input_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &input_pubkey_sum_ge, &rsk_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate output = spend_pubkey + t_k * G.\n+         * This can fail if t_k is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as t_k is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+            secp256k1_scalar_clear(&rsk_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 230,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": 2330790125,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "And maybe we can find a better name for `t_k_scalar`. Not sure if it appears in the BIP but it's \"BIP-style\"",
      "created_at": "2025-09-09T06:44:31Z",
      "updated_at": "2025-09-09T06:44:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332195607",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332195607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 591,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 620,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332202580",
      "pull_request_review_id": 3199643682,
      "id": 2332202580,
      "node_id": "PRRC_kwDOAP4Jqs6LApZU",
      "diff_hunk": "@@ -172,6 +174,265 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_prevouts_summary {",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": 2330804325,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I guess either is fine. It's a data structure only used on the recipient side, so having `recipient` is consistent. On the other hand, it suffices that only function names have the `sender` and `recipient` infixes. If you believe it could be confusing in this case, then it may be better to drop it.",
      "created_at": "2025-09-09T06:47:41Z",
      "updated_at": "2025-09-09T06:47:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332202580",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332202580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332288582",
      "pull_request_review_id": 3199782557,
      "id": 2332288582,
      "node_id": "PRRC_kwDOAP4Jqs6LA-ZG",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 84,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n *  only and not optimized. In a production use case, it is expected that the\n```\n\nOr just \"in production\"",
      "created_at": "2025-09-09T07:25:09Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332288582",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332288582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332307985",
      "pull_request_review_id": 3199782557,
      "id": 2332307985,
      "node_id": "PRRC_kwDOAP4Jqs6LBDIR",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 119,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I see why you use an enum here, but this is advanced C stuff that we could try to avoid in the examples. This is conceptually not an enumeration, so I'd prefer `#define`.\n",
      "created_at": "2025-09-09T07:32:21Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332307985",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332307985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332313466",
      "pull_request_review_id": 3199782557,
      "id": 2332313466,
      "node_id": "PRRC_kwDOAP4Jqs6LBEd6",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 213,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Why print `\\n` before the message? In the other error outputs, the `\\n` comes after the message.",
      "created_at": "2025-09-09T07:34:34Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332313466",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332313466"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 212,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332322256",
      "pull_request_review_id": 3199782557,
      "id": 2332322256,
      "node_id": "PRRC_kwDOAP4Jqs6LBGnQ",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];",
      "path": "examples/silentpayments.c",
      "position": 151,
      "original_position": 147,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could add a comment here to explain the structure of this array, e.g., that the [2] is for scan/spend.  ",
      "created_at": "2025-09-09T07:37:47Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332322256",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332322256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332326457",
      "pull_request_review_id": 3199782557,
      "id": 2332326457,
      "node_id": "PRRC_kwDOAP4Jqs6LBHo5",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 141,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n    /*** Sending (Alice) ***/\n```",
      "created_at": "2025-09-09T07:39:26Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332326457",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332326457"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332334095",
      "pull_request_review_id": 3199782557,
      "id": 2332334095,
      "node_id": "PRRC_kwDOAP4Jqs6LBJgP",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 279,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: We shouldn't omit the `secp256k1` prefix in user-facing docs.",
      "created_at": "2025-09-09T07:42:28Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332334095",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332334095"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332334757",
      "pull_request_review_id": 3199782557,
      "id": 2332334757,
      "node_id": "PRRC_kwDOAP4Jqs6LBJql",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 302,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n                 *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n```",
      "created_at": "2025-09-09T07:42:46Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332334757",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332334757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332336732",
      "pull_request_review_id": 3199782557,
      "id": 2332336732,
      "node_id": "PRRC_kwDOAP4Jqs6LBKJc",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 304,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n                 *  In this example, since Bob has access to the full transaction\n```\n\nIn this \"case\" could refer to the previous paragraph (no labels used at all)",
      "created_at": "2025-09-09T07:43:25Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332336732",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332336732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 304,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332339887",
      "pull_request_review_id": 3199782557,
      "id": 2332339887,
      "node_id": "PRRC_kwDOAP4Jqs6LBK6v",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 237,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n        printf(\"Alice created the following outputs for Bob and Carol:\\n\");\n```",
      "created_at": "2025-09-09T07:44:28Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332339887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332339887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 237,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332341874",
      "pull_request_review_id": 3199782557,
      "id": 2332341874,
      "node_id": "PRRC_kwDOAP4Jqs6LBLZy",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 311,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n                 *  used, he can pregenerate a large number of labels, e.g.,\n```",
      "created_at": "2025-09-09T07:45:09Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332341874",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332341874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332348031",
      "pull_request_review_id": 3199782557,
      "id": 2332348031,
      "node_id": "PRRC_kwDOAP4Jqs6LBM5_",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the prevouts data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_prevouts_summary` object. He uses\n+             * this for his own scanning and also serializes the `prevouts_summary`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `prevouts_summary` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\n+                &prevouts_summary,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the prevouts data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that prevouts_summary_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the prevouts data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_serialize(ctx,\n+                light_client_data33,\n+                &prevouts_summary\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &prevouts_summary,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the prevouts data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );\n+                    assert(ret);\n+                    print_hex(serialized_xonly, sizeof(serialized_xonly));\n+\n+                    /* Verify that this output is spendable by Bob by reconstructing the full\n+                     * secret key for the xonly output.\n+                     *\n+                     * This is done by adding the tweak from the transaction to Bob's spend key.\n+                     * If the output was sent to a labeled address, the label tweak has\n+                     * already been added to the tweak returned in `_silentpayments_found_output`.",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 445,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "prefix",
      "created_at": "2025-09-09T07:47:28Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332348031",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332348031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 445,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332348570",
      "pull_request_review_id": 3199782557,
      "id": 2332348570,
      "node_id": "PRRC_kwDOAP4Jqs6LBNCa",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the prevouts data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_prevouts_summary` object. He uses\n+             * this for his own scanning and also serializes the `prevouts_summary`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `prevouts_summary` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\n+                &prevouts_summary,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the prevouts data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that prevouts_summary_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the prevouts data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_serialize(ctx,\n+                light_client_data33,\n+                &prevouts_summary\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &prevouts_summary,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the prevouts data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );\n+                    assert(ret);\n+                    print_hex(serialized_xonly, sizeof(serialized_xonly));\n+\n+                    /* Verify that this output is spendable by Bob by reconstructing the full\n+                     * secret key for the xonly output.\n+                     *\n+                     * This is done by adding the tweak from the transaction to Bob's spend key.\n+                     * If the output was sent to a labeled address, the label tweak has\n+                     * already been added to the tweak returned in `_silentpayments_found_output`.\n+                     *\n+                     * To verify that we are able to sign for this output, it is sufficient to\n+                     * check that the public key generated from `full_seckey` matches the output\n+                     * in the transaction. For a full example on signing for a schnorr ouput,",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 449,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\n                     * in the transaction. For a full example on signing for a Schnorr signature ouput,\n```\n\nor do you want to call this \"taproot\" to match the terms above?",
      "created_at": "2025-09-09T07:47:42Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332348570",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332348570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332353256",
      "pull_request_review_id": 3199782557,
      "id": 2332353256,
      "node_id": "PRRC_kwDOAP4Jqs6LBOLo",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the prevouts data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_prevouts_summary` object. He uses\n+             * this for his own scanning and also serializes the `prevouts_summary`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `prevouts_summary` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\n+                &prevouts_summary,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the prevouts data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that prevouts_summary_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the prevouts data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_serialize(ctx,\n+                light_client_data33,\n+                &prevouts_summary\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &prevouts_summary,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the prevouts data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );\n+                    assert(ret);\n+                    print_hex(serialized_xonly, sizeof(serialized_xonly));\n+\n+                    /* Verify that this output is spendable by Bob by reconstructing the full\n+                     * secret key for the xonly output.\n+                     *\n+                     * This is done by adding the tweak from the transaction to Bob's spend key.\n+                     * If the output was sent to a labeled address, the label tweak has\n+                     * already been added to the tweak returned in `_silentpayments_found_output`.\n+                     *\n+                     * To verify that we are able to sign for this output, it is sufficient to\n+                     * check that the public key generated from `full_seckey` matches the output\n+                     * in the transaction. For a full example on signing for a schnorr ouput,\n+                     * see `examples/schnorr.c` */\n+                    memcpy(&full_seckey, &bob_spend_key, 32);\n+                    ret = secp256k1_ec_seckey_tweak_add(ctx, full_seckey, found_outputs[i].tweak);\n+                    ret &= secp256k1_keypair_create(ctx, &kp, full_seckey);\n+                    ret &= secp256k1_keypair_xonly_pub(\n+                        ctx,\n+                        &xonly_output,\n+                        NULL,\n+                        &kp\n+                    );\n+                    /* We assert here because the only way the seckey_tweak_add operation can fail\n+                     * is if the tweak is the negation of Bob's spend key.\n+                     *\n+                     * We also assert that the generated public key matches the transaction output,\n+                     * as it should be impossible for a mismatch at this point considering the\n+                     * scanning function completed without errors and indicated found outputs. */\n+                    assert(ret);\n+                    assert(secp256k1_xonly_pubkey_cmp(ctx, &xonly_output, &found_outputs[i].output) == 0);\n+                }\n+            } else {\n+                printf(\"\\n\");\n+                printf(\"Bob did not find any outputs in this transaction.\");\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists. It's\n+             * also difficult for Carol to efficiently scan for labels without\n+             * the transaction outputs, but Carol can still use labels as a\n+             * light client by pregenerating all possible labels and adding them\n+             * to the generated output (i.e., `k = 0`). Once at least one output\n+             * is found, she can request the full block and scan the full\n+             * transaction. This assumes Carol will only use a small number of\n+             * of labels as a light client.\n+             *\n+             * Additionally, Carol likely does not have access to the\n+             * transaction inputs and prevout information, so she uses the\n+             * `prevouts_summary` object created by Bob's full node earlier. This\n+             * serialized `prevouts_summary` object contains everything she needs for\n+             * generating the shared secret, i.e., `input_hash * A_sum`.",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 494,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "A_sum is still BIP-style",
      "created_at": "2025-09-09T07:49:32Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332353256",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332353256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 494,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332354575",
      "pull_request_review_id": 3199782557,
      "id": 2332354575,
      "node_id": "PRRC_kwDOAP4Jqs6LBOgP",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the prevouts data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_prevouts_summary` object. He uses\n+             * this for his own scanning and also serializes the `prevouts_summary`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `prevouts_summary` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\n+                &prevouts_summary,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the prevouts data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that prevouts_summary_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the prevouts data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_serialize(ctx,\n+                light_client_data33,\n+                &prevouts_summary\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &prevouts_summary,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the prevouts data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );\n+                    assert(ret);\n+                    print_hex(serialized_xonly, sizeof(serialized_xonly));\n+\n+                    /* Verify that this output is spendable by Bob by reconstructing the full\n+                     * secret key for the xonly output.\n+                     *\n+                     * This is done by adding the tweak from the transaction to Bob's spend key.\n+                     * If the output was sent to a labeled address, the label tweak has\n+                     * already been added to the tweak returned in `_silentpayments_found_output`.\n+                     *\n+                     * To verify that we are able to sign for this output, it is sufficient to\n+                     * check that the public key generated from `full_seckey` matches the output\n+                     * in the transaction. For a full example on signing for a schnorr ouput,\n+                     * see `examples/schnorr.c` */\n+                    memcpy(&full_seckey, &bob_spend_key, 32);\n+                    ret = secp256k1_ec_seckey_tweak_add(ctx, full_seckey, found_outputs[i].tweak);\n+                    ret &= secp256k1_keypair_create(ctx, &kp, full_seckey);\n+                    ret &= secp256k1_keypair_xonly_pub(\n+                        ctx,\n+                        &xonly_output,\n+                        NULL,\n+                        &kp\n+                    );\n+                    /* We assert here because the only way the seckey_tweak_add operation can fail\n+                     * is if the tweak is the negation of Bob's spend key.\n+                     *\n+                     * We also assert that the generated public key matches the transaction output,\n+                     * as it should be impossible for a mismatch at this point considering the\n+                     * scanning function completed without errors and indicated found outputs. */\n+                    assert(ret);\n+                    assert(secp256k1_xonly_pubkey_cmp(ctx, &xonly_output, &found_outputs[i].output) == 0);\n+                }\n+            } else {\n+                printf(\"\\n\");\n+                printf(\"Bob did not find any outputs in this transaction.\");\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists. It's\n+             * also difficult for Carol to efficiently scan for labels without\n+             * the transaction outputs, but Carol can still use labels as a\n+             * light client by pregenerating all possible labels and adding them\n+             * to the generated output (i.e., `k = 0`). Once at least one output\n+             * is found, she can request the full block and scan the full\n+             * transaction. This assumes Carol will only use a small number of\n+             * of labels as a light client.\n+             *\n+             * Additionally, Carol likely does not have access to the\n+             * transaction inputs and prevout information, so she uses the\n+             * `prevouts_summary` object created by Bob's full node earlier. This\n+             * serialized `prevouts_summary` object contains everything she needs for\n+             * generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of\n+             * time but we are cheating here to keep the example simple.",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 497,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The number of *found* outputs?",
      "created_at": "2025-09-09T07:50:05Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332354575",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332354575"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 496,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332361334",
      "pull_request_review_id": 3199782557,
      "id": 2332361334,
      "node_id": "PRRC_kwDOAP4Jqs6LBQJ2",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the prevouts data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_prevouts_summary` object. He uses\n+             * this for his own scanning and also serializes the `prevouts_summary`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `prevouts_summary` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\n+                &prevouts_summary,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the prevouts data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that prevouts_summary_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the prevouts data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_serialize(ctx,\n+                light_client_data33,\n+                &prevouts_summary\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &prevouts_summary,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the prevouts data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );\n+                    assert(ret);\n+                    print_hex(serialized_xonly, sizeof(serialized_xonly));\n+\n+                    /* Verify that this output is spendable by Bob by reconstructing the full\n+                     * secret key for the xonly output.\n+                     *\n+                     * This is done by adding the tweak from the transaction to Bob's spend key.\n+                     * If the output was sent to a labeled address, the label tweak has\n+                     * already been added to the tweak returned in `_silentpayments_found_output`.\n+                     *\n+                     * To verify that we are able to sign for this output, it is sufficient to\n+                     * check that the public key generated from `full_seckey` matches the output\n+                     * in the transaction. For a full example on signing for a schnorr ouput,\n+                     * see `examples/schnorr.c` */\n+                    memcpy(&full_seckey, &bob_spend_key, 32);",
      "path": "examples/silentpayments.c",
      "position": 462,
      "original_position": 451,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We should clean `full_seckey` at some point.",
      "created_at": "2025-09-09T07:52:48Z",
      "updated_at": "2025-09-09T07:53:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332361334",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332361334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 462,
      "original_line": 462,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332635803",
      "pull_request_review_id": 3200269748,
      "id": 2332635803,
      "node_id": "PRRC_kwDOAP4Jqs6LCTKb",
      "diff_hunk": "@@ -172,6 +174,265 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_prevouts_summary {",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": 2330804325,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think having the `sender` and `recipient` infixes should be sufficient and would prefer to keep the names simple, wherever possible. Its also a good point that including recipient in the struct name is at best redundant and at worst confusing.",
      "created_at": "2025-09-09T09:07:26Z",
      "updated_at": "2025-09-09T09:07:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332635803",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332635803"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332904767",
      "pull_request_review_id": 3200665874,
      "id": 2332904767,
      "node_id": "PRRC_kwDOAP4Jqs6LDU0_",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the prevouts data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_prevouts_summary` object. He uses\n+             * this for his own scanning and also serializes the `prevouts_summary`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `prevouts_summary` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\n+                &prevouts_summary,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the prevouts data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that prevouts_summary_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the prevouts data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_serialize(ctx,\n+                light_client_data33,\n+                &prevouts_summary\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &prevouts_summary,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the prevouts data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );\n+                    assert(ret);\n+                    print_hex(serialized_xonly, sizeof(serialized_xonly));\n+\n+                    /* Verify that this output is spendable by Bob by reconstructing the full\n+                     * secret key for the xonly output.\n+                     *\n+                     * This is done by adding the tweak from the transaction to Bob's spend key.\n+                     * If the output was sent to a labeled address, the label tweak has\n+                     * already been added to the tweak returned in `_silentpayments_found_output`.\n+                     *\n+                     * To verify that we are able to sign for this output, it is sufficient to\n+                     * check that the public key generated from `full_seckey` matches the output\n+                     * in the transaction. For a full example on signing for a schnorr ouput,\n+                     * see `examples/schnorr.c` */\n+                    memcpy(&full_seckey, &bob_spend_key, 32);\n+                    ret = secp256k1_ec_seckey_tweak_add(ctx, full_seckey, found_outputs[i].tweak);\n+                    ret &= secp256k1_keypair_create(ctx, &kp, full_seckey);\n+                    ret &= secp256k1_keypair_xonly_pub(\n+                        ctx,\n+                        &xonly_output,\n+                        NULL,\n+                        &kp\n+                    );\n+                    /* We assert here because the only way the seckey_tweak_add operation can fail\n+                     * is if the tweak is the negation of Bob's spend key.\n+                     *\n+                     * We also assert that the generated public key matches the transaction output,\n+                     * as it should be impossible for a mismatch at this point considering the\n+                     * scanning function completed without errors and indicated found outputs. */\n+                    assert(ret);\n+                    assert(secp256k1_xonly_pubkey_cmp(ctx, &xonly_output, &found_outputs[i].output) == 0);\n+                }\n+            } else {\n+                printf(\"\\n\");\n+                printf(\"Bob did not find any outputs in this transaction.\");\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists. It's\n+             * also difficult for Carol to efficiently scan for labels without\n+             * the transaction outputs, but Carol can still use labels as a\n+             * light client by pregenerating all possible labels and adding them\n+             * to the generated output (i.e., `k = 0`). Once at least one output\n+             * is found, she can request the full block and scan the full\n+             * transaction. This assumes Carol will only use a small number of\n+             * of labels as a light client.\n+             *\n+             * Additionally, Carol likely does not have access to the\n+             * transaction inputs and prevout information, so she uses the\n+             * `prevouts_summary` object created by Bob's full node earlier. This\n+             * serialized `prevouts_summary` object contains everything she needs for\n+             * generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of\n+             * time but we are cheating here to keep the example simple.",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 497,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": 2332354575,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Technically, Carol wouldn't know anything about the transaction, i.e., the total number of inputs, outputs, or found outputs. But I think its more correct to be explicit here and say \"found outputs\" since we are only using this information to initialize the `ser_found_outputs` array.",
      "created_at": "2025-09-09T10:11:45Z",
      "updated_at": "2025-09-09T10:11:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332904767",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332904767"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 496,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332906352",
      "pull_request_review_id": 3200667712,
      "id": 2332906352,
      "node_id": "PRRC_kwDOAP4Jqs6LDVNw",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts data from the transaction\n+             *        and call `_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_prevouts_summary prevouts_summary;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the prevouts data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_prevouts_summary` object. He uses\n+             * this for his own scanning and also serializes the `prevouts_summary`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `prevouts_summary` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\n+                &prevouts_summary,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the prevouts data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that prevouts_summary_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the prevouts data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_prevouts_summary_serialize(ctx,\n+                light_client_data33,\n+                &prevouts_summary\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &prevouts_summary,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the prevouts data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );\n+                    assert(ret);\n+                    print_hex(serialized_xonly, sizeof(serialized_xonly));\n+\n+                    /* Verify that this output is spendable by Bob by reconstructing the full\n+                     * secret key for the xonly output.\n+                     *\n+                     * This is done by adding the tweak from the transaction to Bob's spend key.\n+                     * If the output was sent to a labeled address, the label tweak has\n+                     * already been added to the tweak returned in `_silentpayments_found_output`.\n+                     *\n+                     * To verify that we are able to sign for this output, it is sufficient to\n+                     * check that the public key generated from `full_seckey` matches the output\n+                     * in the transaction. For a full example on signing for a schnorr ouput,",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 449,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": 2332348570,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think taproot is better here.",
      "created_at": "2025-09-09T10:12:02Z",
      "updated_at": "2025-09-09T10:12:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332906352",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332906352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332909889",
      "pull_request_review_id": 3200673020,
      "id": 2332909889,
      "node_id": "PRRC_kwDOAP4Jqs6LDWFB",
      "diff_hunk": "@@ -0,0 +1,598 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 213,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "09d1aee8300f1d6c4623b1c09cef569826954039",
      "in_reply_to_id": 2332313466,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No reason, good catch!",
      "created_at": "2025-09-09T10:12:59Z",
      "updated_at": "2025-09-09T10:12:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332909889",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332909889"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 212,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332914686",
      "pull_request_review_id": 3200680147,
      "id": 2332914686,
      "node_id": "PRRC_kwDOAP4Jqs6LDXP-",
      "diff_hunk": "@@ -7,10 +7,291 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 56,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "b802ecfd6cdf855938ada68a7322321aca5f7d41",
      "in_reply_to_id": 2330860594,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I went ahead and took this suggestion now. I think its much cleaner and makes the call sites of `_calculate_input_hash_scalar` easier to understand without the the duplicated overflow checking and comment explaining why.",
      "created_at": "2025-09-09T10:14:04Z",
      "updated_at": "2025-09-09T10:14:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2332914686",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2332914686"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2333111055",
      "pull_request_review_id": 3200948503,
      "id": 2333111055,
      "node_id": "PRRC_kwDOAP4Jqs6LEHMP",
      "diff_hunk": "@@ -364,4 +364,357 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][input_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge input_pubkey_sum_ge, addend;\n+    secp256k1_gej input_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: input_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&input_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&input_pubkey_sum_gej, &input_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&input_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&input_pubkey_sum_ge, &input_pubkey_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &input_pubkey_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &input_pubkey_sum_ge);\n+    memcpy(&prevouts_summary->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_recipient_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, input_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&input_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &input_pubkey_sum_ge, &rsk_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate output = spend_pubkey + t_k * G.\n+         * This can fail if t_k is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as t_k is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+            secp256k1_scalar_clear(&rsk_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 230,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "91789906aa27a83e93d188fd6dd29ed2d9a492cf",
      "in_reply_to_id": 2330790125,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It is \"BIP-style,\" in that its the terminology used in the BIP. I think the most accurate thing to call it would be \"output_tweak,\" since this is the value that is created from the hash of the shared secret (with counter k), and then used as an additive tweak with the spend public key / spend private key.",
      "created_at": "2025-09-09T11:06:14Z",
      "updated_at": "2025-09-09T11:06:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2333111055",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2333111055"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 591,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 620,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336501632",
      "pull_request_review_id": 3205791238,
      "id": 2336501632,
      "node_id": "PRRC_kwDOAP4Jqs6LRC-A",
      "diff_hunk": "@@ -0,0 +1,602 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+#define N_INPUTS  2\n+#define N_OUTPUTS 3\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 84,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "a9d8fce0a3ee548ac031e5c31e146634f8412cb7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  The structs and callback function are implemented here as a demonstration\r\n```",
      "created_at": "2025-09-10T11:51:26Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336501632",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336501632"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336502543",
      "pull_request_review_id": 3205791238,
      "id": 2336502543,
      "node_id": "PRRC_kwDOAP4Jqs6LRDMP",
      "diff_hunk": "@@ -0,0 +1,602 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+#define N_INPUTS  2\n+#define N_OUTPUTS 3\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In production, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending (Alice) ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        /* 2D array for holding multiple public key pairs. The second index, i.e., [2],\n+         * is to represent the spend and scan public keys. */\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"Something went wrong, this is not a valid silent payments address.\\n\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol:\\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            ret = secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            assert(ret);\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant prevouts from the transaction and call\n+             *        `secp256k1_silentpayments_recipient_prevouts_summary_create`\n+             *     2. Call `secp256k1__silentpayments_recipient_scan_outputs`",
      "path": "examples/silentpayments.c",
      "position": 1,
      "original_position": 282,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "a9d8fce0a3ee548ac031e5c31e146634f8412cb7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\r\n```",
      "created_at": "2025-09-10T11:51:51Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336502543",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336502543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336505476",
      "pull_request_review_id": 3205791238,
      "id": 2336505476,
      "node_id": "PRRC_kwDOAP4Jqs6LRD6E",
      "diff_hunk": "@@ -120,6 +120,59 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 48,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "faebc5972b924b978cb83aa25647533ad6992ced",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "formatting nit\r\n```suggestion\r\n *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\r\n *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend pubkey\r\n *                         label: pointer to the recipient's label public key\r\n```",
      "created_at": "2025-09-10T11:53:09Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336505476",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336505476"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 163,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336508102",
      "pull_request_review_id": 3205791238,
      "id": 2336508102,
      "node_id": "PRRC_kwDOAP4Jqs6LREjG",
      "diff_hunk": "@@ -236,6 +252,15 @@ int main(int argc, char** argv) {\n     }\n #endif\n \n+#ifndef ENABLE_MODULE_SILENTPAYMENTS\n+    if (have_flag(argc, argv, \"silentpayments\") || have_flag(argc, argv, \"silentpayments_full_scan\") ||\n+        have_flag(argc, argv, \"silentpayments_full_scan_with_labels\") || have_flag(argc, argv, \"silentpayments_output_scan\")) {\n+        fprintf(stderr, \"./bench: silentpayments module not enabled.\\n\");\n+        fprintf(stderr, \"Use ./configure --enable-module-silentpayments.\\n\\n\");\n+        return 1;",
      "path": "src/bench.c",
      "position": 1,
      "original_position": 98,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "65a4967f557c73f462b50a059a3678b75dca83d6",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n        return EXIT_FAILURE;\r\n```",
      "created_at": "2025-09-10T11:54:16Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336508102",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336508102"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336510772",
      "pull_request_review_id": 3205791238,
      "id": 2336510772,
      "node_id": "PRRC_kwDOAP4Jqs6LRFM0",
      "diff_hunk": "@@ -365,4 +365,349 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 4,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "afdb7f77249ca7a83cc86c2d2a21309079264c2a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n/** An explanation of the prevouts_summary object and its usage:\r\n```",
      "created_at": "2025-09-10T11:55:26Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336510772",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336510772"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 368,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336534258",
      "pull_request_review_id": 3205791238,
      "id": 2336534258,
      "node_id": "PRRC_kwDOAP4Jqs6LRK7y",
      "diff_hunk": "@@ -365,4 +365,349 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 44,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "afdb7f77249ca7a83cc86c2d2a21309079264c2a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: other functions that access the `_prevouts_summary.data` array (e.g. `_prevouts_summary_{serialize,parse}`) don't use this constant and directly access at offset `5 + 64` instead, so for consistency, could either remove it here (my preference) or introduce it in the other functions as well",
      "created_at": "2025-09-10T12:05:07Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336534258",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336534258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 408,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336542419",
      "pull_request_review_id": 3205791238,
      "id": 2336542419,
      "node_id": "PRRC_kwDOAP4Jqs6LRM7T",
      "diff_hunk": "@@ -365,4 +365,349 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge);\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + pubkeylen], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, rsk_scalar;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 164,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "afdb7f77249ca7a83cc86c2d2a21309079264c2a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit, here and in the `_create_shared_secret` function: could rename `rsk_scalar` to something more explicit like `scan_key_scalar` (even after many review rounds, I tend to repeatedly forget that `rsk` is short for \"recipient scan key\")",
      "created_at": "2025-09-10T12:08:11Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336542419",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336542419"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 528,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336599208",
      "pull_request_review_id": 3205791238,
      "id": 2336599208,
      "node_id": "PRRC_kwDOAP4Jqs6LRayo",
      "diff_hunk": "@@ -173,6 +175,265 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_prevouts_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevouts_summary object created with `_recipent_prevouts_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_prevouts_summary` in\n+ *  In: prevouts_summary: pointer to an initialized silentpayments_prevouts_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevouts_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevouts_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:              ctx: pointer to a context object.\n+ *  Out:  prevouts_summary: pointer to a silentpayments_prevouts_summary object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_prevouts_summary.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 115,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "afdb7f77249ca7a83cc86c2d2a21309079264c2a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "formatting nit\r\n```suggestion\r\n *  Out:  prevouts_summary: pointer to a silentpayments_prevouts_summary object. If 1 is\r\n *                          returned, it is set to a parsed version of input33.\r\n *  In:            input33: pointer to a serialized silentpayments_prevouts_summary.\r\n```",
      "created_at": "2025-09-10T12:28:24Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336599208",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336599208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 271,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336601921",
      "pull_request_review_id": 3205791238,
      "id": 2336601921,
      "node_id": "PRRC_kwDOAP4Jqs6LRbdB",
      "diff_hunk": "@@ -365,4 +365,349 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevout_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevout_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevout_pubkey_sum.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 21,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "afdb7f77249ca7a83cc86c2d2a21309079264c2a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "s/prevout_pubkey_sum/prevouts_pubkey_sum/",
      "created_at": "2025-09-10T12:29:23Z",
      "updated_at": "2025-09-10T12:55:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336601921",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336601921"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 381,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 385,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336609162",
      "pull_request_review_id": 3205791238,
      "id": 2336609162,
      "node_id": "PRRC_kwDOAP4Jqs6LRdOK",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 107,
      "original_position": 107,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "65a4967f557c73f462b50a059a3678b75dca83d6",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: k is initialized to zero and never changes in this benchmark, was the plan to increment it in the loop in order to have changing input data? (didn't check if it leads to significantly different results, I presume it doesn't)",
      "created_at": "2025-09-10T12:32:14Z",
      "updated_at": "2025-09-10T13:06:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2336609162",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2336609162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 102,
      "original_start_line": 102,
      "start_side": "RIGHT",
      "line": 107,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2337136189",
      "pull_request_review_id": 3206708270,
      "id": 2337136189,
      "node_id": "PRRC_kwDOAP4Jqs6LTd49",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 107,
      "original_position": 107,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "65a4967f557c73f462b50a059a3678b75dca83d6",
      "in_reply_to_id": 2336609162,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It wasn't the plan, and I'm not sure it makes a difference? FWIW, the scan key in the full tx benchmark is the same on every run, as well. So if we are going to update it so the benchmarks run on different data each iteration, I'd be inclined to update both benchmarks. I'd recommend this as a follow up.",
      "created_at": "2025-09-10T15:25:40Z",
      "updated_at": "2025-09-10T15:25:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2337136189",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2337136189"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 102,
      "original_start_line": 102,
      "start_side": "RIGHT",
      "line": 107,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2341875760",
      "pull_request_review_id": 3212961333,
      "id": 2341875760,
      "node_id": "PRRC_kwDOAP4Jqs6LljAw",
      "diff_hunk": "@@ -25,6 +26,100 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 54,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "307df90a62e76d5a42e0f04afd8a4e980efafab7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in the `_sender_create_outputs` API docs: looking closer at the statistically improbable (and thus untestable) failure cases, I think strictly speaking this documentation is currently incorrect, as we would not return 0 if any of these hash result sclars were indeed larger than or equal than the curve order, as `_scalar_set_b32` would just reduce them (mod n) and the function would still succeed and create some outputs (which might or might not be found by receivers, depending on if their implementation reduces these hash values as well or fails on overflow); the overflow condition check is only `VERIFY_CHECK`ed and hence not active in production. According to BIP352 we [should](https://github.com/bitcoin/bips/blob/abf3bdab2947cad5204b60d298b305adc597f04c/bip-0352.mediawiki?plain=1#L337) [fail](https://github.com/bitcoin/bips/blob/abf3bdab2947cad5204b60d298b305adc597f04c/bip-0352.mediawiki?plain=1#L343), but then we would introduce code branches that can't be tested, which as far as I understood we want to avoid in general in libsecp.\r\n\r\nNot sure what to do about this, but if we keep the code as-is, I tend to think the mentioning of statistically improbable cases resulting from hash values could be removed from the API docs (it's not something the user has direct control of or could avoid, so it seems to provide not much value, especially if it refers to internal variables).",
      "created_at": "2025-09-11T17:31:51Z",
      "updated_at": "2025-09-11T18:41:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2341875760",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2341875760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 68,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2341985160",
      "pull_request_review_id": 3212961333,
      "id": 2341985160,
      "node_id": "PRRC_kwDOAP4Jqs6Ll9uI",
      "diff_hunk": "@@ -7,10 +7,292 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 80,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "307df90a62e76d5a42e0f04afd8a4e980efafab7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should `VERIFY_CHECK` here for non-zero as well (same as in `_create_output_tweak` below)\r\n```suggestion\r\n    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\r\n    VERIFY_CHECK(!overflow);\r\n    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\r\n```",
      "created_at": "2025-09-11T18:17:38Z",
      "updated_at": "2025-09-11T18:36:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2341985160",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2341985160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 83,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2342008968",
      "pull_request_review_id": 3212961333,
      "id": 2342008968,
      "node_id": "PRRC_kwDOAP4Jqs6LmDiI",
      "diff_hunk": "@@ -7,10 +7,292 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. We use a VERIFY_CHECK as opposed to returning an error,\n+     * since returning an error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 202,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "307df90a62e76d5a42e0f04afd8a4e980efafab7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yocto-nit: could move this ARG_CHECK up to after `n_recipients` to match the order of the input parameters",
      "created_at": "2025-09-11T18:27:48Z",
      "updated_at": "2025-09-11T18:36:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2342008968",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2342008968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2343939144",
      "pull_request_review_id": 3216242558,
      "id": 2343939144,
      "node_id": "PRRC_kwDOAP4Jqs6LtaxI",
      "diff_hunk": "@@ -25,6 +26,100 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 54,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "307df90a62e76d5a42e0f04afd8a4e980efafab7",
      "in_reply_to_id": 2341875760,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've gone back and forth on this in my own head so many times 😅 You're correct that the documentation is incorrect. Looking at this with fresh eyes, I do think the best thing to do here is return an error to ensure strict compliance with the BIP. This does introduce a few untestable branches, but I think a comment explaining why we have an untestable branch is sufficient.\r\n\r\nIts also worth mentioning we aren't _really_ adding extra cases the callers would need to handle: the function outputs 0 or 1, and in all cases the caller is expected to try again with different inputs.\r\n\r\ncc @real-or-random , iirc you've made some compelling arguments in the past against returning an error here, curious to hear your thoughts.",
      "created_at": "2025-09-12T11:42:01Z",
      "updated_at": "2025-09-12T11:42:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2343939144",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2343939144"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 68,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2345047308",
      "pull_request_review_id": 3218091998,
      "id": 2345047308,
      "node_id": "PRRC_kwDOAP4Jqs6LxpUM",
      "diff_hunk": "@@ -25,6 +26,100 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 54,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "307df90a62e76d5a42e0f04afd8a4e980efafab7",
      "in_reply_to_id": 2341875760,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I've gone back and forth on this in my own head so many times 😅 You're correct that the documentation is incorrect. Looking at this with fresh eyes, I do think the best thing to do here is return an error to ensure strict compliance with the BIP. This does introduce a few untestable branches, but I think a comment explaining why we have an untestable branch is sufficient.\r\n\r\nI tend to agree, and it seems a very reasonable choice to strictly follow the BIP [1] when in doubt. My current stance on this is that either approach should be fine (as long as the API docs are accurate), and this is much more of a theoretical/philosophical question, rather than one that would ever be relevant in practice, but happy to hear more arguments for either side.\r\n\r\n[1] in theory one option would be to change the BIP to reduce these hash scalars modulo n (like e.g. done in BIP340), but I assume it's a bit too late for that, and that still wouldn't eliminate the zero-scalar failure case (though that one is again orders of magnitude less likely than the equal-or-above-group-order case :P).",
      "created_at": "2025-09-12T17:54:55Z",
      "updated_at": "2025-09-12T17:54:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2345047308",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2345047308"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 68,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348553335",
      "pull_request_review_id": 3223935462,
      "id": 2348553335,
      "node_id": "PRRC_kwDOAP4Jqs6L_BR3",
      "diff_hunk": "@@ -25,6 +26,100 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 54,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "307df90a62e76d5a42e0f04afd8a4e980efafab7",
      "in_reply_to_id": 2341875760,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've updated this to handle the error explicitly, while also commenting this is for strict compliance with the BIP and results in an untestable branch of the code.\r\n\r\nRegarding reducing hash scalars modulo n, I do think its too late for that and I also pushed back against that when we were designing the protocol. I wish I had a better reason for not liking it besides \"it makes me uncomfortable.\" 😅  But this is a topic I plan to dig into at some point in the future more generally, e.g., when is it appropriate to reduce a hash scalar modulo the curve and when should we be concerned about it. ",
      "created_at": "2025-09-15T10:29:43Z",
      "updated_at": "2025-09-15T10:29:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2348553335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348553335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 68,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348787418",
      "pull_request_review_id": 3224290742,
      "id": 2348787418,
      "node_id": "PRRC_kwDOAP4Jqs6L_6ba",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 86,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there a reason we handle overflow different to 0 (same in `create_output_tweak`)?",
      "created_at": "2025-09-15T12:07:28Z",
      "updated_at": "2025-09-15T13:17:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2348787418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348787418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 84,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348921993",
      "pull_request_review_id": 3224290742,
      "id": 2348921993,
      "node_id": "PRRC_kwDOAP4Jqs6MAbSJ",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 73,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's not clear if \"statistically improbable\" applies to the function returning 0 or just to the scalars being invalid. I guess it only applies to the scalars being invalid because the function calls `create_output_pubkey` which fails if `output_tweak_scalar*G = -spend_pubkey`. The comment says that this has only \"negligible probability for honestly created spend_pubkey\". Couldn't a dishonest party set their `spend_pubkey` to `output_tweak_scalar*G`? If yes, then we should also not assert in the example. Same applies to `recipient_create_output_pubkey`.",
      "created_at": "2025-09-15T12:59:59Z",
      "updated_at": "2025-09-15T13:17:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2348921993",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348921993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 71,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348927918",
      "pull_request_review_id": 3224290742,
      "id": 2348927918,
      "node_id": "PRRC_kwDOAP4Jqs6MAcuu",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 218,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's not clear to the reader if \"statistically improbable\" applies to the function returning 0 or just to the scalar being invalid.",
      "created_at": "2025-09-15T13:02:22Z",
      "updated_at": "2025-09-15T13:17:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2348927918",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348927918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 217,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348945731",
      "pull_request_review_id": 3224290742,
      "id": 2348945731,
      "node_id": "PRRC_kwDOAP4Jqs6MAhFD",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 163,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That spend pubkey + label sum to zero is only statistically improbable for a honestly created label. Can you imagine that this function is called with untrusted inputs? The example asserts that this function returns 1.",
      "created_at": "2025-09-15T13:08:53Z",
      "updated_at": "2025-09-15T13:17:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2348945731",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348945731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 162,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348960258",
      "pull_request_review_id": 3224290742,
      "id": 2348960258,
      "node_id": "PRRC_kwDOAP4Jqs6MAkoC",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_prevouts_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevouts_summary object created with `_recipent_prevouts_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_prevouts_summary` in\n+ *  In: prevouts_summary: pointer to an initialized silentpayments_prevouts_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevouts_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevouts_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:              ctx: pointer to a context object.\n+ *  Out:  prevouts_summary: pointer to a silentpayments_prevouts_summary object. If 1 is\n+ *                          returned, it is set to a parsed version of input33.\n+ *  In:            input33: pointer to a serialized silentpayments_prevouts_summary.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if any combination of the shared secret, label and spend public keys\n+ *             sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 335,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Doesn't this only fail if \"output_tweak * G is the negation of spend_pubkey\"? This doesn't seem to be statistically improbable, because a malicious party could have set their `spend_key` to `-output_tweak * G`. In the example we also don't trust that this is statistically improbable and explicitly check the return value.",
      "created_at": "2025-09-15T13:13:47Z",
      "updated_at": "2025-09-15T13:17:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2348960258",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348960258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 334,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348968948",
      "pull_request_review_id": 3224290742,
      "id": 2348968948,
      "node_id": "PRRC_kwDOAP4Jqs6MAmv0",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as output_tweak is the output of a hash function. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 614,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As mentioned in the comment in `create_output_pubkey`, this only holds for honestly created spend_pubkeys.",
      "created_at": "2025-09-15T13:17:14Z",
      "updated_at": "2025-09-15T13:17:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2348968948",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2348968948"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 612,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 614,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2350385418",
      "pull_request_review_id": 3226689885,
      "id": 2350385418,
      "node_id": "PRRC_kwDOAP4Jqs6MGAkK",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 28,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "fcd2443665b76e978abadafd1d2599286f923813",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "this constant is now available as `secp256k1_group_order_bytes` in util.h (#1745)",
      "created_at": "2025-09-16T00:29:14Z",
      "updated_at": "2025-09-16T00:40:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2350385418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2350385418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 23,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2350395913",
      "pull_request_review_id": 3226689885,
      "id": 2350395913,
      "node_id": "PRRC_kwDOAP4Jqs6MGDIJ",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\n+    int i;\n+    size_t n_found = 0;\n+    secp256k1_silentpayments_found_output *found_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[2];\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\n+    const void *label_context = use_labels ? label_cache : NULL;\n+\n+    for (i = 0; i < 2; i++) {\n+        found_output_ptrs[i] = &data->found_outputs[i];\n+        tx_output_ptrs[i] = &data->tx_outputs[i];\n+        tx_input_ptrs[i] = &data->tx_inputs[i];\n+    }\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(data->ctx,\n+            &prevouts_summary,\n+            data->smallest_outpoint,\n+            tx_input_ptrs, 2,\n+            NULL, 0\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(data->ctx,\n+            found_output_ptrs, &n_found,\n+            tx_output_ptrs, 2,\n+            data->scan_key,\n+            &prevouts_summary,\n+            &data->spend_pubkey,\n+            label_lookup_fn, label_context)\n+        );\n+    }\n+}\n+\n+static void bench_silentpayments_full_scan(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\n+}\n+\n+/* TODO: currently, the with_labels benchmark ensures all of the labels code paths\n+ * are hit during scanning, but should be extended to measure scanning for labels\n+ * with a sizable labels cache.\n+ */\n+static void bench_silentpayments_full_scan_with_labels(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 1);\n+}\n+\n+static void run_silentpayments_bench(int iters, int argc, char** argv) {\n+    bench_silentpayments_data data;\n+    int d = argc == 1;\n+\n+    /* create a context with no capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 162,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d5fd1871bdbd5488a2ae6dac2e2652033569937e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\r\n```\r\nThat's logically the same, but for consistency with other benchmarks and `_context_create` call-sites. I guess these lines origin from the ECDH benchmark, where it should be fixed too (if anyone wants to open a PR; for that one we could probably even use the static context, as a \"no capabilities\" context is indeed sufficient).",
      "created_at": "2025-09-16T00:40:16Z",
      "updated_at": "2025-09-16T00:40:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2350395913",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2350395913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 161,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352294992",
      "pull_request_review_id": 3229687998,
      "id": 2352294992,
      "node_id": "PRRC_kwDOAP4Jqs6MNSxQ",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 86,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348787418,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Great catch. We should treat both the same, i.e., return an error. BIP352 does specify failing if `input_hash_scalar` is zero or greater than the curve order, we must fail. I had forgotten that zero was included as a failure mode.",
      "created_at": "2025-09-16T12:16:05Z",
      "updated_at": "2025-09-16T12:16:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352294992",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352294992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 84,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352313291",
      "pull_request_review_id": 3229711613,
      "id": 2352313291,
      "node_id": "PRRC_kwDOAP4Jqs6MNXPL",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 218,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348927918,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Someone once told me \"statistics mean nothing to individual experience,\" which feels appropriate here? What I mean is, I'm warming up to removing all references to statistically improbably from the API documentation. For the user, if they hit a failure case, they don't really care if it was the input keys summing to zero, or the specific set of inputs resulting in an invalid scalar because for them the next step is the same: they need to try again with different inputs.\r\n\r\nHow do you feel about simply removing \"statistically improbable\" from the API documentation? I do feel its still worth having comments in the code, especially when it adds an explanation for why we don't have 100% test coverage. ",
      "created_at": "2025-09-16T12:20:30Z",
      "updated_at": "2025-09-16T12:20:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352313291",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352313291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 217,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352317527",
      "pull_request_review_id": 3229717573,
      "id": 2352317527,
      "node_id": "PRRC_kwDOAP4Jqs6MNYRX",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 163,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348945731,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Same argument as https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352313291, I'm no longer convinced \"statistically improbable\" is adding anything for the user.",
      "created_at": "2025-09-16T12:21:29Z",
      "updated_at": "2025-09-16T12:21:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352317527",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352317527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 162,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352402200",
      "pull_request_review_id": 3229840226,
      "id": 2352402200,
      "node_id": "PRRC_kwDOAP4Jqs6MNs8Y",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_prevouts_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevouts_summary object created with `_recipent_prevouts_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_prevouts_summary` in\n+ *  In: prevouts_summary: pointer to an initialized silentpayments_prevouts_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevouts_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevouts_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:              ctx: pointer to a context object.\n+ *  Out:  prevouts_summary: pointer to a silentpayments_prevouts_summary object. If 1 is\n+ *                          returned, it is set to a parsed version of input33.\n+ *  In:            input33: pointer to a serialized silentpayments_prevouts_summary.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if any combination of the shared secret, label and spend public keys\n+ *             sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 335,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348960258,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's not only if output_tweak is the negation of the spend pubkey. This is because when calling this function, the caller passes in an \"unlabeled_spend_pubkey\" and a label_lookup function. If the silent payment was sent to one of their labeled addresses, i.e., spend_pubkey = unlabeled_spend_pubkey + label_tweak * G, then the final output is of the form `unlabeled_spend_pubkey + label_tweak * G + output_tweak * G`.\r\n\r\nAnd agree that a malicious party can choose specific values for spend_pubkey to trigger this, especially given that the set of all possible inputs in silent payments is already known, i.e., the UTXO set.",
      "created_at": "2025-09-16T12:49:08Z",
      "updated_at": "2025-09-16T12:49:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352402200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352402200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 334,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352507057",
      "pull_request_review_id": 3229994641,
      "id": 2352507057,
      "node_id": "PRRC_kwDOAP4Jqs6MOGix",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 646,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there a reason not to use `secp256k1_ge_set_gej_var` here and few lines below in this function? On my machine, this saves `n_tx_outputs` microseconds per `scan_outputs` call.\r\n\r\nIt seems like we can also use `ge_set_gej_var`  in `create_labeled_spend_pubkey` and `prevouts_summary_create`. As an aside, if we also replace it in `create_shared_secret` or `sender_create_outputs`, our ctime tests complain. So seems like that is working!",
      "created_at": "2025-09-16T13:25:00Z",
      "updated_at": "2025-09-16T14:01:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352507057",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352507057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 646,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352528782",
      "pull_request_review_id": 3229994641,
      "id": 2352528782,
      "node_id": "PRRC_kwDOAP4Jqs6MOL2O",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 111,
      "original_position": 111,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I printed `n_found` to confirm what the function is benchmarking. Maybe it make sense to mention somewhere that scanning will not find an output or add `CHECK(n_found == 0)`.",
      "created_at": "2025-09-16T13:31:02Z",
      "updated_at": "2025-09-16T14:01:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352528782",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352528782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352540152",
      "pull_request_review_id": 3229994641,
      "id": 2352540152,
      "node_id": "PRRC_kwDOAP4Jqs6MOOn4",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\n+    int i;\n+    size_t n_found = 0;\n+    secp256k1_silentpayments_found_output *found_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[2];\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\n+    const void *label_context = use_labels ? label_cache : NULL;\n+\n+    for (i = 0; i < 2; i++) {\n+        found_output_ptrs[i] = &data->found_outputs[i];\n+        tx_output_ptrs[i] = &data->tx_outputs[i];\n+        tx_input_ptrs[i] = &data->tx_inputs[i];\n+    }\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(data->ctx,\n+            &prevouts_summary,\n+            data->smallest_outpoint,\n+            tx_input_ptrs, 2,\n+            NULL, 0\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(data->ctx,\n+            found_output_ptrs, &n_found,\n+            tx_output_ptrs, 2,\n+            data->scan_key,\n+            &prevouts_summary,\n+            &data->spend_pubkey,\n+            label_lookup_fn, label_context)\n+        );\n+    }\n+}\n+\n+static void bench_silentpayments_full_scan(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\n+}\n+\n+/* TODO: currently, the with_labels benchmark ensures all of the labels code paths\n+ * are hit during scanning, but should be extended to measure scanning for labels\n+ * with a sizable labels cache.\n+ */",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 152,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Unless I'm missing something this would only benchmark the speed of the labels cache, which we're not planning to implement.",
      "created_at": "2025-09-16T13:34:26Z",
      "updated_at": "2025-09-16T14:01:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352540152",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352540152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 149,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352598946",
      "pull_request_review_id": 3229994641,
      "id": 2352598946,
      "node_id": "PRRC_kwDOAP4Jqs6MOc-i",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 610,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there a reason why we clear secret values everywhere else when this function returns 0 but not here?",
      "created_at": "2025-09-16T13:53:25Z",
      "updated_at": "2025-09-16T14:01:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2352598946",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2352598946"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 608,
      "original_start_line": 608,
      "start_side": "RIGHT",
      "line": 613,
      "original_line": 613,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2353324454",
      "pull_request_review_id": 3231209660,
      "id": 2353324454,
      "node_id": "PRRC_kwDOAP4Jqs6MROGm",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 218,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348927918,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'd be in favor of removing \"statistically improbable\" because it doesn't help the user deciding whether to assert that the return value is 1 or to handle it in some way. We can see this in the examples, where we currently do both even if \"statistically improbable\". I think if we want to be consistent, we only say \"Returns 1 always\" when it really always returns 1 if the API is used correctly, which allows the caller to assert the return value. In cases where the failure probability is really negligible, we'd not specify that it \"Returns 1 always\".\r\n\r\nAdditionally,  \"statistically improbable\" is also an API guarantee that we may not want to make.",
      "created_at": "2025-09-16T18:30:40Z",
      "updated_at": "2025-09-16T18:30:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2353324454",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2353324454"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 217,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2353386466",
      "pull_request_review_id": 3231295465,
      "id": 2353386466,
      "node_id": "PRRC_kwDOAP4Jqs6MRdPi",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_prevouts_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevouts_summary object created with `_recipent_prevouts_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_prevouts_summary` in\n+ *  In: prevouts_summary: pointer to an initialized silentpayments_prevouts_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevouts_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevouts_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:              ctx: pointer to a context object.\n+ *  Out:  prevouts_summary: pointer to a silentpayments_prevouts_summary object. If 1 is\n+ *                          returned, it is set to a parsed version of input33.\n+ *  In:            input33: pointer to a serialized silentpayments_prevouts_summary.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if any combination of the shared secret, label and spend public keys\n+ *             sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 335,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348960258,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe I'm blind, but I only see a return 0 when \"output_tweak * G is the negation of spend_pubkey\". ",
      "created_at": "2025-09-16T19:00:02Z",
      "updated_at": "2025-09-16T19:00:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2353386466",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2353386466"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 334,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2353392960",
      "pull_request_review_id": 3231304908,
      "id": 2353392960,
      "node_id": "PRRC_kwDOAP4Jqs6MRe1A",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 655,
      "original_position": 648,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This argument appears to be oversimplifying because serialize also fails if `label_ge` is the point at infinity. This cannot happen, however, because we only land in this branch if `x(tx_output) != x(generated_output)` (same below).",
      "created_at": "2025-09-16T19:02:58Z",
      "updated_at": "2025-09-17T08:16:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2353392960",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2353392960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 655,
      "original_line": 655,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2353403082",
      "pull_request_review_id": 3231304908,
      "id": 2353403082,
      "node_id": "PRRC_kwDOAP4Jqs6MRhTK",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 63,
      "original_position": 60,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This function requires that `pubkey_sum` is not the point at infinity. We check this explicitly in `recipient_prevouts_summary_create` but not in `sender_create_outputs`. I think we should do that and document the requirement.",
      "created_at": "2025-09-16T19:08:07Z",
      "updated_at": "2025-09-17T08:16:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2353403082",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2353403082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2354571635",
      "pull_request_review_id": 3233031263,
      "id": 2354571635,
      "node_id": "PRRC_kwDOAP4Jqs6MV-lz",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_prevouts_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevouts_summary object created with `_recipent_prevouts_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_prevouts_summary` in\n+ *  In: prevouts_summary: pointer to an initialized silentpayments_prevouts_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevouts_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevouts_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:              ctx: pointer to a context object.\n+ *  Out:  prevouts_summary: pointer to a silentpayments_prevouts_summary object. If 1 is\n+ *                          returned, it is set to a parsed version of input33.\n+ *  In:            input33: pointer to a serialized silentpayments_prevouts_summary.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if any combination of the shared secret, label and spend public keys\n+ *             sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 335,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348960258,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Apologies, I'm blind! We only do a `VERIFY_CHECK` when applying the label tweak here:\r\n\r\nhttps://github.com/bitcoin-core/secp256k1/blob/d8d062eabbf3a98f717ea7779dddcc9eeea80ef6/src/modules/silentpayments/main_impl.h#L684-L685\r\n\r\n.. but given that the label value is returned from a callback function that might be retrieving label values not controlled by the caller (and thus, potentially maliciously created), we should also return here. Also, this is consistent with the principle \"if we can trigger it with a test case, don't do a verify check.\" ",
      "created_at": "2025-09-17T07:24:49Z",
      "updated_at": "2025-09-17T07:24:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2354571635",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2354571635"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 334,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2354608311",
      "pull_request_review_id": 3233086098,
      "id": 2354608311,
      "node_id": "PRRC_kwDOAP4Jqs6MWHi3",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 646,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2352507057,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No reason, great suggestion!",
      "created_at": "2025-09-17T07:38:06Z",
      "updated_at": "2025-09-17T07:38:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2354608311",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2354608311"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 646,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2354611270",
      "pull_request_review_id": 3233090294,
      "id": 2354611270,
      "node_id": "PRRC_kwDOAP4Jqs6MWIRG",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 610,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2352598946,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nope, was likely missed when I changed this from a `VERIFY_CHECK` to a return.",
      "created_at": "2025-09-17T07:39:22Z",
      "updated_at": "2025-09-17T07:39:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2354611270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2354611270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 608,
      "original_start_line": 608,
      "start_side": "RIGHT",
      "line": 613,
      "original_line": 613,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2354621979",
      "pull_request_review_id": 3233105044,
      "id": 2354621979,
      "node_id": "PRRC_kwDOAP4Jqs6MWK4b",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\n+    int i;\n+    size_t n_found = 0;\n+    secp256k1_silentpayments_found_output *found_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[2];\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\n+    const void *label_context = use_labels ? label_cache : NULL;\n+\n+    for (i = 0; i < 2; i++) {\n+        found_output_ptrs[i] = &data->found_outputs[i];\n+        tx_output_ptrs[i] = &data->tx_outputs[i];\n+        tx_input_ptrs[i] = &data->tx_inputs[i];\n+    }\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(data->ctx,\n+            &prevouts_summary,\n+            data->smallest_outpoint,\n+            tx_input_ptrs, 2,\n+            NULL, 0\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(data->ctx,\n+            found_output_ptrs, &n_found,\n+            tx_output_ptrs, 2,\n+            data->scan_key,\n+            &prevouts_summary,\n+            &data->spend_pubkey,\n+            label_lookup_fn, label_context)\n+        );\n+    }\n+}\n+\n+static void bench_silentpayments_full_scan(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\n+}\n+\n+/* TODO: currently, the with_labels benchmark ensures all of the labels code paths\n+ * are hit during scanning, but should be extended to measure scanning for labels\n+ * with a sizable labels cache.\n+ */",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 152,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2352540152,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is a good point. My thinking initially was to create something that confirms that the size of the labels cache won't affect scanning, but that seems like more effort than its worth to implement in C. I think it's best to remove the comment.",
      "created_at": "2025-09-17T07:43:57Z",
      "updated_at": "2025-09-17T07:43:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2354621979",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2354621979"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 149,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355439378",
      "pull_request_review_id": 3234337051,
      "id": 2355439378,
      "node_id": "PRRC_kwDOAP4Jqs6MZScS",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 63,
      "original_position": 60,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2353403082,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In `create_outputs`, we generate the pubkey_sum from the seckey_sum. We do explicitly check that the seckey_sum is not zero before generating the corresponding public point. My assumption was checking the seckey_sum would be sufficient, but it sounds like you're saying we can still end up at the point at infinity from a valid, non-zero scalar? It was my understanding was this is impossible, but happy to add the extra check if my intuition on this is wrong. Otherwise, the extra check feels redundant to me.",
      "created_at": "2025-09-17T12:58:21Z",
      "updated_at": "2025-09-17T12:58:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355439378",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355439378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355442034",
      "pull_request_review_id": 3234341852,
      "id": 2355442034,
      "node_id": "PRRC_kwDOAP4Jqs6MZTFy",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 655,
      "original_position": 648,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2353392960,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed, and the justification of tx_output != generated_output is not obvious. Will add a comment.",
      "created_at": "2025-09-17T12:59:07Z",
      "updated_at": "2025-09-17T12:59:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355442034",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355442034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 655,
      "original_line": 655,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355543841",
      "pull_request_review_id": 3234495591,
      "id": 2355543841,
      "node_id": "PRRC_kwDOAP4Jqs6MZr8h",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 655,
      "original_position": 648,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2353392960,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated comments.",
      "created_at": "2025-09-17T13:32:50Z",
      "updated_at": "2025-09-17T13:32:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355543841",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355543841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 655,
      "original_line": 655,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355544434",
      "pull_request_review_id": 3234496465,
      "id": 2355544434,
      "node_id": "PRRC_kwDOAP4Jqs6MZsFy",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 610,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2352598946,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-09-17T13:33:03Z",
      "updated_at": "2025-09-17T13:33:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355544434",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355544434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 608,
      "original_start_line": 608,
      "start_side": "RIGHT",
      "line": 613,
      "original_line": 613,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355545366",
      "pull_request_review_id": 3234497825,
      "id": 2355545366,
      "node_id": "PRRC_kwDOAP4Jqs6MZsUW",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\n+    int i;\n+    size_t n_found = 0;\n+    secp256k1_silentpayments_found_output *found_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[2];\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\n+    const void *label_context = use_labels ? label_cache : NULL;\n+\n+    for (i = 0; i < 2; i++) {\n+        found_output_ptrs[i] = &data->found_outputs[i];\n+        tx_output_ptrs[i] = &data->tx_outputs[i];\n+        tx_input_ptrs[i] = &data->tx_inputs[i];\n+    }\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(data->ctx,\n+            &prevouts_summary,\n+            data->smallest_outpoint,\n+            tx_input_ptrs, 2,\n+            NULL, 0\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(data->ctx,\n+            found_output_ptrs, &n_found,\n+            tx_output_ptrs, 2,\n+            data->scan_key,\n+            &prevouts_summary,\n+            &data->spend_pubkey,\n+            label_lookup_fn, label_context)\n+        );\n+    }\n+}\n+\n+static void bench_silentpayments_full_scan(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\n+}\n+\n+/* TODO: currently, the with_labels benchmark ensures all of the labels code paths\n+ * are hit during scanning, but should be extended to measure scanning for labels\n+ * with a sizable labels cache.\n+ */",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 152,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2352540152,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed.",
      "created_at": "2025-09-17T13:33:22Z",
      "updated_at": "2025-09-17T13:33:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355545366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355545366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 149,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355546027",
      "pull_request_review_id": 3234498664,
      "id": 2355546027,
      "node_id": "PRRC_kwDOAP4Jqs6MZser",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 111,
      "original_position": 111,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2352528782,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added.",
      "created_at": "2025-09-17T13:33:34Z",
      "updated_at": "2025-09-17T13:33:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355546027",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355546027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355546626",
      "pull_request_review_id": 3234499536,
      "id": 2355546626,
      "node_id": "PRRC_kwDOAP4Jqs6MZsoC",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 646,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2352507057,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added.",
      "created_at": "2025-09-17T13:33:47Z",
      "updated_at": "2025-09-17T13:33:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355546626",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355546626"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 646,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355547227",
      "pull_request_review_id": 3234500433,
      "id": 2355547227,
      "node_id": "PRRC_kwDOAP4Jqs6MZsxb",
      "diff_hunk": "@@ -0,0 +1,171 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\n+    int i;\n+    size_t n_found = 0;\n+    secp256k1_silentpayments_found_output *found_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[2];\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\n+    const void *label_context = use_labels ? label_cache : NULL;\n+\n+    for (i = 0; i < 2; i++) {\n+        found_output_ptrs[i] = &data->found_outputs[i];\n+        tx_output_ptrs[i] = &data->tx_outputs[i];\n+        tx_input_ptrs[i] = &data->tx_inputs[i];\n+    }\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(data->ctx,\n+            &prevouts_summary,\n+            data->smallest_outpoint,\n+            tx_input_ptrs, 2,\n+            NULL, 0\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(data->ctx,\n+            found_output_ptrs, &n_found,\n+            tx_output_ptrs, 2,\n+            data->scan_key,\n+            &prevouts_summary,\n+            &data->spend_pubkey,\n+            label_lookup_fn, label_context)\n+        );\n+    }\n+}\n+\n+static void bench_silentpayments_full_scan(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\n+}\n+\n+/* TODO: currently, the with_labels benchmark ensures all of the labels code paths\n+ * are hit during scanning, but should be extended to measure scanning for labels\n+ * with a sizable labels cache.\n+ */\n+static void bench_silentpayments_full_scan_with_labels(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 1);\n+}\n+\n+static void run_silentpayments_bench(int iters, int argc, char** argv) {\n+    bench_silentpayments_data data;\n+    int d = argc == 1;\n+\n+    /* create a context with no capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 162,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d5fd1871bdbd5488a2ae6dac2e2652033569937e",
      "in_reply_to_id": 2350395913,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-09-17T13:34:00Z",
      "updated_at": "2025-09-17T13:34:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355547227",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355547227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 161,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355547742",
      "pull_request_review_id": 3234501132,
      "id": 2355547742,
      "node_id": "PRRC_kwDOAP4Jqs6MZs5e",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 28,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "fcd2443665b76e978abadafd1d2599286f923813",
      "in_reply_to_id": 2350385418,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed, good catch!",
      "created_at": "2025-09-17T13:34:11Z",
      "updated_at": "2025-09-17T13:34:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355547742",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355547742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 23,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355548362",
      "pull_request_review_id": 3234502130,
      "id": 2355548362,
      "node_id": "PRRC_kwDOAP4Jqs6MZtDK",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(output_tweak_scalar));\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        VERIFY_CHECK(k < SIZE_MAX);\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability as output_tweak is the output of a hash function. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 614,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348968948,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated the comment to clarify.",
      "created_at": "2025-09-17T13:34:23Z",
      "updated_at": "2025-09-17T13:34:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355548362",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355548362"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 612,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 614,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355551899",
      "pull_request_review_id": 3234507030,
      "id": 2355551899,
      "node_id": "PRRC_kwDOAP4Jqs6MZt6b",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 163,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348945731,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed all references to \"statistically improbable,\" which is a bit unfortunate given how many times @theStack had to correct my spelling of \"statistically\" during review, all for nothing 😅 ",
      "created_at": "2025-09-17T13:35:32Z",
      "updated_at": "2025-09-17T13:35:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355551899",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355551899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 162,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355552638",
      "pull_request_review_id": 3234508165,
      "id": 2355552638,
      "node_id": "PRRC_kwDOAP4Jqs6MZuF-",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 218,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348927918,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated.",
      "created_at": "2025-09-17T13:35:48Z",
      "updated_at": "2025-09-17T13:35:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355552638",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355552638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 217,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355556120",
      "pull_request_review_id": 3234513643,
      "id": 2355556120,
      "node_id": "PRRC_kwDOAP4Jqs6MZu8Y",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 73,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348921993,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed \"statistically improbable,\" but reading your comment again I realise I may have missed this assert in the example. If so, will fix in my next push.",
      "created_at": "2025-09-17T13:36:47Z",
      "updated_at": "2025-09-17T13:36:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355556120",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355556120"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 71,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355558334",
      "pull_request_review_id": 3234516785,
      "id": 2355558334,
      "node_id": "PRRC_kwDOAP4Jqs6MZve-",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+#ifdef VERIFIY\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+#else\n+    (void)ret;\n+#endif\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(input_hash_scalar));\n+    return !overflow;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 86,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348787418,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-09-17T13:37:25Z",
      "updated_at": "2025-09-17T13:37:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355558334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355558334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 84,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355560722",
      "pull_request_review_id": 3234519916,
      "id": 2355560722,
      "node_id": "PRRC_kwDOAP4Jqs6MZwES",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_prevouts_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevouts_summary object created with `_recipent_prevouts_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_prevouts_summary` in\n+ *  In: prevouts_summary: pointer to an initialized silentpayments_prevouts_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevouts_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevouts_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:              ctx: pointer to a context object.\n+ *  Out:  prevouts_summary: pointer to a silentpayments_prevouts_summary object. If 1 is\n+ *                          returned, it is set to a parsed version of input33.\n+ *  In:            input33: pointer to a serialized silentpayments_prevouts_summary.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if any combination of the shared secret, label and spend public keys\n+ *             sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 335,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348960258,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed the VERIFY_CHECK, will add a test case that covers this branch in the next push.",
      "created_at": "2025-09-17T13:38:06Z",
      "updated_at": "2025-09-17T13:38:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2355560722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2355560722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 334,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2356786894",
      "pull_request_review_id": 3236276312,
      "id": 2356786894,
      "node_id": "PRRC_kwDOAP4Jqs6MebbO",
      "diff_hunk": "@@ -382,4 +382,379 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 *\n+                 * Note: we can only hit this branch if tx_output != output_xonly. Thus,\n+                 * we can add tx_output_gej + output_negated_ge without needing to check\n+                 * whether or not the result is the point at infinity.\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 *     label2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded.\n+                 *\n+                 * Note: serialize will also fail if label_ge is the point at infinity, but we know\n+                 * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                 * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\n+                 * point at infinity.\n+                 */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[n_found]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &output_tweak_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[n_found]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 */\n+                if (!secp256k1_ec_seckey_tweak_add(ctx, found_outputs[n_found]->tweak, label_tweak)) {\n+                    secp256k1_scalar_clear(&scan_key_scalar);\n+                    secp256k1_scalar_clear(&output_tweak_scalar);\n+                    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                    return 0;\n+                }\n+                secp256k1_pubkey_save(&found_outputs[n_found]->label, &label_ge);\n+            } else {\n+                found_outputs[n_found]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value. */\n+                memset(&found_outputs[n_found]->label, 0, sizeof(secp256k1_pubkey));\n+            }\n+            /* Reset everything for the next round of scanning. */\n+            label_tweak = NULL;\n+            n_found++;\n+            k++;\n+        } else {\n+            break;\n+        }\n+    }\n+    *n_found_outputs = n_found;\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    secp256k1_memclear_explicit(shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const unsigned char *scan_key32, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_scalar rsk;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 342,
      "commit_id": "fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "original_commit_id": "23c19b896e7810dedf461593b545e42a643dcd77",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "naming nit: s/rsk/scan_key_scalar/ (after this, I'm pretty confident that all of the outdated or confusing scan/spend key variable names are fixed)",
      "created_at": "2025-09-17T21:07:11Z",
      "updated_at": "2025-09-17T21:20:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2356786894",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2356786894"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 723,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2356801279",
      "pull_request_review_id": 3236276312,
      "id": 2356801279,
      "node_id": "PRRC_kwDOAP4Jqs6Mee7_",
      "diff_hunk": "@@ -7,10 +7,309 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    ret &= !secp256k1_scalar_is_zero(input_hash_scalar);\n+    return !!ret & !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !!ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 269,
      "commit_id": "fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "original_commit_id": "8044d3770cb64392ad9b93ad7f44da66e92cf159",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in the newly introduced failure branch of the sending function: missing clearing of `seckey_sum_scalar` detected :detective: ",
      "created_at": "2025-09-17T21:13:52Z",
      "updated_at": "2025-09-17T21:22:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2356801279",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2356801279"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 274,
      "original_start_line": 271,
      "start_side": "RIGHT",
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2356811728",
      "pull_request_review_id": 3236276312,
      "id": 2356811728,
      "node_id": "PRRC_kwDOAP4Jqs6MehfQ",
      "diff_hunk": "@@ -0,0 +1,168 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\n+    int i;\n+    size_t n_found = 0;\n+    secp256k1_silentpayments_found_output *found_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[2];\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\n+    const void *label_context = use_labels ? label_cache : NULL;\n+\n+    for (i = 0; i < 2; i++) {\n+        found_output_ptrs[i] = &data->found_outputs[i];\n+        tx_output_ptrs[i] = &data->tx_outputs[i];\n+        tx_input_ptrs[i] = &data->tx_inputs[i];\n+    }\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(data->ctx,\n+            &prevouts_summary,\n+            data->smallest_outpoint,\n+            tx_input_ptrs, 2,\n+            NULL, 0\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(data->ctx,\n+            found_output_ptrs, &n_found,\n+            tx_output_ptrs, 2,\n+            data->scan_key,\n+            &prevouts_summary,\n+            &data->spend_pubkey,\n+            label_lookup_fn, label_context)\n+        );\n+        CHECK(n_found == 0);\n+    }\n+}\n+\n+static void bench_silentpayments_full_scan(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\n+}\n+\n+static void bench_silentpayments_full_scan_with_labels(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 1);\n+}\n+\n+static void run_silentpayments_bench(int iters, int argc, char** argv) {\n+    bench_silentpayments_data data;\n+    int d = argc == 1;\n+\n+    /* create a context with no capabilities */",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 158,
      "commit_id": "fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "original_commit_id": "1a1c7f9ff45e6ff50f0678451577c3dffe39dde9",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: the context has indeed capabilities, so could just remove the comment (or s/no capabilities/signing capabilities/, as done in the EllSwift benchmarks)",
      "created_at": "2025-09-17T21:19:11Z",
      "updated_at": "2025-09-17T21:20:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2356811728",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2356811728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 158,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2358771769",
      "pull_request_review_id": 3239101225,
      "id": 2358771769,
      "node_id": "PRRC_kwDOAP4Jqs6MmAA5",
      "diff_hunk": "@@ -7,10 +7,309 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 22,
      "original_position": 18,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "8044d3770cb64392ad9b93ad7f44da66e92cf159",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 8044d3770cb64392ad9b93ad7f44da66e92cf159 _silentpayments: sending_: in an earlier discussion you said you planned to update this comment, in order to clarify that callers should not assume this is deterministic (and it currently isn't because of the use of heap sort, but that's perhaps an implementation detail).\r\n\r\nLooks like that update went missing.\r\n\r\n`secp256k1_silentpayments_recipient_sort` might be a better place for that comment.\r\n\r\nhttps://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247633383",
      "created_at": "2025-09-18T11:40:21Z",
      "updated_at": "2025-09-18T15:56:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2358771769",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2358771769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 22,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2359894590",
      "pull_request_review_id": 3240486253,
      "id": 2359894590,
      "node_id": "PRRC_kwDOAP4Jqs6MqSI-",
      "diff_hunk": "@@ -7,10 +7,309 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    ret &= !secp256k1_scalar_is_zero(input_hash_scalar);\n+    return !!ret & !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return !!ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Private keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 269,
      "commit_id": "fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "original_commit_id": "8044d3770cb64392ad9b93ad7f44da66e92cf159",
      "in_reply_to_id": 2356801279,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "One of these days, I promise: I will learn how to spell statiscaly , and I will remember to clear my scalars 😅 ",
      "created_at": "2025-09-18T15:26:53Z",
      "updated_at": "2025-09-18T15:26:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2359894590",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2359894590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 274,
      "original_start_line": 271,
      "start_side": "RIGHT",
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2359896826",
      "pull_request_review_id": 3240488804,
      "id": 2359896826,
      "node_id": "PRRC_kwDOAP4Jqs6MqSr6",
      "diff_hunk": "@@ -382,4 +382,379 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and prevouts_pubkey_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ *  - `_recipient_prevouts_summary_serialize` multiplies the input_hash into the summed public key before\n+ *     serializing the resulting point as a compressed public key, if combined = false. If combined = true,\n+ *     the point is serialized back into a compressed public key.\n+ *  - `_recipient_prevouts_summary_parse` assumes the input represents a previously serialized\n+ *    prevouts_summary object and always deserializes into a prevouts_summary object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar to ensure the value is less than the curve order.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_ge ge;\n+    size_t pubkeylen = 33;\n+    int ret, combined;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the prevouts_summary object was created incorrectly\n+     *     and we already check for this above.\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the prevouts_summary object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function.\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity.\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   prevouts_summary object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    ret = 1;\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        ret &= secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+#else\n+    (void)ret;\n+#endif\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_parse(const secp256k1_context *ctx, secp256k1_silentpayments_prevouts_summary *prevouts_summary, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early. */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized prevouts_summary will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes used to represent the input_hash.\n+     */\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 1;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &pk);\n+    memset(&prevouts_summary->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    ret = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar to ensure the value is less than the curve order.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than the curver order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&scan_key_scalar);\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 *\n+                 * Note: we can only hit this branch if tx_output != output_xonly. Thus,\n+                 * we can add tx_output_gej + output_negated_ge without needing to check\n+                 * whether or not the result is the point at infinity.\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded. */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 *     label2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded.\n+                 *\n+                 * Note: serialize will also fail if label_ge is the point at infinity, but we know\n+                 * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                 * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\n+                 * point at infinity.\n+                 */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[n_found]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &output_tweak_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[n_found]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 */\n+                if (!secp256k1_ec_seckey_tweak_add(ctx, found_outputs[n_found]->tweak, label_tweak)) {\n+                    secp256k1_scalar_clear(&scan_key_scalar);\n+                    secp256k1_scalar_clear(&output_tweak_scalar);\n+                    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                    return 0;\n+                }\n+                secp256k1_pubkey_save(&found_outputs[n_found]->label, &label_ge);\n+            } else {\n+                found_outputs[n_found]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value. */\n+                memset(&found_outputs[n_found]->label, 0, sizeof(secp256k1_pubkey));\n+            }\n+            /* Reset everything for the next round of scanning. */\n+            label_tweak = NULL;\n+            n_found++;\n+            k++;\n+        } else {\n+            break;\n+        }\n+    }\n+    *n_found_outputs = n_found;\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    secp256k1_memclear_explicit(shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const unsigned char *scan_key32, const secp256k1_silentpayments_prevouts_summary *prevouts_summary) {\n+    secp256k1_scalar rsk;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 342,
      "commit_id": "fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "original_commit_id": "23c19b896e7810dedf461593b545e42a643dcd77",
      "in_reply_to_id": 2356786894,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "One of these days, I will learn how to use find and replace all 😅 ",
      "created_at": "2025-09-18T15:27:21Z",
      "updated_at": "2025-09-18T15:27:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2359896826",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2359896826"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 723,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2359917508",
      "pull_request_review_id": 3240514331,
      "id": 2359917508,
      "node_id": "PRRC_kwDOAP4Jqs6MqXvE",
      "diff_hunk": "@@ -0,0 +1,168 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized prevouts_summary object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_parse(data->ctx, &prevouts_summary, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &prevouts_summary\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\n+    int i;\n+    size_t n_found = 0;\n+    secp256k1_silentpayments_found_output *found_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[2];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[2];\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_prevouts_summary prevouts_summary;\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\n+    const void *label_context = use_labels ? label_cache : NULL;\n+\n+    for (i = 0; i < 2; i++) {\n+        found_output_ptrs[i] = &data->found_outputs[i];\n+        tx_output_ptrs[i] = &data->tx_outputs[i];\n+        tx_input_ptrs[i] = &data->tx_inputs[i];\n+    }\n+    for (i = 0; i < iters; i++) {\n+        CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(data->ctx,\n+            &prevouts_summary,\n+            data->smallest_outpoint,\n+            tx_input_ptrs, 2,\n+            NULL, 0\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(data->ctx,\n+            found_output_ptrs, &n_found,\n+            tx_output_ptrs, 2,\n+            data->scan_key,\n+            &prevouts_summary,\n+            &data->spend_pubkey,\n+            label_lookup_fn, label_context)\n+        );\n+        CHECK(n_found == 0);\n+    }\n+}\n+\n+static void bench_silentpayments_full_scan(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\n+}\n+\n+static void bench_silentpayments_full_scan_with_labels(void *arg, int iters) {\n+    bench_silentpayments_full_tx_scan(arg, iters, 1);\n+}\n+\n+static void run_silentpayments_bench(int iters, int argc, char** argv) {\n+    bench_silentpayments_data data;\n+    int d = argc == 1;\n+\n+    /* create a context with no capabilities */",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 1,
      "original_position": 158,
      "commit_id": "fe2cec5e2a9b81ed19ed00f9ca56f40a291c1c67",
      "original_commit_id": "1a1c7f9ff45e6ff50f0678451577c3dffe39dde9",
      "in_reply_to_id": 2356811728,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I opted to remove the comment. It didn't feel like it was adding any new information, beyond just describing what the code is doing.",
      "created_at": "2025-09-18T15:31:40Z",
      "updated_at": "2025-09-18T15:31:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2359917508",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2359917508"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 158,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2360009863",
      "pull_request_review_id": 3239101225,
      "id": 2360009863,
      "node_id": "PRRC_kwDOAP4Jqs6MquSH",
      "diff_hunk": "@@ -25,6 +26,99 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars.\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 87,
      "original_position": 62,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "e9350ffd2346e48713ede92e74ce1b62dec1a342",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 8044d3770cb64392ad9b93ad7f44da66e92cf159 _silentpayments: sending_: in line with our earlier discussion, it might be worth warning the user to not drop outputs (at least not for transactions with more than one recipient).\r\n\r\nhttps://github.com/bitcoin-core/secp256k1/pull/1698/commits/8044d3770cb64392ad9b93ad7f44da66e92cf159#r2245582298",
      "created_at": "2025-09-18T15:50:13Z",
      "updated_at": "2025-09-18T15:56:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2360009863",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2360009863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2365817902",
      "pull_request_review_id": 3249258777,
      "id": 2365817902,
      "node_id": "PRRC_kwDOAP4Jqs6NA4Qu",
      "diff_hunk": "@@ -7,10 +7,310 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than the curve order, which",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 71,
      "commit_id": "4428fd35f3733ba799da8e45762bdd6d6d8155d1",
      "original_commit_id": "e9350ffd2346e48713ede92e74ce1b62dec1a342",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "pedantic-nit: s/greater than/greater than or equal/ (here and in many other instances)",
      "created_at": "2025-09-20T21:07:52Z",
      "updated_at": "2025-09-20T21:21:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2365817902",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2365817902"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2365841470",
      "pull_request_review_id": 3249291212,
      "id": 2365841470,
      "node_id": "PRRC_kwDOAP4Jqs6NA-A-",
      "diff_hunk": "@@ -0,0 +1,747 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 63,
      "original_position": 60,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2353403082,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's also my understanding that this can't happen currently in `sender_create_outputs` due to early return if seckey_sum is zero. I'd agree that adding a run-time check is redundant, but I guess adding a `VERIFY_CHECK` line mostly for documentation purposes could make sense.",
      "created_at": "2025-09-20T21:42:49Z",
      "updated_at": "2025-09-20T21:42:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2365841470",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2365841470"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367252974",
      "pull_request_review_id": 3251365737,
      "id": 2367252974,
      "node_id": "PRRC_kwDOAP4Jqs6NGWnu",
      "diff_hunk": "@@ -7,10 +7,310 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than the curve order, which",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 71,
      "commit_id": "4428fd35f3733ba799da8e45762bdd6d6d8155d1",
      "original_commit_id": "e9350ffd2346e48713ede92e74ce1b62dec1a342",
      "in_reply_to_id": 2365817902,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point, initially I was thinking this is correct since a scalar equal to the curve order _is_ zero when reduced module p. But this comment refers to the output of the hash function, meaning the modulus step has not happened yet. So, indeed, `>=` is correct.",
      "created_at": "2025-09-22T09:20:10Z",
      "updated_at": "2025-09-22T09:20:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2367252974",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367252974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367681580",
      "pull_request_review_id": 3251941677,
      "id": 2367681580,
      "node_id": "PRRC_kwDOAP4Jqs6NH_Qs",
      "diff_hunk": "@@ -7,10 +7,310 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than the curve order, which",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 71,
      "commit_id": "4428fd35f3733ba799da8e45762bdd6d6d8155d1",
      "original_commit_id": "e9350ffd2346e48713ede92e74ce1b62dec1a342",
      "in_reply_to_id": 2365817902,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated.",
      "created_at": "2025-09-22T10:59:47Z",
      "updated_at": "2025-09-22T10:59:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2367681580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367681580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367682719",
      "pull_request_review_id": 3251942864,
      "id": 2367682719,
      "node_id": "PRRC_kwDOAP4Jqs6NH_if",
      "diff_hunk": "@@ -25,6 +26,99 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars.\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 87,
      "original_position": 62,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "e9350ffd2346e48713ede92e74ce1b62dec1a342",
      "in_reply_to_id": 2360009863,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added!",
      "created_at": "2025-09-22T11:00:00Z",
      "updated_at": "2025-09-22T11:00:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2367682719",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367682719"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367683995",
      "pull_request_review_id": 3251944372,
      "id": 2367683995,
      "node_id": "PRRC_kwDOAP4Jqs6NH_2b",
      "diff_hunk": "@@ -7,10 +7,309 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 22,
      "original_position": 18,
      "commit_id": "1a21cf1945ad8712a32ff5765bc46cf2cb2a57eb",
      "original_commit_id": "8044d3770cb64392ad9b93ad7f44da66e92cf159",
      "in_reply_to_id": 2358771769,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added, not sure how this was dropped 😅 ",
      "created_at": "2025-09-22T11:00:15Z",
      "updated_at": "2025-09-22T11:00:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2367683995",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367683995"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 22,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367690071",
      "pull_request_review_id": 3251950778,
      "id": 2367690071,
      "node_id": "PRRC_kwDOAP4Jqs6NIBVX",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `_silentpayments_recipient` object with\n+ *                            index = 0.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct silent\n+ *                            payment addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if label_tweak32 is an invalid scalar (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if the input public keys are invalid,\n+ *             or the spend pubkey + label sum to zero (statistically improbable).\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments prevout summary data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_serialize`. The serialization is\n+ *  intended for sending the prevout summary data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payment prevout summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_prevouts_summary_serialize`.\n+ *\n+ *  Returns: 1 if prevout summary creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_prevouts_summary object into a 33-byte sequence.\n+ *\n+ *  Serializing a prevouts_summary object created with `_recipent_prevouts_summary_create` will result in\n+ *  an EC multiplication. This allows for a more compact serialization.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:            ctx: pointer to a context object\n+ *  Out:        output33: pointer to a 33-byte array to place the serialized\n+ *                        `silentpayments_prevouts_summary` in\n+ *  In: prevouts_summary: pointer to an initialized silentpayments_prevouts_summary\n+ *                        object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_prevouts_summary_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_prevouts_summary object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:              ctx: pointer to a context object.\n+ *  Out:  prevouts_summary: pointer to a silentpayments_prevouts_summary object. If 1 is\n+ *                          returned, it is set to a parsed version of input33.\n+ *  In:            input33: pointer to a serialized silentpayments_prevouts_summary.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if any combination of the shared secret, label and spend public keys\n+ *             sum to zero (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 335,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348960258,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a test which covers this branch.",
      "created_at": "2025-09-22T11:01:23Z",
      "updated_at": "2025-09-22T11:01:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2367690071",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367690071"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 334,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367838133",
      "pull_request_review_id": 3252116759,
      "id": 2367838133,
      "node_id": "PRRC_kwDOAP4Jqs6NIle1",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 73,
      "commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "original_commit_id": "d8d062eabbf3a98f717ea7779dddcc9eeea80ef6",
      "in_reply_to_id": 2348921993,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed the inappropriate asserts from the example.",
      "created_at": "2025-09-22T11:34:11Z",
      "updated_at": "2025-09-22T11:34:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2367838133",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2367838133"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 71,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    }
  ]
}