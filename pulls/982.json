{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982",
    "id": 745089373,
    "node_id": "PR_kwDOAP4Jqs4saSld",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/982.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/982.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/d4cbedc023ab921631723a37ea8052d48b1c4537",
    "number": 982,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Add Elligator Square module",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Based on #979.\r\n\r\nThis adds a module with an implementation of the Elligator Squared algorithm for encoding/decoding public keys in uniformly random byte arrays.",
    "labels": [],
    "created_at": "2021-09-28T19:04:34Z",
    "updated_at": "2024-09-20T07:03:02Z",
    "closed_at": "2022-07-07T14:01:10Z",
    "mergeable_state": "unknown",
    "merge_commit_sha": "48fd7105f2ccd9ec6e88ebb45750fd5f0597f946",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "sipa:202109_ellsq",
      "ref": "202109_ellsq",
      "sha": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 16648672,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODY3Mg==",
        "name": "secp256k1",
        "full_name": "sipa/secp256k1",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/secp256k1",
        "archive_url": "https://api.github.com/repos/sipa/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/sipa/secp256k1/events",
        "forks_url": "https://api.github.com/repos/sipa/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/sipa/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/sipa/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/sipa/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/sipa/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/sipa/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/sipa/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/sipa/secp256k1/hooks",
        "svn_url": "https://github.com/sipa/secp256k1",
        "language": "C",
        "forks_count": 20,
        "stargazers_count": 43,
        "watchers_count": 43,
        "size": 12103,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-04-19T15:43:52Z",
        "created_at": "2014-02-08T17:33:30Z",
        "updated_at": "2024-08-30T21:37:44Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "44c2452fd387f7ca604ab42d73746e7d3a44d8a2",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1001,
        "stargazers_count": 2056,
        "watchers_count": 2056,
        "size": 11996,
        "default_branch": "master",
        "open_issues_count": 147,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-18T13:42:10Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2024-09-19T11:48:35Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 1133,
    "deletions": 24,
    "changed_files": 21,
    "commits": 4,
    "review_comments": 14,
    "comments": 11
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 5376091942,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFAcKcm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5376091942",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-28T19:22:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5397583203,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFBuJVj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5397583203",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-10-02T04:08:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5592942644,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFNXYg0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5592942644",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-09T21:30:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5593242127,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFNYhoP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5593242127",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-09T22:18:31Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5593270641,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFNYolx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5593270641",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-09T22:23:07Z"
    },
    {
      "event": "reviewed",
      "id": 804959919,
      "node_id": "PRR_kwDOAP4Jqs4v-rav",
      "url": null,
      "actor": null,
      "commit_id": "f1ad50559ac5ae4db0f3f0e156d45c387b37b2ac",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "tACK 7b1e6260e215174561a2d1fdd7f500ba6eaf1489\r\n\r\nI'll give a full ack once I carefully review:\r\n- [x] Optimizations in section 3 of the writeup\r\n- [x] Low-level implementation\r\n- [x] Argument that the encoding is statistically indistinguishable from 64 random bytes, even with the minor changes (e.g. point at infinity, omitting some duplicate checks)\r\n\r\n---\r\n\r\nBasic question, what would go wrong if we use naive approaches such as:\r\n\r\n(1) Given a random curve point *(x1, y1)*, increment the *x* coordinate until you get another curve point *(x2, y2)*. Use a random field element in *[x1, x2)* as the encoding. Decode by decrementing until you get an *x* corresponding to a curve point.\r\n\r\n(2) Just generate and use a random field element as the encoding; both parties decrement *x* until they get a valid curve point.\r\n\r\nI'm guessing the reason we don't do something like that is (1) will produce field elements that don't look random, and (2) will generate keys in a biased way?",
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#pullrequestreview-804959919",
      "submitted_at": "2021-11-12T20:07:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
    },
    {
      "event": "commented",
      "id": 967464241,
      "node_id": "IC_kwDOAP4Jqs45qlUx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/967464241",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-12T20:11:59Z",
      "updated_at": "2021-11-12T20:12:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "@robot-dreams:\r\n\r\n(1) Indeed, this will result in biased encodings, because the distance between field elements which are valid X coordinates varies, and attacker-known, so they can detect a bias: encodings for which the previous and next valid X coordinate are close together will occur more frequently.\r\n\r\n(2) Biased private key isn't really a problem as long as (a) the bias is small and (b) the bias isn't recognizable from the encodings/public keys, which is the case here. There is another problem however: the encoder wouldn't know the corresponding private key.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-967464241",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "mentioned",
      "id": 5611778616,
      "node_id": "MEE_lADOAP4Jqs48NPwZzwAAAAFOfPI4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5611778616",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-12T20:11:59Z"
    },
    {
      "event": "subscribed",
      "id": 5611778619,
      "node_id": "SE_lADOAP4Jqs48NPwZzwAAAAFOfPI7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5611778619",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-12T20:11:59Z"
    },
    {
      "event": "commented",
      "id": 967472894,
      "node_id": "IC_kwDOAP4Jqs45qnb-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/967472894",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-12T20:16:40Z",
      "updated_at": "2021-11-12T20:16:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "Oops, good point about (2), I am silly. 🤣",
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-967472894",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "commented",
      "id": 967479849,
      "node_id": "IC_kwDOAP4Jqs45qpIp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/967479849",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-12T20:20:34Z",
      "updated_at": "2021-11-12T20:24:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "But about (1), if there were a known upper bound on the distance between valid X coordinates (AFAIK there isn't one, but more than ~128 is probably negligibly rare), you could actually use f(x) = (first point with largest X coordinate not larger than x) as mapping function in the scheme. I suspect that's significantly slower than what we have now though, as you'd need avg 128 iterations, and counting the distance between valid X coordinates around each...",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-967479849",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "reviewed",
      "id": 805205777,
      "node_id": "PRR_kwDOAP4Jqs4v_ncR",
      "url": null,
      "actor": null,
      "commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#pullrequestreview-805205777",
      "submitted_at": "2021-11-12T20:34:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
    },
    {
      "event": "commented",
      "id": 968159119,
      "node_id": "IC_kwDOAP4Jqs45tO-P",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/968159119",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-13T22:46:29Z",
      "updated_at": "2021-11-15T00:45:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "Code Review ACK 7b1e6260e215174561a2d1fdd7f500ba6eaf1489, modulo verifying the proof that the encoding is actually indistinguishable from 64 random bytes\r\n\r\nI opened the different implementations of `f`, `r` side by side and checked that:\r\n- Section 2.6 is equivalent to Section 3\r\n- Section 3 is equivalent to the broken-down Sage implementation\r\n- The C and Sage implementations are equivalent\r\n\r\nBasic question:\r\n- The use of SHA256 for generating branch values seems reasonable, but just wondering, is there a justification that this use of SHA256 gives you a secure PRG (taking `rnd32` as the key)? (Is this a well-known construction?)",
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-968159119",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "reviewed",
      "id": 806192049,
      "node_id": "PRR_kwDOAP4Jqs4wDYOx",
      "url": null,
      "actor": null,
      "commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 7b1e6260e215174561a2d1fdd7f500ba6eaf1489, I don't think the rest of my comments are blocking.\r\n\r\n- I'm happy with the argument that the sampling algorithm produces a uniformly random preimage of a curve point\r\n- Although I wasn't yet able to calculate the exact statistical distance between the distribution implemented here and the distribution described in the paper (handling infinity being the only difference), I suspect that it's O(1/p), i.e. negligible unless I made a big mistake in my estimation.\r\n- I've convinced myself (in part with the help of the section starting with \"Back to Delphia\" in [this article](https://blog.cryptographyengineering.com/2011/10/08/what-is-random-oracle-model-and-why-2/)) that the use of SHA256 to generate random branches / field elements is secure under a random oracle model 😅 sipa's favorite! Here, an attacker would have no choice but to guess `rnd32`.\r\n\r\nThe only thing I haven't verified is that the function `f` is indeed \"well-distributed\", but I don't want to block this PR until I've learned the background material needed to check that—I'm happy to accept that without verifying the proof for now.\r\n\r\nFinally, would it make sense to either:\r\n1. Elaborate on the statement `not terribly non-uniform` in https://github.com/sipa/writeups/tree/main/elligator-square-for-bn#25-dealing-with-infinity\r\n2. Make the encoder NOT target the `f(u) = -f(v)` case, so that it's really easy to show that the statistical distance between the implemented distribution and the one in the paper is neglible (the decoder can still handle that case, so that every 64-byte string decodes to a valid public key)",
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#pullrequestreview-806192049",
      "submitted_at": "2021-11-15T16:54:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
    },
    {
      "event": "commented",
      "id": 969370038,
      "node_id": "IC_kwDOAP4Jqs45x2m2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/969370038",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-15T22:11:29Z",
      "updated_at": "2021-11-15T22:11:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Elaborate on the statement not terribly non-uniform in https://github.com/sipa/writeups/tree/main/elligator-square-for-bn#25-dealing-with-infinity\r\n\r\nI should drop that, as it's confusing. Given the immensely low probability of hitting infinity in the first place, how it is handled is totally irrelevant.\r\n\r\nThis comment aims to indicate that it's better than e.g. mapping infinity to the generator or so (which it is, as it'd mean the generator has ~*2n* ellsq preimages, while other points only have ~*n*), but I don't think that's a useful justification given it's only changing an negligibly frequent event anyway. The real justification is: it's probably the easiest way to implement this edge case.\r\n\r\n> Make the encoder NOT target the f(u) = -f(v) case, so that it's really easy to show that the statistical distance between the implemented distribution and the one in the paper is neglible (the decoder can still handle that case, so that every 64-byte string decodes to a valid public key)\r\n\r\nI don't think it should be hard to show the difference is negligible, given the fact that even *triggering* (much less observing) a case in which the outcome is different is negligible (it requires picking a uniformly random u for which f(u)=-P).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-969370038",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "commented",
      "id": 969897581,
      "node_id": "IC_kwDOAP4Jqs45z3Zt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/969897581",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-16T06:09:12Z",
      "updated_at": "2021-11-16T06:09:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "OK, I'm fully on board with this now! If you're curious, see https://gist.github.com/robot-dreams/86302bfca28bf9dc83ced365cd428f64 for way too much detail that nobody needed or asked for.",
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-969897581",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5627705203,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFPb_dz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5627705203",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-16T21:00:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5627788858,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFPcT46",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5627788858",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-16T21:18:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5627802807,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFPcXS3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5627802807",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-16T21:21:58Z"
    },
    {
      "event": "commented",
      "id": 970737667,
      "node_id": "IC_kwDOAP4Jqs453EgD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/970737667",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-16T22:31:38Z",
      "updated_at": "2021-11-16T22:31:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 07a4ef5a08cea9916cf93603670d8ee4d5340540",
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-970737667",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "referenced",
      "id": 5855886974,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdCb5-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5855886974",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "94767af46217fef4954c78e216384a87d8ffbb14",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/94767af46217fef4954c78e216384a87d8ffbb14",
      "created_at": "2022-01-07T04:26:15Z"
    },
    {
      "event": "referenced",
      "id": 5855886982,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdCb6G",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5855886982",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b3c5aab7ebdd798f45f0270e8564a687e50ee13f",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/b3c5aab7ebdd798f45f0270e8564a687e50ee13f",
      "created_at": "2022-01-07T04:26:15Z"
    },
    {
      "event": "referenced",
      "id": 5855886988,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdCb6M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5855886988",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4a00483129e973b7dcd77e5e815ec6b33875aa13",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/4a00483129e973b7dcd77e5e815ec6b33875aa13",
      "created_at": "2022-01-07T04:26:15Z"
    },
    {
      "event": "referenced",
      "id": 5855983069,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdCzXd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5855983069",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0cfafbda3eba9d2bd6bbb8bb162db98e98b3d6ca",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/0cfafbda3eba9d2bd6bbb8bb162db98e98b3d6ca",
      "created_at": "2022-01-07T05:08:44Z"
    },
    {
      "event": "referenced",
      "id": 5856003830,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdC4b2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5856003830",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "f01f335844e744539f2e6ddeccb29ae0165c5daf",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/f01f335844e744539f2e6ddeccb29ae0165c5daf",
      "created_at": "2022-01-07T05:17:12Z"
    },
    {
      "event": "referenced",
      "id": 5857524567,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdIrtX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5857524567",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8eb51d7e80772c02d6e3219b30fff4297f3dc3ad",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/8eb51d7e80772c02d6e3219b30fff4297f3dc3ad",
      "created_at": "2022-01-07T12:06:11Z"
    },
    {
      "event": "referenced",
      "id": 5857524575,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdIrtf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5857524575",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "915a1c9abb308e00cb8ddc8c9f76fd5211eb6474",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/915a1c9abb308e00cb8ddc8c9f76fd5211eb6474",
      "created_at": "2022-01-07T12:06:11Z"
    },
    {
      "event": "referenced",
      "id": 5861262675,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdW8VT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861262675",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0410b05d16b17f31db2a1ce0643ae9c5a7d7f7ac",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/0410b05d16b17f31db2a1ce0643ae9c5a7d7f7ac",
      "created_at": "2022-01-08T14:16:09Z"
    },
    {
      "event": "referenced",
      "id": 5861262678,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdW8VW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861262678",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a77605a047499b0fad94100fcb4fd94c61e8ea9b",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/a77605a047499b0fad94100fcb4fd94c61e8ea9b",
      "created_at": "2022-01-08T14:16:09Z"
    },
    {
      "event": "referenced",
      "id": 5861262679,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdW8VX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861262679",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8cdf579e8666d581be6aaa7f0b5be4e9ea1a5b01",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/8cdf579e8666d581be6aaa7f0b5be4e9ea1a5b01",
      "created_at": "2022-01-08T14:16:09Z"
    },
    {
      "event": "referenced",
      "id": 5861276407,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdW_r3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861276407",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2e831ff811aaf9afaf8d27f6180aaa002ecbe936",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/2e831ff811aaf9afaf8d27f6180aaa002ecbe936",
      "created_at": "2022-01-08T14:32:02Z"
    },
    {
      "event": "referenced",
      "id": 5861276410,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdW_r6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861276410",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1c2ef4c40f9c87226c2d2ffab6b44afcc828c44e",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/1c2ef4c40f9c87226c2d2ffab6b44afcc828c44e",
      "created_at": "2022-01-08T14:32:02Z"
    },
    {
      "event": "referenced",
      "id": 5861276411,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdW_r7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861276411",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e755867f796d0cfe7539a9d1d82590d918433ee2",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/e755867f796d0cfe7539a9d1d82590d918433ee2",
      "created_at": "2022-01-08T14:32:02Z"
    },
    {
      "event": "referenced",
      "id": 5861336169,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdXORp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861336169",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "33827163a07cc46a96e50c695c6b93544d6450ba",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/33827163a07cc46a96e50c695c6b93544d6450ba",
      "created_at": "2022-01-08T15:36:26Z"
    },
    {
      "event": "referenced",
      "id": 5861336171,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdXORr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861336171",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4a63d306e4fbeb774c0acc682ee016b58fd6b410",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/4a63d306e4fbeb774c0acc682ee016b58fd6b410",
      "created_at": "2022-01-08T15:36:26Z"
    },
    {
      "event": "referenced",
      "id": 5861336172,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdXORs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861336172",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "90d044f51c8988db2820c12720a87ced8e8d100d",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/90d044f51c8988db2820c12720a87ced8e8d100d",
      "created_at": "2022-01-08T15:36:26Z"
    },
    {
      "event": "referenced",
      "id": 5861646483,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdYaCT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861646483",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2b621b5f92edace3ac68837a8c9eab4bb21df071",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/2b621b5f92edace3ac68837a8c9eab4bb21df071",
      "created_at": "2022-01-08T21:19:06Z"
    },
    {
      "event": "referenced",
      "id": 5861646484,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdYaCU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861646484",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "692ef047f33ba18603560bec5bfc725429da35bf",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/692ef047f33ba18603560bec5bfc725429da35bf",
      "created_at": "2022-01-08T21:19:06Z"
    },
    {
      "event": "referenced",
      "id": 5861646485,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFdYaCV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5861646485",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "ff16f37018e079a1f54b300ca323261eb1ba2442",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/ff16f37018e079a1f54b300ca323261eb1ba2442",
      "created_at": "2022-01-08T21:19:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5952486009,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAFiy7p5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5952486009",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-01-25T19:59:16Z"
    },
    {
      "event": "commented",
      "id": 1021557029,
      "node_id": "IC_kwDOAP4Jqs4847kl",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1021557029",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-01-25T19:59:21Z",
      "updated_at": "2022-01-25T19:59:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-1021557029",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "commented",
      "id": 1021567421,
      "node_id": "IC_kwDOAP4Jqs484-G9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1021567421",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-01-25T20:12:22Z",
      "updated_at": "2022-01-25T20:12:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK f997dadf592131054d1cfca6175730e53dee52a1 (aside from most recent build / CI changes) based on:\r\n\r\n- https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-970737667\r\n- git range-diff 0a40a4861ae654b3685d3d3670d45876f7cc9c48 07a4ef5a08cea9916cf93603670d8ee4d5340540 f997dadf592131054d1cfca6175730e53dee52a1\r\n",
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-1021567421",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "commented",
      "id": 1026206563,
      "node_id": "IC_kwDOAP4Jqs49Kqtj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1026206563",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-01-31T21:03:15Z",
      "updated_at": "2022-01-31T21:03:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "Mental note: simplify this after #1033.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-1026206563",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "referenced",
      "id": 6005174630,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFl77Fm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/6005174630",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "858c4072dbfd93bb3d7c91c399f4f4948e2e8660",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/858c4072dbfd93bb3d7c91c399f4f4948e2e8660",
      "created_at": "2022-02-03T19:30:35Z"
    },
    {
      "event": "referenced",
      "id": 6005174637,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFl77Ft",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/6005174637",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2b49380816d697b56a666f709d286ce16e78c52f",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/2b49380816d697b56a666f709d286ce16e78c52f",
      "created_at": "2022-02-03T19:30:35Z"
    },
    {
      "event": "referenced",
      "id": 6005174642,
      "node_id": "REFE_lADOAP4Jqs48NPwZzwAAAAFl77Fy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/6005174642",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "f8e8a8d1411ceccfaa518e6d90085a697d0fafae",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/f8e8a8d1411ceccfaa518e6d90085a697d0fafae",
      "created_at": "2022-02-03T19:30:35Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGU1YWUxZTBjNGQ5ZmViYzAyYmY4MzQxNjE5MzhmZmNkY2IxZDhkNmY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/e5ae1e0c4d9febc02bf834161938ffcdcb1d8d6f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/e5ae1e0c4d9febc02bf834161938ffcdcb1d8d6f",
      "tree": {
        "sha": "0336acfbffe1a08d22b1f2ff9711b85818defc12",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/0336acfbffe1a08d22b1f2ff9711b85818defc12"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/44c2452fd387f7ca604ab42d73746e7d3a44d8a2",
          "sha": "44c2452fd387f7ca604ab42d73746e7d3a44d8a2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/44c2452fd387f7ca604ab42d73746e7d3a44d8a2"
        }
      ],
      "message": "Native jacobi symbol algorithm\n\nThis introduces variants of the divsteps-based GCD algorithm used for\nmodular inverses to compute Jacobi symbols. Changes compared to\nthe normal vartime divsteps:\n* Only positive matrices are used, guaranteeing that f and g remain\n  positive.\n* An additional jac variable is updated to track sign changes during\n  matrix computation.\n* There is (so far) no proof that this algorithm terminates within\n  reasonable amount of time for every input, but experimentally it\n  appears to almost always need less than 900 iterations. To account\n  for that, only a bounded number of iterations is performed (1500),\n  after which failure is returned. The field logic then falls back to\n  using square roots to determining the result.\n* The algorithm converges to f=g=gcd(f0,g0) rather than g=0. To keep\n  this test simple, the end condition is f=1, which won't be reached\n  if started with g=0. That case is dealt with specially.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-06-28T20:17:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-09-11T14:39:00Z"
      },
      "sha": "e5ae1e0c4d9febc02bf834161938ffcdcb1d8d6f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDdlMWJiZWYzNjQxZmY1YmIwNTkzYTUzZjQ1MjU3N2JmOTZkN2QyZGM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7e1bbef3641ff5bb0593a53f452577bf96d7d2dc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7e1bbef3641ff5bb0593a53f452577bf96d7d2dc",
      "tree": {
        "sha": "bc81f90fbc87daf8b47eabae412738ba4a116245",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/bc81f90fbc87daf8b47eabae412738ba4a116245"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/e5ae1e0c4d9febc02bf834161938ffcdcb1d8d6f",
          "sha": "e5ae1e0c4d9febc02bf834161938ffcdcb1d8d6f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/e5ae1e0c4d9febc02bf834161938ffcdcb1d8d6f"
        }
      ],
      "message": "doc: Describe Jacobi calculation in safegcd_implementation.md",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-06-28T20:17:17Z"
      },
      "author": {
        "name": "Elliott Jin",
        "email": "elliott.jin@gmail.com",
        "date": "2021-11-10T18:37:44Z"
      },
      "sha": "7e1bbef3641ff5bb0593a53f452577bf96d7d2dc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGZjZDRhYmZlZWRhNzNkZDU0Y2FjZjk4MDQ4N2Y0YWMxZDg5OWU3M2M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/fcd4abfeeda73dd54cacf980487f4ac1d899e73c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/fcd4abfeeda73dd54cacf980487f4ac1d899e73c",
      "tree": {
        "sha": "7bb246515978ab2eba1cadbf927cac738f515541",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/7bb246515978ab2eba1cadbf927cac738f515541"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7e1bbef3641ff5bb0593a53f452577bf96d7d2dc",
          "sha": "7e1bbef3641ff5bb0593a53f452577bf96d7d2dc",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7e1bbef3641ff5bb0593a53f452577bf96d7d2dc"
        }
      ],
      "message": "Elligator Squared module\n\nThis adds a module with an implementation of the Elligator Squared\nalgorithm for encoding/decoding public keys in uniformly random\nbyte arrays.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-06-28T20:23:07Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-09-02T23:00:43Z"
      },
      "sha": "fcd4abfeeda73dd54cacf980487f4ac1d899e73c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGQ0Y2JlZGMwMjNhYjkyMTYzMTcyM2EzN2VhODA1MmQ0OGIxYzQ1Mzc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d4cbedc023ab921631723a37ea8052d48b1c4537",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d4cbedc023ab921631723a37ea8052d48b1c4537",
      "tree": {
        "sha": "c3aabb3ec88d162f8224741a4b73be64076ca3db",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/c3aabb3ec88d162f8224741a4b73be64076ca3db"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/fcd4abfeeda73dd54cacf980487f4ac1d899e73c",
          "sha": "fcd4abfeeda73dd54cacf980487f4ac1d899e73c",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/fcd4abfeeda73dd54cacf980487f4ac1d899e73c"
        }
      ],
      "message": "Add ellsq testing to CI",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-06-28T20:24:40Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-09-28T19:09:50Z"
      },
      "sha": "d4cbedc023ab921631723a37ea8052d48b1c4537"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6897101500,
      "node_id": "HRFPE_lADOAP4Jqs48NPwZzwAAAAGbGWq8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/6897101500",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-28T20:28:37Z"
    },
    {
      "event": "commented",
      "id": 1177663651,
      "node_id": "IC_kwDOAP4Jqs5GMbij",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1177663651",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-07T14:01:10Z",
      "updated_at": "2022-07-07T14:01:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "Closing, as Elligator Square seems strictly inferior in performance and complexity to [ElligatorSwift](https://eprint.iacr.org/2022/759).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#issuecomment-1177663651",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/982"
    },
    {
      "event": "closed",
      "id": 6952127830,
      "node_id": "CE_lADOAP4Jqs48NPwZzwAAAAGeYQ1W",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/6952127830",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-07T14:01:10Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/748520983",
      "pull_request_review_id": 804959919,
      "id": 748520983,
      "node_id": "PRRC_kwDOAP4Jqs4snYYX",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_TESTS_H\n+#define SECP256K1_MODULE_ELLSQ_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellsq.h\"\n+\n+struct ellsq_test {\n+    secp256k1_ge point;\n+    int enc_bitmap;\n+    secp256k1_fe encs[4];\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_test ellsq_tests[] = {\n+    {SECP256K1_GE_CONST(0xc27fb7a3, 0x283a7d3e, 0xc9f96421, 0x545ef6f5, 0x8ace7b71, 0x06c8a1b9, 0x07c0ae8a, 0x7598159c, 0xe05a060e, 0x839ef79f, 0xc0c1267c, 0xa17880c9, 0x584cdd34, 0xc05f9695, 0x55482207, 0xe6851f2a), 15, {SECP256K1_FE_CONST(0xc0ad127a, 0xa36824d6, 0x5b1f5be7, 0x4de1aa25, 0xbc4d5cbe, 0xcee15462, 0x0a12682a, 0xfc87df98), SECP256K1_FE_CONST(0xd40fd5bc, 0x51992484, 0x8f13273b, 0x1d857cba, 0x42d45e78, 0x9eaa4e47, 0xf458b83a, 0xbd5f8d1c), SECP256K1_FE_CONST(0xde636141, 0x7deb440b, 0x3a305924, 0x43635cf9, 0xcf42f9b5, 0xf5b891c1, 0x1e119f09, 0x71b570ac), SECP256K1_FE_CONST(0xd55135ce, 0x41bb4d05, 0x5b3757f4, 0xaf1d6537, 0x137376d7, 0x5270caae, 0xda68382d, 0x25d00708)}},\n+    {SECP256K1_GE_CONST(0x3f5ada4e, 0x8f646ec9, 0x10ffc1a2, 0xb74d94bb, 0xb1860631, 0xa3c2a349, 0xeddf55ca, 0xfd49cce9, 0x28ad9d8d, 0x77d9cd87, 0xf80aaa34, 0x8e9ad1b4, 0x40353d7a, 0x6e717714, 0x60425319, 0x38f530c3), 15, {SECP256K1_FE_CONST(0xac42348f, 0x1b356822, 0x5bb7d4c0, 0x0feab37e, 0xa5fb7fbb, 0x0cc3879d, 0xc74e2dda, 0xf9a393bf), SECP256K1_FE_CONST(0xda7a45b2, 0x6c87dcb6, 0x4a934c1d, 0xc841d250, 0xf98af5f0, 0x511be2a3, 0x82d17bab, 0xe1e4a533), SECP256K1_FE_CONST(0xc3d9b9a6, 0x570ca9c8, 0xa640fc75, 0x945850b2, 0xcc86b6d6, 0x399b4496, 0x4288d76d, 0x832a32d7), SECP256K1_FE_CONST(0xbf5ebc2f, 0x4060abe7, 0x884a1fa7, 0xcc0883cb, 0x97535c5a, 0x31dc6df4, 0xc6968e9d, 0x8554f3b1)}},\n+    {SECP256K1_GE_CONST(0xf5f74fab, 0x3ebbbcfd, 0xdcaef6cc, 0xd14eb934, 0xf9435a4e, 0x4a1ed2d8, 0x75352c47, 0x306d6c2f, 0xea6a5b2a, 0xe109897d, 0x046e1504, 0xf7a382d6, 0x1eb49a8a, 0xae8852ef, 0x48e29466, 0x194d9e66), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xe8362df2, 0x38e0405b, 0x49218747, 0x74f9ebca, 0x36dfe21b, 0x1a49ae2d, 0x0fa23fd4, 0x11a262a6), SECP256K1_FE_CONST(0x9e453426, 0xac973155, 0x19d11d63, 0xc3bb27ee, 0x89a7ec85, 0x5661dce4, 0xe428f6cc, 0x0be059cc)}},\n+    {SECP256K1_GE_CONST(0x977694f6, 0x6f0a3005, 0x2c638916, 0x61432fa0, 0x605528a7, 0xad87d829, 0x5c9eb9a3, 0x973c6fed, 0x16515f14, 0x00186fec, 0x67f6314c, 0x8a9e2d43, 0x3d2020e9, 0x38f86465, 0x39f749a1, 0x51a793ed), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x8f091a42, 0xce496be8, 0x877d43fc, 0x2f2b2927, 0x42c9c1fb, 0x0dfe570b, 0x9c9fbd3e, 0x04afa709), SECP256K1_FE_CONST(0xb5930cf1, 0x4db355a5, 0xa92b9f78, 0x9390b59a, 0x013c8e27, 0x7c41ddd6, 0xd8221622, 0x93d39141)}},\n+    {SECP256K1_GE_CONST(0x9c970ce9, 0x39e8a4ec, 0x70237f33, 0xad858370, 0xc9d30e8a, 0xadaac257, 0x546d1e16, 0xf374973b, 0x95755fab, 0x1bcae32e, 0xc811c63f, 0xb1e56da8, 0x97a1e140, 0xb1aae97e, 0x0b6ae6c5, 0x3879f51c), 13, {SECP256K1_FE_CONST(0xa7424f55, 0x60b58ceb, 0xbb9a6ee1, 0x5fc41b18, 0xf282b2cd, 0xd9e2fb4d, 0x02626c1a, 0xc0a89ec4), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xd7016e9b, 0x94db9b4c, 0x5bc61c87, 0xaf3b3c9c, 0x72707e5e, 0x48332958, 0xce5371bf, 0xd501a006), SECP256K1_FE_CONST(0xe95cd3a1, 0x2cff74bd, 0x6761a782, 0x61f73f0d, 0x755a80f6, 0x39ccd117, 0x136f9963, 0xf422b82a)}},\n+    {SECP256K1_GE_CONST(0x48206211, 0x5e6fc771, 0x738b4859, 0x4da66901, 0xa0a8c36e, 0xa61122b7, 0x745cf5fe, 0xec932b64, 0x01c9e1a1, 0x59effb22, 0x4442c868, 0x9119fd26, 0x8cdca070, 0x7edbefb6, 0xea81d5f6, 0x86333768), 13, {SECP256K1_FE_CONST(0xf1047fb9, 0x4cfa6dcd, 0x202e1acc, 0xa85afc88, 0x46381925, 0x7adf32aa, 0x25e19e52, 0xbf3cadd8), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x94dc1b2b, 0x6a24bbdb, 0x36afab1a, 0x6e036e7f, 0xdf1ded22, 0x915bf761, 0x97e5e5a5, 0xc6261582), SECP256K1_FE_CONST(0x8dd664ba, 0x47061bac, 0x0c99d727, 0xac2ade9f, 0xf8d33aff, 0x995a7a28, 0x97f2968c, 0x558ef724)}},\n+    {SECP256K1_GE_CONST(0x47e54d7b, 0x86025d30, 0x248b18e6, 0xc6b2b128, 0x3f8eb11e, 0x60d11cad, 0xf59884ea, 0x56939f5a, 0xb618d932, 0x6110c200, 0xcbed144f, 0xc6376800, 0xd8ba0de1, 0xd87fa02d, 0x17d1d58d, 0x9652c498),  3, {SECP256K1_FE_CONST(0x8797d6a9, 0xe3614b34, 0x80e43cb6, 0x936cd932, 0xbe4eee02, 0x1e47e067, 0x2d1d9f2f, 0xd0148558), SECP256K1_FE_CONST(0xb19c75d0, 0xb4856c81, 0xb467f8f5, 0xb9f8d849, 0x0e5296f0, 0x4c60d639, 0x6f772b7f, 0x427c5d38), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8fa5ffb5, 0x597068f6, 0x06785a63, 0x1f74cd6f, 0x8b16e94b, 0xe6cee831, 0x2970e0ec, 0xa9ecda52, 0x6c4f0efe, 0xf1d0eef2, 0xe3281b13, 0x4f29289f, 0x0a9d7b4d, 0xb3118c5f, 0x1d2d1da4, 0x75569ebf),  3, {SECP256K1_FE_CONST(0xe66995d0, 0x9cfdddda, 0xadf4b4ec, 0xc00270ed, 0xaeaacf01, 0x2db38d37, 0xe4143baf, 0x0ae7dfa3), SECP256K1_FE_CONST(0xfe0d264e, 0x3121942c, 0xd5126e26, 0x0766f36c, 0x3a08a689, 0x4e8ec172, 0xf3fdb252, 0x70def1ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x016a682d, 0x1df4f869, 0xb32c48b0, 0xa9b442a1, 0x493949fb, 0x85d951d1, 0x21c1143b, 0xd3d5c1af, 0x38d33fe5, 0xd3f9b4b9, 0x82e37dff, 0x7561428d, 0x47ef4ddf, 0x654bd959, 0x51b04e90, 0xa3be50e7),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ec42424, 0xb4d2226f, 0x83f94258, 0xc737d0da, 0xf93a4eb1, 0x1d9b9e3f, 0xd500d5b9, 0xc3aa7c71, 0x84975819, 0xb703da77, 0xca98bd3c, 0xd9bbdc7a, 0xf1dbc7b5, 0x85c590eb, 0xcbd417fd, 0x739ad572),  1, {SECP256K1_FE_CONST(0x945faa12, 0x7e8bf378, 0x63581bfb, 0xde084bf7, 0x63caee39, 0x1449c610, 0xc2074f86, 0xff1bf16c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x69ee52b2, 0x88dfb06a, 0x449d3db8, 0x7602e094, 0xb4f131e3, 0xf6a4b249, 0xdc0a76ff, 0xdebe989a, 0x3922f1a4, 0xdd208f94, 0xcbac1c5d, 0x34a9278d, 0x84310781, 0x84ff4430, 0x31a14018, 0x95ffd9e6),  1, {SECP256K1_FE_CONST(0xdc1e4760, 0x15bda784, 0xa1b9527b, 0x0357786a, 0xdf2a8028, 0x03957837, 0xe10cff92, 0x5ef4ca7e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0x3ac01550, 0x68185039, 0x6068aaf0, 0xc3f24144, 0x9a267956, 0x698833d4, 0x80c03dc5, 0x678b67cf),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9ddddd8e, 0xc1814a29, 0x3fcca202, 0xebfbe14e, 0x5d808dda, 0x142eee64, 0xc6108381, 0xe99e5cff, 0xb5072d55, 0x37223f39, 0x3e4176d2, 0xcfd93c86, 0x82ca2c22, 0xcd25ec40, 0x877296bd, 0xbb7c08f6),  3, {SECP256K1_FE_CONST(0xadd34f27, 0xc5f90171, 0x75186c23, 0xd14f6ef2, 0xaa182896, 0x77d5373a, 0xd6c31e9f, 0xf6358ae8), SECP256K1_FE_CONST(0xf5ee8614, 0x1916fe03, 0x945d028b, 0xbc354c4a, 0x09f6d6ab, 0x1468ab9a, 0xd8742075, 0x1543c2a2), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ee7e9a7, 0xfcd56edf, 0xabf3712e, 0x72cc24a3, 0x0a476f5a, 0x97f77825, 0xf0308620, 0x162f31ad, 0x77bfc7de, 0xc2401a39, 0x8c5e8675, 0x417c8a7b, 0x632f5d64, 0x2f1a5059, 0x9a830b8c, 0x7981f636),  3, {SECP256K1_FE_CONST(0xb3a8d9e7, 0x368af258, 0x3785be92, 0x2ad54dfb, 0x47329513, 0x6ade2d18, 0x2f931cd6, 0x54f35d02), SECP256K1_FE_CONST(0xe1d420e5, 0xfab5c26d, 0xf4294b2b, 0x0c19eb9a, 0x188409bf, 0x48a3741f, 0x31f72acc, 0x6ea93418), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9e24d0a5, 0xd5014164, 0x987f86bb, 0x1709305a, 0x6fd352a0, 0xa3478fae, 0x3f85e594, 0x21d72a80, 0x3729c39b, 0xbbb26d97, 0xa4ec6bf7, 0xcb4e6453, 0x058e448e, 0x7530b028, 0xd1ae345e, 0x35608d3c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x15f2f1a4, 0x339f5f2a, 0x313b9501, 0x5cad8124, 0xd054a171, 0xac2f31cf, 0x529dda7c, 0xfb6a38b4, 0xfe1d0fa5, 0x95b4f7d3, 0x63e82c29, 0x0095189f, 0x5f2be99c, 0x880be4fc, 0x9742a31b, 0x40041eda),  1, {SECP256K1_FE_CONST(0xc1c3ed27, 0x17ffabfd, 0x01132f5e, 0x54dd73c3, 0x475297e0, 0xfdbff814, 0xdc9456b8, 0x4a57b698), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd383134d, 0x721cf055, 0x143570e7, 0x82bb323d, 0x5c542a61, 0xe455823e, 0xd60b940f, 0x86826d54, 0x5a88e50b, 0x3f59874e, 0x84dab4a2, 0x07d34623, 0xd836c376, 0xc68dded3, 0xc095a716, 0xf563e4fc),  1, {SECP256K1_FE_CONST(0xe4d2660c, 0x1d50d031, 0x97f5e610, 0x4d9c2066, 0x01f6c791, 0xadb52178, 0xe2bd6c88, 0xe89cf012), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  3, {SECP256K1_FE_CONST(0xd3779b57, 0x3cb17828, 0xac118cff, 0x74412ab5, 0xb84c86f8, 0xa92f48b8, 0xefcbe4c7, 0x0a675631), SECP256K1_FE_CONST(0xea6f729d, 0xdc884123, 0xf0130aa0, 0x339bda36, 0x2166d034, 0xfe50d9d7, 0x53bf0dde, 0x7721fa3f), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x99a70224, 0xc3062c32, 0x6c45d3c6, 0x46a545e9, 0xb152b75b, 0xee868378, 0x07e47951, 0x9e5b600d, 0x95b6675a, 0x10845b66, 0x37ff96e8, 0xe67f2a75, 0xbbf0f764, 0xc56d26c5, 0x4b2db5eb, 0xb026d7de),  3, {SECP256K1_FE_CONST(0xb74a9552, 0xc5b9b6ed, 0x575d380f, 0xec3df8ed, 0xdb524ed1, 0x80b13607, 0x81e2eec6, 0x7ad06c04), SECP256K1_FE_CONST(0xbb702282, 0x4194fbe4, 0x4a74c4f4, 0xabd01ee3, 0xdac8f4cb, 0x5a0e3a67, 0xd2276039, 0xdd4aac1a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb5902433, 0x3110b310, 0x8625f254, 0x47665c1e, 0xbf10c6a6, 0xbbe9f018, 0xc421f4b0, 0xdcb5a993, 0x43bae2cd, 0xaae9c002, 0xe57ac99a, 0x17926e22, 0x76a66728, 0xf92b11bb, 0x7dc953b9, 0xea6d49b7),  3, {SECP256K1_FE_CONST(0xd5a57c1b, 0x71916606, 0xbfb235f0, 0xce8d880d, 0xe9109a01, 0xb86d58c8, 0x2852b211, 0x0e55ee0f), SECP256K1_FE_CONST(0xca6cf74b, 0x128e1d79, 0x75482bfd, 0xc9e81416, 0x71a5c3e7, 0xe2af854b, 0x23707630, 0x97ba917b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb526749e, 0x35fa04ef, 0x5d20b1d6, 0xcda6f57e, 0x2f3c10c9, 0x85098901, 0xc390da79, 0x31769e34, 0x182093b3, 0xce5883a2, 0x7b834af6, 0x18547fd1, 0x6017cee0, 0x4e9398da, 0x6aaaed2b, 0x87ca0e7c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x901c52d6, 0xa39718c7, 0x255e94e3, 0x3189cbeb, 0x41f2fa97, 0x95279076, 0xbecd6678, 0x99684c17, 0xf988a838, 0x156cc39f, 0x2182bbc5, 0xf7e4f707, 0x9cf75bfb, 0x58638cff, 0x5b201fd3, 0xcf499fc0),  1, {SECP256K1_FE_CONST(0xa356db31, 0x44b754a3, 0xdafdf2a9, 0x0767b65a, 0xbaea92ca, 0x56c69c3a, 0x31a4ff5b, 0xd7914d9c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x957d4fd4, 0x4a10f38a, 0x0d0e1e46, 0x2656dd2e, 0x7f2b6b8c, 0x9545ee02, 0x903f28b0, 0x8f9a57e7, 0x3f4bf4de, 0x3731bea3, 0x291627e3, 0x9daa7dac, 0xcdcd4e13, 0xb2418482, 0x488730b7, 0xa7a816b7),  1, {SECP256K1_FE_CONST(0xa761cd3a, 0x58385878, 0x300c6963, 0xe918b545, 0x99eb0254, 0x550f6254, 0xe414628c, 0x2f431bbd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x0a7b6db2, 0x56f01aea, 0x797a0798, 0x5eaf98d6, 0x64486f82, 0x723758bf, 0x1a5f7b00, 0xb74887e1, 0xe07ce7ec, 0x5f24b6da, 0x199329ff, 0x674788c4, 0x1b7312d4, 0xbb63672f, 0x81ebbfd3, 0x6d962235), 15, {SECP256K1_FE_CONST(0x442e15e3, 0xac31958b, 0x7acdb8b9, 0x7977b6d0, 0x533b1ef0, 0x5094f496, 0x126a04d0, 0xc6d6c327), SECP256K1_FE_CONST(0xc565d637, 0x6c8f4fa4, 0xa22ab5d4, 0xe1c87f5d, 0x6f9beb27, 0x7764a77f, 0x8ebe3796, 0xaa82cba5), SECP256K1_FE_CONST(0x2082a3b7, 0x04d3729c, 0x71a73a0c, 0xd745c7ce, 0x7a7c5e26, 0x77c688e2, 0x772806d1, 0xdd1a849f), SECP256K1_FE_CONST(0xc00c8cc3, 0x5ea8122e, 0xf17b0a8e, 0xc69218d1, 0x8cb45a3f, 0x0227a2c5, 0x68fbd9f9, 0xc6d6d141)}},\n+    {SECP256K1_GE_CONST(0x770ed6cb, 0xf6d2156b, 0x362523eb, 0xc2908f68, 0x65ab182c, 0x43468bc8, 0x69d6754e, 0x68dc71a0, 0x2a378713, 0x10223129, 0xbaba56c2, 0x0dc4a1e9, 0x634dba32, 0xa034d21f, 0x3104176b, 0x870c9916), 15, {SECP256K1_FE_CONST(0x092c79ab, 0xbbafd66d, 0x58c56208, 0x7ba5c385, 0x9fed6c1b, 0x5f8005af, 0x0087cedb, 0xec7dc084), SECP256K1_FE_CONST(0x3f5c280a, 0x60802515, 0x16dfd84a, 0x4488df47, 0x96198d5f, 0xbce0be21, 0x1ab0ee7d, 0xa456e73e), SECP256K1_FE_CONST(0x94057b6b, 0xd54b13b2, 0xe2b9d322, 0x687569f5, 0xdd16727d, 0x3d912ba3, 0xeb8aa33d, 0x36c15108), SECP256K1_FE_CONST(0x098360ae, 0xcf93979e, 0x7cd6df39, 0x6e8fe2f3, 0x18fa1da3, 0x9efa707a, 0xeab95cd8, 0xcd5dca2a)}},\n+    {SECP256K1_GE_CONST(0xab01575c, 0x0604c63e, 0xe77d3153, 0x4a5bcfa2, 0x0ce66c9d, 0xf47d6054, 0xb822bfd8, 0x6934f8ec, 0xce488d85, 0xd0875b40, 0x4fb92b6e, 0x8068602a, 0x670ac4f8, 0xd76b78b6, 0xc246b713, 0x595e226b), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4ab21b18, 0x1009aa48, 0xb8ba5eb9, 0xd373919b, 0xcfcb36a6, 0xf34961b2, 0xc859f5a8, 0x6da8ba41), SECP256K1_FE_CONST(0x9a11c401, 0x9a4ba9fc, 0xf4698a71, 0x2d85c8e4, 0x70028e02, 0x545ef049, 0xf9f3083d, 0x187c5b41)}},\n+    {SECP256K1_GE_CONST(0x6084cfdd, 0xf8d9736e, 0xa90100eb, 0xdb43338f, 0x65e2ab43, 0xef35a799, 0x926e6ce3, 0x2a89ae17, 0x753998b5, 0x9eaae7a3, 0xdcab34d9, 0xa15dbc71, 0xe539cdff, 0xdcf05927, 0x0eb27c86, 0xab6b62a4), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x18b1f707, 0x3fca3167, 0x04e1b3b8, 0x8cc8ff5a, 0x702d79bc, 0x756e4dea, 0x2ff948cc, 0xdb43a9f4), SECP256K1_FE_CONST(0xca02e589, 0x89eb16d1, 0x520463d2, 0x435745cf, 0x6e69fa52, 0x6b5c7adc, 0x57cea2b3, 0xf5a6441c)}},\n+    {SECP256K1_GE_CONST(0xc9fbac00, 0x9d8eda5d, 0x25c9aabb, 0x2b6794bc, 0x9a801afd, 0x17adef78, 0x78c65392, 0x04eb0f82, 0x95ed9e51, 0x898b903e, 0xe689e6ed, 0xff2b54bf, 0xed5c2da1, 0x69e2bdd0, 0x415a392e, 0x16b3de2b), 13, {SECP256K1_FE_CONST(0x21a95220, 0x8577e3f0, 0xcc5b4b17, 0xf5e434b2, 0x2bbdbaaa, 0x51cd2659, 0xe37880a6, 0xa25aa7dd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xcfd1ca13, 0x2f8d3eae, 0x73a97895, 0x01d2c82a, 0x6f057566, 0x7949fab9, 0x267bc1e8, 0xef9bf5bd), SECP256K1_FE_CONST(0x9cde02aa, 0x3acd2596, 0xdbea4b82, 0xf9f47ad1, 0x994ad567, 0x3c0d4fb2, 0xe8a3dca5, 0xe8e067fb)}},\n+    {SECP256K1_GE_CONST(0x8dcb38d9, 0x0059d4f1, 0x270455af, 0x6f3dd40e, 0x8d671a34, 0xa1fad81d, 0x2470db8a, 0x13b18f76, 0x603ed5be, 0x7bc3e67f, 0x439067da, 0x29949bcb, 0xd3c96c9f, 0x94da4231, 0x3c9c0feb, 0xe5cdf560), 13, {SECP256K1_FE_CONST(0x3ef4008a, 0x8a190a3f, 0x5c97d211, 0x3bb539e1, 0xf4261a78, 0xf7cd85c4, 0xfd254837, 0xeaacd020), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x0fe7af4f, 0xcab80199, 0x37ee0026, 0x47d55d97, 0x575474b3, 0x4b9cc1bb, 0x133f4261, 0x017124a0), SECP256K1_FE_CONST(0x09dcec3b, 0x93c4ab42, 0x91d01dce, 0xccc19525, 0xc801add3, 0x77170c2c, 0x919f5488, 0xf41d6d3e)}},\n+    {SECP256K1_GE_CONST(0xf69dfe44, 0x890d2b09, 0x4b749a56, 0xf680e851, 0x50c47c4c, 0xd51e7796, 0x3fec4e6a, 0x09dcd0a1, 0xfb5d321c, 0x1e243b63, 0x6dfb71f3, 0xcf0e8a01, 0x2e52b22c, 0x905cec6d, 0x2f6ae32a, 0x6a4eb7be),  3, {SECP256K1_FE_CONST(0xa17fd528, 0x7276cbf6, 0xc168dcde, 0xb32aba14, 0xe1aeae2f, 0xe7f5bea5, 0xa87d384e, 0xe8046aac), SECP256K1_FE_CONST(0x637f176a, 0xf2fe854a, 0x968ab19b, 0xee010554, 0x313e3eff, 0xc6ff8cb4, 0xcb538a6d, 0xbaedd954), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x043a0631, 0x871a3f67, 0xac03c5f8, 0x406b69a0, 0xdc14bd5b, 0x23e55f27, 0xa5d4462b, 0x0f0a2d23, 0x247b9bcc, 0x0019091c, 0x31eb4b03, 0xe731a0b5, 0xa9b33f75, 0xad9e5e63, 0x39286573, 0xa6439d88),  3, {SECP256K1_FE_CONST(0xd65add13, 0xad3044d9, 0x2ebcd0e6, 0xd42853d8, 0xe5733ff6, 0x5297f544, 0x09a3ce89, 0xfdaffbdc), SECP256K1_FE_CONST(0x7281ad3c, 0x85de3870, 0x84f64e14, 0x42b37154, 0xeab39453, 0x8b1c0753, 0x4b303ae7, 0x37f3973e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8855508a, 0xade16ec5, 0x73d21e6a, 0x485dfd0a, 0x7624085c, 0x1a14b5ec, 0xdd6485de, 0x0c6839a4, 0xe50aaeba, 0xa0ceceec, 0xa1bce62e, 0x5f0fac4b, 0xe78ab03a, 0x7b2deaa6, 0xe5c17e88, 0x98e277e9),  1, {SECP256K1_FE_CONST(0x4e96da73, 0xae14fc85, 0x25eccb2d, 0xf4416924, 0x8a7fd269, 0xa065e065, 0x04d315e6, 0x63666b03), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xc66327bc, 0x5b0b8b90, 0x37adfd63, 0xc2a9f192, 0x2ce2144a, 0xa513b390, 0xd48bc387, 0xae3ebff6, 0x17a1ca89, 0x64eb0b41, 0x162894e6, 0x4fb4112b, 0x638f96ec, 0xe0c6f30d, 0xef7616fe, 0x0e78386a),  1, {SECP256K1_FE_CONST(0x56e8e17e, 0xfaf989d6, 0xa7efb81d, 0x5a602393, 0x6814930e, 0xbc3f6fdf, 0x72ebf472, 0x69ba4c9a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0xc53feaaf, 0x97e7afc6, 0x9f97550f, 0x3c0dbebb, 0x65d986a9, 0x9677cc2b, 0x7f3fc239, 0x98749460),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9d709c02, 0x74604cb6, 0x3b531fea, 0x35932e2e, 0xc965f4bf, 0x5913e577, 0xff31080b, 0x67727a2e, 0xf2b0b821, 0xa24081a9, 0xd0ca84d9, 0x303068cf, 0x7ea32788, 0x05926b0a, 0xb90b9af7, 0x498efbd5),  3, {SECP256K1_FE_CONST(0xb06abefa, 0x192a6498, 0xbce368ff, 0xacc843fb, 0xb39f8117, 0xa56a1870, 0xf57197ef, 0xd9312f6d), SECP256K1_FE_CONST(0x1263d142, 0xaac9cfc5, 0x64c56650, 0x0fa4a62f, 0x38e727fb, 0xb4dbeaf2, 0x6fdf7d05, 0xfd022c71), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb4955dcb, 0x4daaa784, 0x9b421c14, 0x53ec8945, 0xd685d554, 0xf41103f8, 0x12cbfb2f, 0x54a4539b, 0x354d18e4, 0xb1cee7a3, 0xf98b0651, 0xf5544091, 0xe8a00656, 0x0c74750d, 0xaadf460e, 0xc3f620ea),  3, {SECP256K1_FE_CONST(0x6281a8a7, 0x0a3b5745, 0xb897ce4f, 0x58305fb0, 0xd6a0f8ab, 0xa6c5ba18, 0xed278ce1, 0x50f7911c), SECP256K1_FE_CONST(0x5f95a708, 0x2d2f6d69, 0xf7ff9b74, 0x2b88063c, 0x39a3003b, 0xb03f333c, 0x7e3d7c5e, 0xd861fb04), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x6ad63dfd, 0xcd231967, 0xff2508f4, 0x75896976, 0xf8728e40, 0xdd7a2acc, 0x6b5ced37, 0xcada8291, 0xf93e5181, 0x8f5329b8, 0xd520a9af, 0xd72938e1, 0x2e3f8be6, 0x421d2bce, 0x89d7b14e, 0x25bf5336),  1, {SECP256K1_FE_CONST(0x0f050318, 0x622f79f1, 0x5a2b23d9, 0xf76329b7, 0x8e195f1a, 0x4651aae0, 0x65d58bcd, 0xdfa4d3b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa91b7f2a, 0xb93de821, 0xabeec175, 0x0258e4d4, 0xf5f09831, 0xb0a11dda, 0x47e89ddf, 0x6944d819, 0x22eb9bf6, 0x4a517df2, 0xc27d1c55, 0x1df07609, 0x166fc995, 0xe2b39fee, 0x0473ea46, 0xed14efc1),  1, {SECP256K1_FE_CONST(0x7a01651a, 0x81a7f09e, 0x2733cf34, 0x9e6472a1, 0x18c16780, 0x6f5c880f, 0x534b89a6, 0x52be06a7), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  3, {SECP256K1_FE_CONST(0x2c8864a8, 0xc34e87d7, 0x53ee7300, 0x8bbed54a, 0x47b37907, 0x56d0b747, 0x10341b37, 0xf598a5fe), SECP256K1_FE_CONST(0x15908d62, 0x2377bedc, 0x0fecf55f, 0xcc6425c9, 0xde992fcb, 0x01af2628, 0xac40f220, 0x88de01f0), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa64de96a, 0x6254cefc, 0xffbeaf89, 0x8f2c228a, 0xf6d405f3, 0xbcc6a4cc, 0xe068312a, 0xf7ccf8e1, 0x8f9b3a1b, 0x2d146ea9, 0x54bfc5e2, 0xcdfe861c, 0xcbed8431, 0xc741c5f9, 0xd32f16a3, 0x073ea496),  3, {SECP256K1_FE_CONST(0x4591d33d, 0x1a133a87, 0x94689b1b, 0x0ca445b7, 0x8ada3bce, 0xc2e812b0, 0x8315e2b1, 0x07940ad4), SECP256K1_FE_CONST(0xa763d217, 0x6027d40e, 0x8a8ff34b, 0xd9c639b7, 0x3e2ea045, 0x92274fdc, 0xfa4051c6, 0x6d93a1b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x49a0dc06, 0x8c3f117a, 0xefdc842d, 0x3d358153, 0xf677f04c, 0x6dabc9c9, 0x1b09d452, 0xfef27b66, 0x7b944da4, 0x8a175dbc, 0x444ead8d, 0xb82eff66, 0xb081a8aa, 0xe6453fed, 0x2bca9720, 0xb44dd6e5),  3, {SECP256K1_FE_CONST(0x7bf1e2b1, 0x720c1c44, 0x0db64687, 0xf16439fa, 0x41b39833, 0x8095f24e, 0xbeec0cfa, 0x88750dc9), SECP256K1_FE_CONST(0xdc97e26d, 0x3137445d, 0x6c1269b6, 0x1a765501, 0x0c19c36a, 0x2e361066, 0xe31e2bb1, 0x0403470b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd09a4047, 0xf158fe52, 0xf96c661d, 0x02c68657, 0xc4c976ea, 0x96ea85ef, 0x46d6985b, 0xd540756b, 0xe793bfaa, 0xe9300f18, 0xe6f9b55a, 0xae263223, 0x68b61d51, 0xae5022ef, 0xe266c72d, 0x574178bc),  1, {SECP256K1_FE_CONST(0x7e6175fd, 0xfbb9fb4f, 0xaf6e2b92, 0x5ef86c4a, 0x444d819a, 0xaa82dbee, 0x545d3d9b, 0x296375be), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x34986625, 0x04b73c7c, 0x8cecb6c3, 0x3cd493bd, 0xfc190e0f, 0x87d913d7, 0xff9ad42e, 0x222bfe95, 0x245b3a61, 0xb8d46997, 0xf14f2fea, 0x28748996, 0x91eb3254, 0x2b9907d6, 0x5eb9d21d, 0x42454021),  1, {SECP256K1_FE_CONST(0x7f556282, 0xc3dd9d26, 0x3390d6bb, 0xddada698, 0xab8fd7c7, 0xd1a06498, 0xf42b3043, 0x7c8361ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}}\n+};\n+\n+struct ellsq_enc_test {\n+    unsigned char ell64[64];\n+    unsigned char pubkey[33];\n+};\n+\n+/* Set of (ell64, point) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_enc_test ellsq_enc_tests[] = {\n+    {{0x54,0xca,0xd2,0x27,0xb2,0xc9,0x8d,0x5f,0x7c,0x78,0x8c,0xfc,0x3d,0xaf,0xd6,0x52,0xf5,0x8f,0x69,0xcf,0xef,0x63,0x2b,0x82,0x2b,0x35,0xd0,0xb0,0xe2,0x4f,0xc0,0x3a,0xd2,0x8c,0xa1,0x4b,0x6f,0x62,0xd4,0x53,0x79,0xc5,0x3f,0x70,0xee,0x40,0x5c,0xa9,0x2c,0xe7,0xb6,0xf9,0x70,0x83,0x13,0x05,0xf2,0x7d,0xc4,0x1e,0xb6,0x9d,0xe0,0x6e}, {0x02,0x11,0x62,0x89,0x03,0x32,0x88,0x91,0xae,0x09,0xd1,0x08,0xd8,0x92,0x43,0xe4,0x7e,0x10,0x9f,0xe7,0xb8,0xbb,0x1e,0x2d,0xf1,0xa3,0xae,0x9b,0x0e,0x78,0x08,0x54,0x9c}},\n+    {{0xfb,0xe6,0xce,0xab,0x4c,0x5f,0xdf,0xa5,0xfb,0xee,0x8f,0x3d,0x09,0xa2,0xf7,0x23,0x53,0xe7,0x4e,0x5a,0x9c,0xd4,0xab,0x8e,0x6a,0x34,0xd4,0x95,0x23,0xa7,0xd1,0xa2,0xc4,0x50,0xb7,0x45,0xda,0xb1,0xaf,0xa9,0x95,0x4b,0x3a,0x35,0x75,0xe4,0xe8,0xe2,0xdb,0x3d,0xa5,0xcd,0x4d,0x56,0x48,0xea,0xd0,0x0a,0x60,0xb4,0xcd,0xfe,0x84,0xb3}, {0x02,0xc0,0x4c,0x84,0x85,0xf9,0x8d,0x56,0x6c,0x79,0xbf,0x33,0xa7,0x0c,0xb2,0x32,0x54,0x9e,0x3d,0xe1,0xc3,0xe3,0x01,0xe3,0x57,0x1c,0x83,0x68,0x97,0xf0,0x7c,0x5d,0x12}},\n+    {{0x71,0x7e,0x63,0xd7,0x71,0xdb,0xda,0x67,0x67,0xd5,0x8f,0x26,0xab,0x5f,0x54,0x9b,0xd2,0xd1,0x8a,0xcf,0x59,0xff,0x50,0x77,0x5f,0x4e,0xb5,0x0a,0xc0,0x17,0x4d,0xf1,0x7d,0xd0,0x34,0xc8,0xed,0x08,0x11,0x61,0x5e,0x3e,0xbb,0x36,0xf8,0xf3,0x3e,0x09,0x23,0x8e,0x4d,0xa8,0xf5,0x01,0x9d,0x37,0x00,0x78,0x4f,0x37,0xc1,0x53,0x53,0x94}, {0x02,0x72,0x81,0x15,0x0c,0xeb,0xc3,0xd7,0xb3,0xbb,0xb9,0x92,0xf5,0x81,0xbb,0xcb,0x9e,0x30,0x4f,0x87,0x44,0xf0,0x19,0x98,0xa7,0x1f,0x5d,0xe1,0x14,0xf8,0x22,0x91,0xc4}},\n+    {{0x01,0xf0,0xbf,0xe4,0xf9,0xbd,0xee,0x52,0x5e,0xb7,0x7c,0x8e,0x35,0x1e,0x1f,0x88,0x3f,0xb9,0xcd,0x37,0x7e,0xf7,0xc5,0xbd,0xde,0xe4,0xf6,0x60,0x64,0x43,0x90,0xf5,0x95,0x3e,0x7d,0x2b,0x6c,0xde,0x36,0x90,0x3e,0xa1,0x34,0x4b,0x0d,0x16,0x33,0x5c,0xc5,0x11,0x5d,0xaa,0x97,0x7c,0x3c,0x2b,0xf9,0x31,0xac,0xde,0x2f,0xf5,0x78,0x9a}, {0x02,0x10,0x44,0x9d,0x7e,0xa0,0x62,0x3e,0x80,0xa5,0x87,0x01,0x9f,0xa5,0x11,0xaf,0xd3,0x94,0xb2,0x55,0xb0,0x8f,0x91,0xb5,0xf7,0x48,0x2a,0xe9,0xd1,0xa1,0xa7,0xfb,0x7c}},\n+    {{0x82,0xd5,0x87,0x1e,0x18,0x37,0x66,0xbd,0x22,0xe1,0x13,0xa8,0x52,0x79,0xaa,0x61,0x7e,0x6b,0x9f,0x73,0x52,0x2c,0xd4,0x6b,0x90,0x59,0xba,0x51,0x97,0xfa,0x56,0x44,0xaf,0x90,0x41,0x89,0x30,0x98,0x7d,0xb7,0xab,0x4a,0x84,0x0c,0x72,0x64,0x1b,0x58,0xb3,0x66,0xe5,0x7c,0x92,0x8c,0x98,0x3a,0x47,0x37,0x82,0x00,0x3c,0x36,0x10,0xab}, {0x03,0xc8,0xb2,0x62,0xf9,0x31,0x69,0x43,0x75,0x51,0x48,0x3b,0x8a,0x61,0x19,0x83,0x82,0xe3,0x11,0x41,0xaf,0x61,0xbf,0x36,0x10,0x0b,0xd0,0x68,0x46,0x5d,0xdd,0xa8,0x40}},\n+    {{0xda,0x82,0x53,0xb4,0x3b,0x5a,0xc2,0x3b,0x42,0x36,0x07,0xe9,0x18,0xab,0x5c,0xaa,0x5d,0x7d,0x34,0x3d,0x77,0xa3,0x99,0x6a,0x42,0xeb,0x33,0x2a,0x3b,0x55,0x1d,0x8c,0xda,0x6c,0xb6,0xf9,0x57,0x4c,0xe3,0x60,0x91,0x2c,0xf4,0x5b,0x90,0x9a,0x96,0x2e,0x4d,0xed,0x63,0xae,0x5a,0xac,0xb0,0xab,0x23,0x29,0x45,0xb1,0x01,0xf7,0x2b,0x62}, {0x02,0xe7,0x28,0x34,0x1d,0xf6,0x93,0x48,0x71,0xb3,0x94,0xbb,0x4f,0xb2,0x8b,0xd8,0xd2,0xdf,0x39,0x92,0x55,0xb0,0x30,0x02,0xed,0x6f,0xc3,0x8f,0x28,0xcf,0xbf,0x53,0x56}},\n+    {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x03,0x1b,0x41,0x2e,0x7a,0x96,0x6d,0x2c,0x24,0x3d,0xbc,0x5b,0x18,0xb7,0xf9,0xba,0xf1,0x85,0xbc,0xfe,0x41,0x38,0x96,0x04,0x79,0x64,0x1a,0xb1,0xe6,0x3b,0x38,0x1e,0x11}},\n+    {{0xdc,0x30,0x98,0xe4,0x00,0x61,0x83,0x30,0xf3,0x8b,0x19,0xe9,0x20,0x0a,0xdf,0x7f,0xfb,0x96,0x84,0x3f,0xa8,0x3c,0x49,0x1c,0xf6,0x7f,0x34,0xa7,0x90,0xbb,0xcf,0xe1,0x23,0xdc,0x30,0x07,0xa4,0xfd,0x13,0x3a,0x39,0x44,0x0b,0x06,0x03,0x1e,0x9e,0x2c,0x38,0x8e,0x41,0x47,0xaf,0x0e,0x82,0xbe,0xda,0x6d,0x56,0x4b,0xf8,0xcc,0x37,0xb1}, {0x02,0x5b,0x74,0x48,0x15,0x22,0xd4,0xc2,0x9f,0x2e,0x6a,0x2f,0x11,0x7f,0x9e,0x39,0xf9,0xab,0x01,0xb1,0xe9,0xf2,0xc3,0x4c,0x68,0xbe,0x8f,0x53,0x1b,0xe0,0x1f,0x6e,0xa7}},\n+    {{0x35,0xd7,0x0a,0x71,0x2c,0xc0,0x85,0x7f,0x8d,0xb1,0xbc,0x55,0x6a,0x6c,0x4e,0xf8,0x66,0x24,0xfd,0x0a,0x47,0x7f,0x96,0x7e,0xed,0xc0,0x32,0xfc,0xda,0xac,0xe7,0x96,0xc6,0x73,0xc5,0x43,0xd0,0x07,0x34,0x32,0x07,0x85,0x5b,0xeb,0xad,0x85,0xe9,0x4b,0xca,0xc7,0x78,0x2b,0x11,0x57,0x9a,0x70,0xdc,0x88,0xe2,0xa4,0x8d,0x9d,0xf2,0xd4}, {0x02,0xdb,0x21,0xb4,0x8f,0xe9,0xf9,0x95,0x08,0x3a,0x1f,0x9c,0x1f,0x3f,0x4b,0x31,0x1d,0x2c,0x43,0xa1,0x28,0xdb,0xb3,0xa4,0xd4,0x78,0x41,0xe4,0xff,0x5d,0xd0,0x2e,0x61}},\n+    {{0x5f,0xb8,0x07,0xce,0x10,0x0c,0x90,0xd2,0x83,0x7c,0xcf,0xc9,0x4d,0x8f,0x8b,0xa5,0xd3,0x5c,0xd3,0xd6,0xfa,0xfc,0xd2,0xf4,0x1f,0x24,0x5b,0x59,0x6e,0x36,0x00,0x57,0xa0,0x47,0xf8,0x31,0xef,0xf3,0x6f,0x2d,0x7c,0x83,0x30,0x36,0xb2,0x70,0x74,0x5a,0x2c,0xa3,0x2c,0x29,0x05,0x03,0x2d,0x0b,0xe0,0xdb,0xa4,0xa5,0x91,0xc9,0xfb,0xd8}, {0x03,0x41,0x58,0x28,0x65,0x43,0x5e,0xe9,0xc8,0xc9,0x27,0xc3,0x49,0xbd,0x3e,0x43,0x7b,0xce,0x2b,0x5c,0xfc,0xd0,0xc4,0x17,0x77,0xc3,0x4c,0x71,0xc6,0x7b,0x14,0x06,0x93}},\n+    {{0x1e,0x76,0x57,0x72,0xbf,0x72,0xde,0xb8,0x81,0x54,0x16,0xbd,0x54,0x45,0xdd,0x75,0x50,0xcd,0x86,0x7a,0xa2,0x5a,0xc6,0x3f,0x6f,0xd9,0xaf,0xd3,0x2f,0x92,0x1c,0xc8,0x8a,0x06,0x1a,0xb5,0xf6,0x98,0x1b,0x55,0x92,0x1b,0x90,0x5b,0x6f,0x4f,0x3d,0xf4,0x82,0x5d,0x79,0x72,0xd6,0x99,0xe3,0xb4,0x21,0x4e,0x40,0x44,0xcf,0xbe,0x65,0x34}, {0x03,0x90,0xd2,0x94,0x30,0x92,0xec,0x7e,0xd8,0xff,0x5a,0xf7,0x04,0x43,0x2d,0x0d,0xbe,0xb0,0x33,0x7c,0xbf,0x58,0x22,0x87,0x18,0x32,0x76,0x38,0x68,0x1f,0x70,0xd7,0xf0}},\n+    {{0x86,0xef,0x92,0xfd,0x28,0x09,0x85,0x4f,0x74,0xf7,0x5a,0xeb,0xbe,0xa1,0x8a,0xee,0xc0,0xee,0xdd,0x4e,0x81,0x92,0xc8,0x8c,0xd7,0xcf,0xf5,0xdf,0xc0,0x8a,0x57,0xdc,0x32,0x73,0xbf,0x6f,0x39,0x2d,0xee,0x48,0x4a,0x72,0x2c,0x3d,0xb0,0x0c,0x0e,0xfb,0x40,0xd5,0x1e,0x8a,0x72,0xfc,0xfb,0x78,0x3f,0xa7,0xeb,0xd4,0x30,0x82,0xdb,0x71}, {0x02,0x31,0x74,0x79,0x29,0x80,0x2d,0x79,0x76,0x02,0x26,0x71,0xb2,0xf7,0x5a,0xc0,0x31,0x18,0x56,0xb3,0x84,0xf4,0xb9,0xa8,0x00,0x0d,0x44,0xa2,0xab,0xc5,0x90,0x3a,0xd4}}\n+};\n+\n+void run_ellsq_tests(void) {\n+    int i = 0;\n+    /* Verify that secp256k1_ellsq_fe_to_ge_var maps everything to curve points for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {\n+        secp256k1_fe t;\n+        secp256k1_ge g;\n+        random_field_element_test(&t);\n+        secp256k1_ellsq_fe_to_ge_var(&g, &t);\n+        CHECK(secp256k1_ge_is_valid_var(&g));",
      "path": "src/modules/ellsq/tests_impl.h",
      "position": 99,
      "original_position": 98,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": null,
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is it worth checking that `t` appears exactly once among preimages of `g`?\r\n\r\n```c\r\n        {\r\n            /* t should appear exactly once in preimages */\r\n            int j, matches = 0;\r\n            secp256k1_fe f;\r\n            for (j = 0; j < 4; j++) {\r\n                if (secp256k1_ellsq_ge_to_fe_var(&f, &g, j) && check_fe_equal(&f, &t)) matches++;\r\n            }\r\n            CHECK(matches == 1);\r\n        }\r\n```",
      "created_at": "2021-11-12T19:00:29Z",
      "updated_at": "2021-11-12T20:07:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r748520983",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/748520983"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 99,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/748522328",
      "pull_request_review_id": 804959919,
      "id": 748522328,
      "node_id": "PRRC_kwDOAP4Jqs4snYtY",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_TESTS_H\n+#define SECP256K1_MODULE_ELLSQ_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellsq.h\"\n+\n+struct ellsq_test {\n+    secp256k1_ge point;\n+    int enc_bitmap;\n+    secp256k1_fe encs[4];\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_test ellsq_tests[] = {\n+    {SECP256K1_GE_CONST(0xc27fb7a3, 0x283a7d3e, 0xc9f96421, 0x545ef6f5, 0x8ace7b71, 0x06c8a1b9, 0x07c0ae8a, 0x7598159c, 0xe05a060e, 0x839ef79f, 0xc0c1267c, 0xa17880c9, 0x584cdd34, 0xc05f9695, 0x55482207, 0xe6851f2a), 15, {SECP256K1_FE_CONST(0xc0ad127a, 0xa36824d6, 0x5b1f5be7, 0x4de1aa25, 0xbc4d5cbe, 0xcee15462, 0x0a12682a, 0xfc87df98), SECP256K1_FE_CONST(0xd40fd5bc, 0x51992484, 0x8f13273b, 0x1d857cba, 0x42d45e78, 0x9eaa4e47, 0xf458b83a, 0xbd5f8d1c), SECP256K1_FE_CONST(0xde636141, 0x7deb440b, 0x3a305924, 0x43635cf9, 0xcf42f9b5, 0xf5b891c1, 0x1e119f09, 0x71b570ac), SECP256K1_FE_CONST(0xd55135ce, 0x41bb4d05, 0x5b3757f4, 0xaf1d6537, 0x137376d7, 0x5270caae, 0xda68382d, 0x25d00708)}},\n+    {SECP256K1_GE_CONST(0x3f5ada4e, 0x8f646ec9, 0x10ffc1a2, 0xb74d94bb, 0xb1860631, 0xa3c2a349, 0xeddf55ca, 0xfd49cce9, 0x28ad9d8d, 0x77d9cd87, 0xf80aaa34, 0x8e9ad1b4, 0x40353d7a, 0x6e717714, 0x60425319, 0x38f530c3), 15, {SECP256K1_FE_CONST(0xac42348f, 0x1b356822, 0x5bb7d4c0, 0x0feab37e, 0xa5fb7fbb, 0x0cc3879d, 0xc74e2dda, 0xf9a393bf), SECP256K1_FE_CONST(0xda7a45b2, 0x6c87dcb6, 0x4a934c1d, 0xc841d250, 0xf98af5f0, 0x511be2a3, 0x82d17bab, 0xe1e4a533), SECP256K1_FE_CONST(0xc3d9b9a6, 0x570ca9c8, 0xa640fc75, 0x945850b2, 0xcc86b6d6, 0x399b4496, 0x4288d76d, 0x832a32d7), SECP256K1_FE_CONST(0xbf5ebc2f, 0x4060abe7, 0x884a1fa7, 0xcc0883cb, 0x97535c5a, 0x31dc6df4, 0xc6968e9d, 0x8554f3b1)}},\n+    {SECP256K1_GE_CONST(0xf5f74fab, 0x3ebbbcfd, 0xdcaef6cc, 0xd14eb934, 0xf9435a4e, 0x4a1ed2d8, 0x75352c47, 0x306d6c2f, 0xea6a5b2a, 0xe109897d, 0x046e1504, 0xf7a382d6, 0x1eb49a8a, 0xae8852ef, 0x48e29466, 0x194d9e66), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xe8362df2, 0x38e0405b, 0x49218747, 0x74f9ebca, 0x36dfe21b, 0x1a49ae2d, 0x0fa23fd4, 0x11a262a6), SECP256K1_FE_CONST(0x9e453426, 0xac973155, 0x19d11d63, 0xc3bb27ee, 0x89a7ec85, 0x5661dce4, 0xe428f6cc, 0x0be059cc)}},\n+    {SECP256K1_GE_CONST(0x977694f6, 0x6f0a3005, 0x2c638916, 0x61432fa0, 0x605528a7, 0xad87d829, 0x5c9eb9a3, 0x973c6fed, 0x16515f14, 0x00186fec, 0x67f6314c, 0x8a9e2d43, 0x3d2020e9, 0x38f86465, 0x39f749a1, 0x51a793ed), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x8f091a42, 0xce496be8, 0x877d43fc, 0x2f2b2927, 0x42c9c1fb, 0x0dfe570b, 0x9c9fbd3e, 0x04afa709), SECP256K1_FE_CONST(0xb5930cf1, 0x4db355a5, 0xa92b9f78, 0x9390b59a, 0x013c8e27, 0x7c41ddd6, 0xd8221622, 0x93d39141)}},\n+    {SECP256K1_GE_CONST(0x9c970ce9, 0x39e8a4ec, 0x70237f33, 0xad858370, 0xc9d30e8a, 0xadaac257, 0x546d1e16, 0xf374973b, 0x95755fab, 0x1bcae32e, 0xc811c63f, 0xb1e56da8, 0x97a1e140, 0xb1aae97e, 0x0b6ae6c5, 0x3879f51c), 13, {SECP256K1_FE_CONST(0xa7424f55, 0x60b58ceb, 0xbb9a6ee1, 0x5fc41b18, 0xf282b2cd, 0xd9e2fb4d, 0x02626c1a, 0xc0a89ec4), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xd7016e9b, 0x94db9b4c, 0x5bc61c87, 0xaf3b3c9c, 0x72707e5e, 0x48332958, 0xce5371bf, 0xd501a006), SECP256K1_FE_CONST(0xe95cd3a1, 0x2cff74bd, 0x6761a782, 0x61f73f0d, 0x755a80f6, 0x39ccd117, 0x136f9963, 0xf422b82a)}},\n+    {SECP256K1_GE_CONST(0x48206211, 0x5e6fc771, 0x738b4859, 0x4da66901, 0xa0a8c36e, 0xa61122b7, 0x745cf5fe, 0xec932b64, 0x01c9e1a1, 0x59effb22, 0x4442c868, 0x9119fd26, 0x8cdca070, 0x7edbefb6, 0xea81d5f6, 0x86333768), 13, {SECP256K1_FE_CONST(0xf1047fb9, 0x4cfa6dcd, 0x202e1acc, 0xa85afc88, 0x46381925, 0x7adf32aa, 0x25e19e52, 0xbf3cadd8), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x94dc1b2b, 0x6a24bbdb, 0x36afab1a, 0x6e036e7f, 0xdf1ded22, 0x915bf761, 0x97e5e5a5, 0xc6261582), SECP256K1_FE_CONST(0x8dd664ba, 0x47061bac, 0x0c99d727, 0xac2ade9f, 0xf8d33aff, 0x995a7a28, 0x97f2968c, 0x558ef724)}},\n+    {SECP256K1_GE_CONST(0x47e54d7b, 0x86025d30, 0x248b18e6, 0xc6b2b128, 0x3f8eb11e, 0x60d11cad, 0xf59884ea, 0x56939f5a, 0xb618d932, 0x6110c200, 0xcbed144f, 0xc6376800, 0xd8ba0de1, 0xd87fa02d, 0x17d1d58d, 0x9652c498),  3, {SECP256K1_FE_CONST(0x8797d6a9, 0xe3614b34, 0x80e43cb6, 0x936cd932, 0xbe4eee02, 0x1e47e067, 0x2d1d9f2f, 0xd0148558), SECP256K1_FE_CONST(0xb19c75d0, 0xb4856c81, 0xb467f8f5, 0xb9f8d849, 0x0e5296f0, 0x4c60d639, 0x6f772b7f, 0x427c5d38), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8fa5ffb5, 0x597068f6, 0x06785a63, 0x1f74cd6f, 0x8b16e94b, 0xe6cee831, 0x2970e0ec, 0xa9ecda52, 0x6c4f0efe, 0xf1d0eef2, 0xe3281b13, 0x4f29289f, 0x0a9d7b4d, 0xb3118c5f, 0x1d2d1da4, 0x75569ebf),  3, {SECP256K1_FE_CONST(0xe66995d0, 0x9cfdddda, 0xadf4b4ec, 0xc00270ed, 0xaeaacf01, 0x2db38d37, 0xe4143baf, 0x0ae7dfa3), SECP256K1_FE_CONST(0xfe0d264e, 0x3121942c, 0xd5126e26, 0x0766f36c, 0x3a08a689, 0x4e8ec172, 0xf3fdb252, 0x70def1ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x016a682d, 0x1df4f869, 0xb32c48b0, 0xa9b442a1, 0x493949fb, 0x85d951d1, 0x21c1143b, 0xd3d5c1af, 0x38d33fe5, 0xd3f9b4b9, 0x82e37dff, 0x7561428d, 0x47ef4ddf, 0x654bd959, 0x51b04e90, 0xa3be50e7),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ec42424, 0xb4d2226f, 0x83f94258, 0xc737d0da, 0xf93a4eb1, 0x1d9b9e3f, 0xd500d5b9, 0xc3aa7c71, 0x84975819, 0xb703da77, 0xca98bd3c, 0xd9bbdc7a, 0xf1dbc7b5, 0x85c590eb, 0xcbd417fd, 0x739ad572),  1, {SECP256K1_FE_CONST(0x945faa12, 0x7e8bf378, 0x63581bfb, 0xde084bf7, 0x63caee39, 0x1449c610, 0xc2074f86, 0xff1bf16c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x69ee52b2, 0x88dfb06a, 0x449d3db8, 0x7602e094, 0xb4f131e3, 0xf6a4b249, 0xdc0a76ff, 0xdebe989a, 0x3922f1a4, 0xdd208f94, 0xcbac1c5d, 0x34a9278d, 0x84310781, 0x84ff4430, 0x31a14018, 0x95ffd9e6),  1, {SECP256K1_FE_CONST(0xdc1e4760, 0x15bda784, 0xa1b9527b, 0x0357786a, 0xdf2a8028, 0x03957837, 0xe10cff92, 0x5ef4ca7e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0x3ac01550, 0x68185039, 0x6068aaf0, 0xc3f24144, 0x9a267956, 0x698833d4, 0x80c03dc5, 0x678b67cf),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9ddddd8e, 0xc1814a29, 0x3fcca202, 0xebfbe14e, 0x5d808dda, 0x142eee64, 0xc6108381, 0xe99e5cff, 0xb5072d55, 0x37223f39, 0x3e4176d2, 0xcfd93c86, 0x82ca2c22, 0xcd25ec40, 0x877296bd, 0xbb7c08f6),  3, {SECP256K1_FE_CONST(0xadd34f27, 0xc5f90171, 0x75186c23, 0xd14f6ef2, 0xaa182896, 0x77d5373a, 0xd6c31e9f, 0xf6358ae8), SECP256K1_FE_CONST(0xf5ee8614, 0x1916fe03, 0x945d028b, 0xbc354c4a, 0x09f6d6ab, 0x1468ab9a, 0xd8742075, 0x1543c2a2), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ee7e9a7, 0xfcd56edf, 0xabf3712e, 0x72cc24a3, 0x0a476f5a, 0x97f77825, 0xf0308620, 0x162f31ad, 0x77bfc7de, 0xc2401a39, 0x8c5e8675, 0x417c8a7b, 0x632f5d64, 0x2f1a5059, 0x9a830b8c, 0x7981f636),  3, {SECP256K1_FE_CONST(0xb3a8d9e7, 0x368af258, 0x3785be92, 0x2ad54dfb, 0x47329513, 0x6ade2d18, 0x2f931cd6, 0x54f35d02), SECP256K1_FE_CONST(0xe1d420e5, 0xfab5c26d, 0xf4294b2b, 0x0c19eb9a, 0x188409bf, 0x48a3741f, 0x31f72acc, 0x6ea93418), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9e24d0a5, 0xd5014164, 0x987f86bb, 0x1709305a, 0x6fd352a0, 0xa3478fae, 0x3f85e594, 0x21d72a80, 0x3729c39b, 0xbbb26d97, 0xa4ec6bf7, 0xcb4e6453, 0x058e448e, 0x7530b028, 0xd1ae345e, 0x35608d3c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x15f2f1a4, 0x339f5f2a, 0x313b9501, 0x5cad8124, 0xd054a171, 0xac2f31cf, 0x529dda7c, 0xfb6a38b4, 0xfe1d0fa5, 0x95b4f7d3, 0x63e82c29, 0x0095189f, 0x5f2be99c, 0x880be4fc, 0x9742a31b, 0x40041eda),  1, {SECP256K1_FE_CONST(0xc1c3ed27, 0x17ffabfd, 0x01132f5e, 0x54dd73c3, 0x475297e0, 0xfdbff814, 0xdc9456b8, 0x4a57b698), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd383134d, 0x721cf055, 0x143570e7, 0x82bb323d, 0x5c542a61, 0xe455823e, 0xd60b940f, 0x86826d54, 0x5a88e50b, 0x3f59874e, 0x84dab4a2, 0x07d34623, 0xd836c376, 0xc68dded3, 0xc095a716, 0xf563e4fc),  1, {SECP256K1_FE_CONST(0xe4d2660c, 0x1d50d031, 0x97f5e610, 0x4d9c2066, 0x01f6c791, 0xadb52178, 0xe2bd6c88, 0xe89cf012), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  3, {SECP256K1_FE_CONST(0xd3779b57, 0x3cb17828, 0xac118cff, 0x74412ab5, 0xb84c86f8, 0xa92f48b8, 0xefcbe4c7, 0x0a675631), SECP256K1_FE_CONST(0xea6f729d, 0xdc884123, 0xf0130aa0, 0x339bda36, 0x2166d034, 0xfe50d9d7, 0x53bf0dde, 0x7721fa3f), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x99a70224, 0xc3062c32, 0x6c45d3c6, 0x46a545e9, 0xb152b75b, 0xee868378, 0x07e47951, 0x9e5b600d, 0x95b6675a, 0x10845b66, 0x37ff96e8, 0xe67f2a75, 0xbbf0f764, 0xc56d26c5, 0x4b2db5eb, 0xb026d7de),  3, {SECP256K1_FE_CONST(0xb74a9552, 0xc5b9b6ed, 0x575d380f, 0xec3df8ed, 0xdb524ed1, 0x80b13607, 0x81e2eec6, 0x7ad06c04), SECP256K1_FE_CONST(0xbb702282, 0x4194fbe4, 0x4a74c4f4, 0xabd01ee3, 0xdac8f4cb, 0x5a0e3a67, 0xd2276039, 0xdd4aac1a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb5902433, 0x3110b310, 0x8625f254, 0x47665c1e, 0xbf10c6a6, 0xbbe9f018, 0xc421f4b0, 0xdcb5a993, 0x43bae2cd, 0xaae9c002, 0xe57ac99a, 0x17926e22, 0x76a66728, 0xf92b11bb, 0x7dc953b9, 0xea6d49b7),  3, {SECP256K1_FE_CONST(0xd5a57c1b, 0x71916606, 0xbfb235f0, 0xce8d880d, 0xe9109a01, 0xb86d58c8, 0x2852b211, 0x0e55ee0f), SECP256K1_FE_CONST(0xca6cf74b, 0x128e1d79, 0x75482bfd, 0xc9e81416, 0x71a5c3e7, 0xe2af854b, 0x23707630, 0x97ba917b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb526749e, 0x35fa04ef, 0x5d20b1d6, 0xcda6f57e, 0x2f3c10c9, 0x85098901, 0xc390da79, 0x31769e34, 0x182093b3, 0xce5883a2, 0x7b834af6, 0x18547fd1, 0x6017cee0, 0x4e9398da, 0x6aaaed2b, 0x87ca0e7c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x901c52d6, 0xa39718c7, 0x255e94e3, 0x3189cbeb, 0x41f2fa97, 0x95279076, 0xbecd6678, 0x99684c17, 0xf988a838, 0x156cc39f, 0x2182bbc5, 0xf7e4f707, 0x9cf75bfb, 0x58638cff, 0x5b201fd3, 0xcf499fc0),  1, {SECP256K1_FE_CONST(0xa356db31, 0x44b754a3, 0xdafdf2a9, 0x0767b65a, 0xbaea92ca, 0x56c69c3a, 0x31a4ff5b, 0xd7914d9c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x957d4fd4, 0x4a10f38a, 0x0d0e1e46, 0x2656dd2e, 0x7f2b6b8c, 0x9545ee02, 0x903f28b0, 0x8f9a57e7, 0x3f4bf4de, 0x3731bea3, 0x291627e3, 0x9daa7dac, 0xcdcd4e13, 0xb2418482, 0x488730b7, 0xa7a816b7),  1, {SECP256K1_FE_CONST(0xa761cd3a, 0x58385878, 0x300c6963, 0xe918b545, 0x99eb0254, 0x550f6254, 0xe414628c, 0x2f431bbd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x0a7b6db2, 0x56f01aea, 0x797a0798, 0x5eaf98d6, 0x64486f82, 0x723758bf, 0x1a5f7b00, 0xb74887e1, 0xe07ce7ec, 0x5f24b6da, 0x199329ff, 0x674788c4, 0x1b7312d4, 0xbb63672f, 0x81ebbfd3, 0x6d962235), 15, {SECP256K1_FE_CONST(0x442e15e3, 0xac31958b, 0x7acdb8b9, 0x7977b6d0, 0x533b1ef0, 0x5094f496, 0x126a04d0, 0xc6d6c327), SECP256K1_FE_CONST(0xc565d637, 0x6c8f4fa4, 0xa22ab5d4, 0xe1c87f5d, 0x6f9beb27, 0x7764a77f, 0x8ebe3796, 0xaa82cba5), SECP256K1_FE_CONST(0x2082a3b7, 0x04d3729c, 0x71a73a0c, 0xd745c7ce, 0x7a7c5e26, 0x77c688e2, 0x772806d1, 0xdd1a849f), SECP256K1_FE_CONST(0xc00c8cc3, 0x5ea8122e, 0xf17b0a8e, 0xc69218d1, 0x8cb45a3f, 0x0227a2c5, 0x68fbd9f9, 0xc6d6d141)}},\n+    {SECP256K1_GE_CONST(0x770ed6cb, 0xf6d2156b, 0x362523eb, 0xc2908f68, 0x65ab182c, 0x43468bc8, 0x69d6754e, 0x68dc71a0, 0x2a378713, 0x10223129, 0xbaba56c2, 0x0dc4a1e9, 0x634dba32, 0xa034d21f, 0x3104176b, 0x870c9916), 15, {SECP256K1_FE_CONST(0x092c79ab, 0xbbafd66d, 0x58c56208, 0x7ba5c385, 0x9fed6c1b, 0x5f8005af, 0x0087cedb, 0xec7dc084), SECP256K1_FE_CONST(0x3f5c280a, 0x60802515, 0x16dfd84a, 0x4488df47, 0x96198d5f, 0xbce0be21, 0x1ab0ee7d, 0xa456e73e), SECP256K1_FE_CONST(0x94057b6b, 0xd54b13b2, 0xe2b9d322, 0x687569f5, 0xdd16727d, 0x3d912ba3, 0xeb8aa33d, 0x36c15108), SECP256K1_FE_CONST(0x098360ae, 0xcf93979e, 0x7cd6df39, 0x6e8fe2f3, 0x18fa1da3, 0x9efa707a, 0xeab95cd8, 0xcd5dca2a)}},\n+    {SECP256K1_GE_CONST(0xab01575c, 0x0604c63e, 0xe77d3153, 0x4a5bcfa2, 0x0ce66c9d, 0xf47d6054, 0xb822bfd8, 0x6934f8ec, 0xce488d85, 0xd0875b40, 0x4fb92b6e, 0x8068602a, 0x670ac4f8, 0xd76b78b6, 0xc246b713, 0x595e226b), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4ab21b18, 0x1009aa48, 0xb8ba5eb9, 0xd373919b, 0xcfcb36a6, 0xf34961b2, 0xc859f5a8, 0x6da8ba41), SECP256K1_FE_CONST(0x9a11c401, 0x9a4ba9fc, 0xf4698a71, 0x2d85c8e4, 0x70028e02, 0x545ef049, 0xf9f3083d, 0x187c5b41)}},\n+    {SECP256K1_GE_CONST(0x6084cfdd, 0xf8d9736e, 0xa90100eb, 0xdb43338f, 0x65e2ab43, 0xef35a799, 0x926e6ce3, 0x2a89ae17, 0x753998b5, 0x9eaae7a3, 0xdcab34d9, 0xa15dbc71, 0xe539cdff, 0xdcf05927, 0x0eb27c86, 0xab6b62a4), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x18b1f707, 0x3fca3167, 0x04e1b3b8, 0x8cc8ff5a, 0x702d79bc, 0x756e4dea, 0x2ff948cc, 0xdb43a9f4), SECP256K1_FE_CONST(0xca02e589, 0x89eb16d1, 0x520463d2, 0x435745cf, 0x6e69fa52, 0x6b5c7adc, 0x57cea2b3, 0xf5a6441c)}},\n+    {SECP256K1_GE_CONST(0xc9fbac00, 0x9d8eda5d, 0x25c9aabb, 0x2b6794bc, 0x9a801afd, 0x17adef78, 0x78c65392, 0x04eb0f82, 0x95ed9e51, 0x898b903e, 0xe689e6ed, 0xff2b54bf, 0xed5c2da1, 0x69e2bdd0, 0x415a392e, 0x16b3de2b), 13, {SECP256K1_FE_CONST(0x21a95220, 0x8577e3f0, 0xcc5b4b17, 0xf5e434b2, 0x2bbdbaaa, 0x51cd2659, 0xe37880a6, 0xa25aa7dd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xcfd1ca13, 0x2f8d3eae, 0x73a97895, 0x01d2c82a, 0x6f057566, 0x7949fab9, 0x267bc1e8, 0xef9bf5bd), SECP256K1_FE_CONST(0x9cde02aa, 0x3acd2596, 0xdbea4b82, 0xf9f47ad1, 0x994ad567, 0x3c0d4fb2, 0xe8a3dca5, 0xe8e067fb)}},\n+    {SECP256K1_GE_CONST(0x8dcb38d9, 0x0059d4f1, 0x270455af, 0x6f3dd40e, 0x8d671a34, 0xa1fad81d, 0x2470db8a, 0x13b18f76, 0x603ed5be, 0x7bc3e67f, 0x439067da, 0x29949bcb, 0xd3c96c9f, 0x94da4231, 0x3c9c0feb, 0xe5cdf560), 13, {SECP256K1_FE_CONST(0x3ef4008a, 0x8a190a3f, 0x5c97d211, 0x3bb539e1, 0xf4261a78, 0xf7cd85c4, 0xfd254837, 0xeaacd020), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x0fe7af4f, 0xcab80199, 0x37ee0026, 0x47d55d97, 0x575474b3, 0x4b9cc1bb, 0x133f4261, 0x017124a0), SECP256K1_FE_CONST(0x09dcec3b, 0x93c4ab42, 0x91d01dce, 0xccc19525, 0xc801add3, 0x77170c2c, 0x919f5488, 0xf41d6d3e)}},\n+    {SECP256K1_GE_CONST(0xf69dfe44, 0x890d2b09, 0x4b749a56, 0xf680e851, 0x50c47c4c, 0xd51e7796, 0x3fec4e6a, 0x09dcd0a1, 0xfb5d321c, 0x1e243b63, 0x6dfb71f3, 0xcf0e8a01, 0x2e52b22c, 0x905cec6d, 0x2f6ae32a, 0x6a4eb7be),  3, {SECP256K1_FE_CONST(0xa17fd528, 0x7276cbf6, 0xc168dcde, 0xb32aba14, 0xe1aeae2f, 0xe7f5bea5, 0xa87d384e, 0xe8046aac), SECP256K1_FE_CONST(0x637f176a, 0xf2fe854a, 0x968ab19b, 0xee010554, 0x313e3eff, 0xc6ff8cb4, 0xcb538a6d, 0xbaedd954), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x043a0631, 0x871a3f67, 0xac03c5f8, 0x406b69a0, 0xdc14bd5b, 0x23e55f27, 0xa5d4462b, 0x0f0a2d23, 0x247b9bcc, 0x0019091c, 0x31eb4b03, 0xe731a0b5, 0xa9b33f75, 0xad9e5e63, 0x39286573, 0xa6439d88),  3, {SECP256K1_FE_CONST(0xd65add13, 0xad3044d9, 0x2ebcd0e6, 0xd42853d8, 0xe5733ff6, 0x5297f544, 0x09a3ce89, 0xfdaffbdc), SECP256K1_FE_CONST(0x7281ad3c, 0x85de3870, 0x84f64e14, 0x42b37154, 0xeab39453, 0x8b1c0753, 0x4b303ae7, 0x37f3973e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8855508a, 0xade16ec5, 0x73d21e6a, 0x485dfd0a, 0x7624085c, 0x1a14b5ec, 0xdd6485de, 0x0c6839a4, 0xe50aaeba, 0xa0ceceec, 0xa1bce62e, 0x5f0fac4b, 0xe78ab03a, 0x7b2deaa6, 0xe5c17e88, 0x98e277e9),  1, {SECP256K1_FE_CONST(0x4e96da73, 0xae14fc85, 0x25eccb2d, 0xf4416924, 0x8a7fd269, 0xa065e065, 0x04d315e6, 0x63666b03), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xc66327bc, 0x5b0b8b90, 0x37adfd63, 0xc2a9f192, 0x2ce2144a, 0xa513b390, 0xd48bc387, 0xae3ebff6, 0x17a1ca89, 0x64eb0b41, 0x162894e6, 0x4fb4112b, 0x638f96ec, 0xe0c6f30d, 0xef7616fe, 0x0e78386a),  1, {SECP256K1_FE_CONST(0x56e8e17e, 0xfaf989d6, 0xa7efb81d, 0x5a602393, 0x6814930e, 0xbc3f6fdf, 0x72ebf472, 0x69ba4c9a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0xc53feaaf, 0x97e7afc6, 0x9f97550f, 0x3c0dbebb, 0x65d986a9, 0x9677cc2b, 0x7f3fc239, 0x98749460),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9d709c02, 0x74604cb6, 0x3b531fea, 0x35932e2e, 0xc965f4bf, 0x5913e577, 0xff31080b, 0x67727a2e, 0xf2b0b821, 0xa24081a9, 0xd0ca84d9, 0x303068cf, 0x7ea32788, 0x05926b0a, 0xb90b9af7, 0x498efbd5),  3, {SECP256K1_FE_CONST(0xb06abefa, 0x192a6498, 0xbce368ff, 0xacc843fb, 0xb39f8117, 0xa56a1870, 0xf57197ef, 0xd9312f6d), SECP256K1_FE_CONST(0x1263d142, 0xaac9cfc5, 0x64c56650, 0x0fa4a62f, 0x38e727fb, 0xb4dbeaf2, 0x6fdf7d05, 0xfd022c71), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb4955dcb, 0x4daaa784, 0x9b421c14, 0x53ec8945, 0xd685d554, 0xf41103f8, 0x12cbfb2f, 0x54a4539b, 0x354d18e4, 0xb1cee7a3, 0xf98b0651, 0xf5544091, 0xe8a00656, 0x0c74750d, 0xaadf460e, 0xc3f620ea),  3, {SECP256K1_FE_CONST(0x6281a8a7, 0x0a3b5745, 0xb897ce4f, 0x58305fb0, 0xd6a0f8ab, 0xa6c5ba18, 0xed278ce1, 0x50f7911c), SECP256K1_FE_CONST(0x5f95a708, 0x2d2f6d69, 0xf7ff9b74, 0x2b88063c, 0x39a3003b, 0xb03f333c, 0x7e3d7c5e, 0xd861fb04), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x6ad63dfd, 0xcd231967, 0xff2508f4, 0x75896976, 0xf8728e40, 0xdd7a2acc, 0x6b5ced37, 0xcada8291, 0xf93e5181, 0x8f5329b8, 0xd520a9af, 0xd72938e1, 0x2e3f8be6, 0x421d2bce, 0x89d7b14e, 0x25bf5336),  1, {SECP256K1_FE_CONST(0x0f050318, 0x622f79f1, 0x5a2b23d9, 0xf76329b7, 0x8e195f1a, 0x4651aae0, 0x65d58bcd, 0xdfa4d3b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa91b7f2a, 0xb93de821, 0xabeec175, 0x0258e4d4, 0xf5f09831, 0xb0a11dda, 0x47e89ddf, 0x6944d819, 0x22eb9bf6, 0x4a517df2, 0xc27d1c55, 0x1df07609, 0x166fc995, 0xe2b39fee, 0x0473ea46, 0xed14efc1),  1, {SECP256K1_FE_CONST(0x7a01651a, 0x81a7f09e, 0x2733cf34, 0x9e6472a1, 0x18c16780, 0x6f5c880f, 0x534b89a6, 0x52be06a7), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  3, {SECP256K1_FE_CONST(0x2c8864a8, 0xc34e87d7, 0x53ee7300, 0x8bbed54a, 0x47b37907, 0x56d0b747, 0x10341b37, 0xf598a5fe), SECP256K1_FE_CONST(0x15908d62, 0x2377bedc, 0x0fecf55f, 0xcc6425c9, 0xde992fcb, 0x01af2628, 0xac40f220, 0x88de01f0), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa64de96a, 0x6254cefc, 0xffbeaf89, 0x8f2c228a, 0xf6d405f3, 0xbcc6a4cc, 0xe068312a, 0xf7ccf8e1, 0x8f9b3a1b, 0x2d146ea9, 0x54bfc5e2, 0xcdfe861c, 0xcbed8431, 0xc741c5f9, 0xd32f16a3, 0x073ea496),  3, {SECP256K1_FE_CONST(0x4591d33d, 0x1a133a87, 0x94689b1b, 0x0ca445b7, 0x8ada3bce, 0xc2e812b0, 0x8315e2b1, 0x07940ad4), SECP256K1_FE_CONST(0xa763d217, 0x6027d40e, 0x8a8ff34b, 0xd9c639b7, 0x3e2ea045, 0x92274fdc, 0xfa4051c6, 0x6d93a1b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x49a0dc06, 0x8c3f117a, 0xefdc842d, 0x3d358153, 0xf677f04c, 0x6dabc9c9, 0x1b09d452, 0xfef27b66, 0x7b944da4, 0x8a175dbc, 0x444ead8d, 0xb82eff66, 0xb081a8aa, 0xe6453fed, 0x2bca9720, 0xb44dd6e5),  3, {SECP256K1_FE_CONST(0x7bf1e2b1, 0x720c1c44, 0x0db64687, 0xf16439fa, 0x41b39833, 0x8095f24e, 0xbeec0cfa, 0x88750dc9), SECP256K1_FE_CONST(0xdc97e26d, 0x3137445d, 0x6c1269b6, 0x1a765501, 0x0c19c36a, 0x2e361066, 0xe31e2bb1, 0x0403470b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd09a4047, 0xf158fe52, 0xf96c661d, 0x02c68657, 0xc4c976ea, 0x96ea85ef, 0x46d6985b, 0xd540756b, 0xe793bfaa, 0xe9300f18, 0xe6f9b55a, 0xae263223, 0x68b61d51, 0xae5022ef, 0xe266c72d, 0x574178bc),  1, {SECP256K1_FE_CONST(0x7e6175fd, 0xfbb9fb4f, 0xaf6e2b92, 0x5ef86c4a, 0x444d819a, 0xaa82dbee, 0x545d3d9b, 0x296375be), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x34986625, 0x04b73c7c, 0x8cecb6c3, 0x3cd493bd, 0xfc190e0f, 0x87d913d7, 0xff9ad42e, 0x222bfe95, 0x245b3a61, 0xb8d46997, 0xf14f2fea, 0x28748996, 0x91eb3254, 0x2b9907d6, 0x5eb9d21d, 0x42454021),  1, {SECP256K1_FE_CONST(0x7f556282, 0xc3dd9d26, 0x3390d6bb, 0xddada698, 0xab8fd7c7, 0xd1a06498, 0xf42b3043, 0x7c8361ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}}\n+};\n+\n+struct ellsq_enc_test {\n+    unsigned char ell64[64];\n+    unsigned char pubkey[33];\n+};\n+\n+/* Set of (ell64, point) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_enc_test ellsq_enc_tests[] = {\n+    {{0x54,0xca,0xd2,0x27,0xb2,0xc9,0x8d,0x5f,0x7c,0x78,0x8c,0xfc,0x3d,0xaf,0xd6,0x52,0xf5,0x8f,0x69,0xcf,0xef,0x63,0x2b,0x82,0x2b,0x35,0xd0,0xb0,0xe2,0x4f,0xc0,0x3a,0xd2,0x8c,0xa1,0x4b,0x6f,0x62,0xd4,0x53,0x79,0xc5,0x3f,0x70,0xee,0x40,0x5c,0xa9,0x2c,0xe7,0xb6,0xf9,0x70,0x83,0x13,0x05,0xf2,0x7d,0xc4,0x1e,0xb6,0x9d,0xe0,0x6e}, {0x02,0x11,0x62,0x89,0x03,0x32,0x88,0x91,0xae,0x09,0xd1,0x08,0xd8,0x92,0x43,0xe4,0x7e,0x10,0x9f,0xe7,0xb8,0xbb,0x1e,0x2d,0xf1,0xa3,0xae,0x9b,0x0e,0x78,0x08,0x54,0x9c}},\n+    {{0xfb,0xe6,0xce,0xab,0x4c,0x5f,0xdf,0xa5,0xfb,0xee,0x8f,0x3d,0x09,0xa2,0xf7,0x23,0x53,0xe7,0x4e,0x5a,0x9c,0xd4,0xab,0x8e,0x6a,0x34,0xd4,0x95,0x23,0xa7,0xd1,0xa2,0xc4,0x50,0xb7,0x45,0xda,0xb1,0xaf,0xa9,0x95,0x4b,0x3a,0x35,0x75,0xe4,0xe8,0xe2,0xdb,0x3d,0xa5,0xcd,0x4d,0x56,0x48,0xea,0xd0,0x0a,0x60,0xb4,0xcd,0xfe,0x84,0xb3}, {0x02,0xc0,0x4c,0x84,0x85,0xf9,0x8d,0x56,0x6c,0x79,0xbf,0x33,0xa7,0x0c,0xb2,0x32,0x54,0x9e,0x3d,0xe1,0xc3,0xe3,0x01,0xe3,0x57,0x1c,0x83,0x68,0x97,0xf0,0x7c,0x5d,0x12}},\n+    {{0x71,0x7e,0x63,0xd7,0x71,0xdb,0xda,0x67,0x67,0xd5,0x8f,0x26,0xab,0x5f,0x54,0x9b,0xd2,0xd1,0x8a,0xcf,0x59,0xff,0x50,0x77,0x5f,0x4e,0xb5,0x0a,0xc0,0x17,0x4d,0xf1,0x7d,0xd0,0x34,0xc8,0xed,0x08,0x11,0x61,0x5e,0x3e,0xbb,0x36,0xf8,0xf3,0x3e,0x09,0x23,0x8e,0x4d,0xa8,0xf5,0x01,0x9d,0x37,0x00,0x78,0x4f,0x37,0xc1,0x53,0x53,0x94}, {0x02,0x72,0x81,0x15,0x0c,0xeb,0xc3,0xd7,0xb3,0xbb,0xb9,0x92,0xf5,0x81,0xbb,0xcb,0x9e,0x30,0x4f,0x87,0x44,0xf0,0x19,0x98,0xa7,0x1f,0x5d,0xe1,0x14,0xf8,0x22,0x91,0xc4}},\n+    {{0x01,0xf0,0xbf,0xe4,0xf9,0xbd,0xee,0x52,0x5e,0xb7,0x7c,0x8e,0x35,0x1e,0x1f,0x88,0x3f,0xb9,0xcd,0x37,0x7e,0xf7,0xc5,0xbd,0xde,0xe4,0xf6,0x60,0x64,0x43,0x90,0xf5,0x95,0x3e,0x7d,0x2b,0x6c,0xde,0x36,0x90,0x3e,0xa1,0x34,0x4b,0x0d,0x16,0x33,0x5c,0xc5,0x11,0x5d,0xaa,0x97,0x7c,0x3c,0x2b,0xf9,0x31,0xac,0xde,0x2f,0xf5,0x78,0x9a}, {0x02,0x10,0x44,0x9d,0x7e,0xa0,0x62,0x3e,0x80,0xa5,0x87,0x01,0x9f,0xa5,0x11,0xaf,0xd3,0x94,0xb2,0x55,0xb0,0x8f,0x91,0xb5,0xf7,0x48,0x2a,0xe9,0xd1,0xa1,0xa7,0xfb,0x7c}},\n+    {{0x82,0xd5,0x87,0x1e,0x18,0x37,0x66,0xbd,0x22,0xe1,0x13,0xa8,0x52,0x79,0xaa,0x61,0x7e,0x6b,0x9f,0x73,0x52,0x2c,0xd4,0x6b,0x90,0x59,0xba,0x51,0x97,0xfa,0x56,0x44,0xaf,0x90,0x41,0x89,0x30,0x98,0x7d,0xb7,0xab,0x4a,0x84,0x0c,0x72,0x64,0x1b,0x58,0xb3,0x66,0xe5,0x7c,0x92,0x8c,0x98,0x3a,0x47,0x37,0x82,0x00,0x3c,0x36,0x10,0xab}, {0x03,0xc8,0xb2,0x62,0xf9,0x31,0x69,0x43,0x75,0x51,0x48,0x3b,0x8a,0x61,0x19,0x83,0x82,0xe3,0x11,0x41,0xaf,0x61,0xbf,0x36,0x10,0x0b,0xd0,0x68,0x46,0x5d,0xdd,0xa8,0x40}},\n+    {{0xda,0x82,0x53,0xb4,0x3b,0x5a,0xc2,0x3b,0x42,0x36,0x07,0xe9,0x18,0xab,0x5c,0xaa,0x5d,0x7d,0x34,0x3d,0x77,0xa3,0x99,0x6a,0x42,0xeb,0x33,0x2a,0x3b,0x55,0x1d,0x8c,0xda,0x6c,0xb6,0xf9,0x57,0x4c,0xe3,0x60,0x91,0x2c,0xf4,0x5b,0x90,0x9a,0x96,0x2e,0x4d,0xed,0x63,0xae,0x5a,0xac,0xb0,0xab,0x23,0x29,0x45,0xb1,0x01,0xf7,0x2b,0x62}, {0x02,0xe7,0x28,0x34,0x1d,0xf6,0x93,0x48,0x71,0xb3,0x94,0xbb,0x4f,0xb2,0x8b,0xd8,0xd2,0xdf,0x39,0x92,0x55,0xb0,0x30,0x02,0xed,0x6f,0xc3,0x8f,0x28,0xcf,0xbf,0x53,0x56}},\n+    {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x03,0x1b,0x41,0x2e,0x7a,0x96,0x6d,0x2c,0x24,0x3d,0xbc,0x5b,0x18,0xb7,0xf9,0xba,0xf1,0x85,0xbc,0xfe,0x41,0x38,0x96,0x04,0x79,0x64,0x1a,0xb1,0xe6,0x3b,0x38,0x1e,0x11}},\n+    {{0xdc,0x30,0x98,0xe4,0x00,0x61,0x83,0x30,0xf3,0x8b,0x19,0xe9,0x20,0x0a,0xdf,0x7f,0xfb,0x96,0x84,0x3f,0xa8,0x3c,0x49,0x1c,0xf6,0x7f,0x34,0xa7,0x90,0xbb,0xcf,0xe1,0x23,0xdc,0x30,0x07,0xa4,0xfd,0x13,0x3a,0x39,0x44,0x0b,0x06,0x03,0x1e,0x9e,0x2c,0x38,0x8e,0x41,0x47,0xaf,0x0e,0x82,0xbe,0xda,0x6d,0x56,0x4b,0xf8,0xcc,0x37,0xb1}, {0x02,0x5b,0x74,0x48,0x15,0x22,0xd4,0xc2,0x9f,0x2e,0x6a,0x2f,0x11,0x7f,0x9e,0x39,0xf9,0xab,0x01,0xb1,0xe9,0xf2,0xc3,0x4c,0x68,0xbe,0x8f,0x53,0x1b,0xe0,0x1f,0x6e,0xa7}},\n+    {{0x35,0xd7,0x0a,0x71,0x2c,0xc0,0x85,0x7f,0x8d,0xb1,0xbc,0x55,0x6a,0x6c,0x4e,0xf8,0x66,0x24,0xfd,0x0a,0x47,0x7f,0x96,0x7e,0xed,0xc0,0x32,0xfc,0xda,0xac,0xe7,0x96,0xc6,0x73,0xc5,0x43,0xd0,0x07,0x34,0x32,0x07,0x85,0x5b,0xeb,0xad,0x85,0xe9,0x4b,0xca,0xc7,0x78,0x2b,0x11,0x57,0x9a,0x70,0xdc,0x88,0xe2,0xa4,0x8d,0x9d,0xf2,0xd4}, {0x02,0xdb,0x21,0xb4,0x8f,0xe9,0xf9,0x95,0x08,0x3a,0x1f,0x9c,0x1f,0x3f,0x4b,0x31,0x1d,0x2c,0x43,0xa1,0x28,0xdb,0xb3,0xa4,0xd4,0x78,0x41,0xe4,0xff,0x5d,0xd0,0x2e,0x61}},\n+    {{0x5f,0xb8,0x07,0xce,0x10,0x0c,0x90,0xd2,0x83,0x7c,0xcf,0xc9,0x4d,0x8f,0x8b,0xa5,0xd3,0x5c,0xd3,0xd6,0xfa,0xfc,0xd2,0xf4,0x1f,0x24,0x5b,0x59,0x6e,0x36,0x00,0x57,0xa0,0x47,0xf8,0x31,0xef,0xf3,0x6f,0x2d,0x7c,0x83,0x30,0x36,0xb2,0x70,0x74,0x5a,0x2c,0xa3,0x2c,0x29,0x05,0x03,0x2d,0x0b,0xe0,0xdb,0xa4,0xa5,0x91,0xc9,0xfb,0xd8}, {0x03,0x41,0x58,0x28,0x65,0x43,0x5e,0xe9,0xc8,0xc9,0x27,0xc3,0x49,0xbd,0x3e,0x43,0x7b,0xce,0x2b,0x5c,0xfc,0xd0,0xc4,0x17,0x77,0xc3,0x4c,0x71,0xc6,0x7b,0x14,0x06,0x93}},\n+    {{0x1e,0x76,0x57,0x72,0xbf,0x72,0xde,0xb8,0x81,0x54,0x16,0xbd,0x54,0x45,0xdd,0x75,0x50,0xcd,0x86,0x7a,0xa2,0x5a,0xc6,0x3f,0x6f,0xd9,0xaf,0xd3,0x2f,0x92,0x1c,0xc8,0x8a,0x06,0x1a,0xb5,0xf6,0x98,0x1b,0x55,0x92,0x1b,0x90,0x5b,0x6f,0x4f,0x3d,0xf4,0x82,0x5d,0x79,0x72,0xd6,0x99,0xe3,0xb4,0x21,0x4e,0x40,0x44,0xcf,0xbe,0x65,0x34}, {0x03,0x90,0xd2,0x94,0x30,0x92,0xec,0x7e,0xd8,0xff,0x5a,0xf7,0x04,0x43,0x2d,0x0d,0xbe,0xb0,0x33,0x7c,0xbf,0x58,0x22,0x87,0x18,0x32,0x76,0x38,0x68,0x1f,0x70,0xd7,0xf0}},\n+    {{0x86,0xef,0x92,0xfd,0x28,0x09,0x85,0x4f,0x74,0xf7,0x5a,0xeb,0xbe,0xa1,0x8a,0xee,0xc0,0xee,0xdd,0x4e,0x81,0x92,0xc8,0x8c,0xd7,0xcf,0xf5,0xdf,0xc0,0x8a,0x57,0xdc,0x32,0x73,0xbf,0x6f,0x39,0x2d,0xee,0x48,0x4a,0x72,0x2c,0x3d,0xb0,0x0c,0x0e,0xfb,0x40,0xd5,0x1e,0x8a,0x72,0xfc,0xfb,0x78,0x3f,0xa7,0xeb,0xd4,0x30,0x82,0xdb,0x71}, {0x02,0x31,0x74,0x79,0x29,0x80,0x2d,0x79,0x76,0x02,0x26,0x71,0xb2,0xf7,0x5a,0xc0,0x31,0x18,0x56,0xb3,0x84,0xf4,0xb9,0xa8,0x00,0x0d,0x44,0xa2,0xab,0xc5,0x90,0x3a,0xd4}}\n+};\n+\n+void run_ellsq_tests(void) {\n+    int i = 0;\n+    /* Verify that secp256k1_ellsq_fe_to_ge_var maps everything to curve points for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {\n+        secp256k1_fe t;\n+        secp256k1_ge g;\n+        random_field_element_test(&t);\n+        secp256k1_ellsq_fe_to_ge_var(&g, &t);\n+        CHECK(secp256k1_ge_is_valid_var(&g));\n+    }\n+    /* Verify that secp256k1_ellsq_ge_to_fe_var + fe_to_ge_var roundtrips for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {",
      "path": "src/modules/ellsq/tests_impl.h",
      "position": 107,
      "original_position": 101,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": null,
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is it worth checking that all preimages are distinct?\r\n\r\n```c\r\n        int j, valid[4];\r\n        secp256k1_fe f[4];\r\n        secp256k1_ge g;\r\n        random_group_element_test(&g);\r\n        for (j = 0; j < 4; j++) {\r\n            valid[j] = 0;\r\n            if (secp256k1_ellsq_ge_to_fe_var(&f[j], &g, j)) {\r\n                secp256k1_ge g2;\r\n                secp256k1_ellsq_fe_to_ge_var(&g2, &f[j]);\r\n                ge_equals_ge(&g, &g2);\r\n                valid[j] = 1;\r\n            }\r\n        }\r\n        /* Preimages should all be distinct */\r\n        for (j = 0; j < 4; j++) {\r\n            int k;\r\n            if (!valid[j]) continue;\r\n            for (k = j + 1; k < 4; k++) {\r\n                if (!valid[k]) continue;\r\n                CHECK(!check_fe_equal(&f[j], &f[k]));\r\n            }\r\n        }\r\n```",
      "created_at": "2021-11-12T19:02:54Z",
      "updated_at": "2021-11-12T20:07:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r748522328",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/748522328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 107,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/748570495",
      "pull_request_review_id": 805205777,
      "id": 748570495,
      "node_id": "PRRC_kwDOAP4Jqs4snkd_",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 254,
      "original_position": 254,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": null,
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Quick question, is there an easy way to hit this branch in a test, that doesn't involve something convoluted like mocking out the hash function?\r\n\r\nNo worries if not but just thought I'd double check, since I added a `VERIFY_CHECK(0)` here and it doesn't get hit by either the test or benchmark.",
      "created_at": "2021-11-12T20:34:14Z",
      "updated_at": "2021-11-12T20:34:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r748570495",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/748570495"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 254,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/748571304",
      "pull_request_review_id": 805206929,
      "id": 748571304,
      "node_id": "PRRC_kwDOAP4Jqs4snkqo",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 254,
      "original_position": 254,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 748570495,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "See the comment below:\r\n\r\n>  Note that if u1 is generated using a secure hash function, the probability of reaching this branch is negligible.\r\n\r\nSo I think it's indeed impossible to construct a testcase for it without stubbing out the hash function.",
      "created_at": "2021-11-12T20:35:58Z",
      "updated_at": "2021-11-12T20:35:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r748571304",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/748571304"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 254,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/749416930",
      "pull_request_review_id": 806192049,
      "id": 749416930,
      "node_id": "PRRC_kwDOAP4Jqs4sqzHi",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 254,
      "original_position": 254,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 748570495,
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I ended up just checking this case manually with these steps:\r\n\r\n- Add code to always set `u1` directly to a preimage of `p` (if one exists)\r\n- Add `VERIFY_CHECK(0)` in the `else` case and make sure it gets hit\r\n- Remove the `VERIFY_CHECK(0)` and make sure the tests (especially roundtrips) pass\r\n\r\nLooks good to me!",
      "created_at": "2021-11-15T15:12:05Z",
      "updated_at": "2021-11-15T16:54:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r749416930",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/749416930"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 254,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/749423567",
      "pull_request_review_id": 806192049,
      "id": 749423567,
      "node_id": "PRRC_kwDOAP4Jqs4sq0vP",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 277,
      "original_position": 277,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": null,
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could this happen? The coverage report shows that this line doesn't get hit, and `secp256k1_pubkey_load` never seems to return 0.\r\n\r\nIf not, would it make sense to either:\r\n- Add an explicit check that the pubkey is valid\r\n- Replace the `if (secp256k1_pubkey_load(ctx, &p, pubkey)) {` with a `VERIFY_CHECK` and de-indent the body",
      "created_at": "2021-11-15T15:19:08Z",
      "updated_at": "2021-11-15T16:54:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r749423567",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/749423567"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/749450934",
      "pull_request_review_id": 806192049,
      "id": 749450934,
      "node_id": "PRRC_kwDOAP4Jqs4sq7a2",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 273,
      "original_position": 273,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": null,
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do you know if this `memset` gets optimized out? e.g. here's how the disassembly for the `tests` binary looked on my machine:\r\n\r\n```asm\r\ncallq   _secp256k1_ellsq_ge_to_fe_var\r\ntestl   %eax, %eax\r\nmovq    -0xd0(%rbp), %r15\r\nmovq    -0xc0(%rbp), %rbx\r\nleaq    -0x2c0(%rbp), %r14\r\nleaq    -0x90(%rbp), %r12\r\nleaq    -0x320(%rbp), %r13\r\njne     0x1000097f1\r\n\r\n...\r\n\r\n0x1000097f1:\r\nleaq    -0x2f0(%rbp), %r14\r\nmovq    %r14, %rdi\r\ncallq   _secp256k1_fe_normalize_var\r\naddq    $0x20, %r15\r\nmovq    %r15, %rdi\r\nmovq    %r14, %rsi\r\ncallq   _secp256k1_fe_get_b32\r\nmovl    $0x1, %eax\r\nmovq    0x1867e5(%rip), %rcx    ## literal pool symbol address: ___stack_chk_guard\r\nmovq    (%rcx), %rcx\r\ncmpq    -0x30(%rbp), %rcx\r\njne     0x10000988d\r\naddq    $0x2f8, %rsp            ## imm = 0x2F8\r\npopq    %rbx\r\npopq    %r12\r\npopq    %r13\r\npopq    %r14\r\npopq    %r15\r\npopq    %rbp\r\nretq\r\n```\r\n\r\nI see calls corresponding to the `if` statement on line 266 above, as well as the `return 1`, but I don't see anything corresponding to the `memset`.",
      "created_at": "2021-11-15T15:47:41Z",
      "updated_at": "2021-11-15T16:54:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r749450934",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/749450934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 273,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/749720877",
      "pull_request_review_id": 806597468,
      "id": 749720877,
      "node_id": "PRRC_kwDOAP4Jqs4sr9Ut",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 277,
      "original_position": 277,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 749423567,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm, good point. I will address this.\r\n\r\nPerhaps we should also make `secp256k1_load_pubkey` return `void` (not in this PR, though).",
      "created_at": "2021-11-15T22:13:15Z",
      "updated_at": "2021-11-15T22:13:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r749720877",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/749720877"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750022300",
      "pull_request_review_id": 806965744,
      "id": 750022300,
      "node_id": "PRRC_kwDOAP4Jqs4stG6c",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 273,
      "original_position": 273,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 749450934,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, it is optimized out but currently that's true for all of these \"safety\" memsets in the codebase. This is something we should really fix. I have an PR here but it's old and needs to be rebased and finished... https://github.com/bitcoin-core/secp256k1/pull/636 ",
      "created_at": "2021-11-16T08:24:10Z",
      "updated_at": "2021-11-16T08:24:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r750022300",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750022300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 273,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750661721",
      "pull_request_review_id": 807835479,
      "id": 750661721,
      "node_id": "PRRC_kwDOAP4Jqs4svjBZ",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_TESTS_H\n+#define SECP256K1_MODULE_ELLSQ_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellsq.h\"\n+\n+struct ellsq_test {\n+    secp256k1_ge point;\n+    int enc_bitmap;\n+    secp256k1_fe encs[4];\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_test ellsq_tests[] = {\n+    {SECP256K1_GE_CONST(0xc27fb7a3, 0x283a7d3e, 0xc9f96421, 0x545ef6f5, 0x8ace7b71, 0x06c8a1b9, 0x07c0ae8a, 0x7598159c, 0xe05a060e, 0x839ef79f, 0xc0c1267c, 0xa17880c9, 0x584cdd34, 0xc05f9695, 0x55482207, 0xe6851f2a), 15, {SECP256K1_FE_CONST(0xc0ad127a, 0xa36824d6, 0x5b1f5be7, 0x4de1aa25, 0xbc4d5cbe, 0xcee15462, 0x0a12682a, 0xfc87df98), SECP256K1_FE_CONST(0xd40fd5bc, 0x51992484, 0x8f13273b, 0x1d857cba, 0x42d45e78, 0x9eaa4e47, 0xf458b83a, 0xbd5f8d1c), SECP256K1_FE_CONST(0xde636141, 0x7deb440b, 0x3a305924, 0x43635cf9, 0xcf42f9b5, 0xf5b891c1, 0x1e119f09, 0x71b570ac), SECP256K1_FE_CONST(0xd55135ce, 0x41bb4d05, 0x5b3757f4, 0xaf1d6537, 0x137376d7, 0x5270caae, 0xda68382d, 0x25d00708)}},\n+    {SECP256K1_GE_CONST(0x3f5ada4e, 0x8f646ec9, 0x10ffc1a2, 0xb74d94bb, 0xb1860631, 0xa3c2a349, 0xeddf55ca, 0xfd49cce9, 0x28ad9d8d, 0x77d9cd87, 0xf80aaa34, 0x8e9ad1b4, 0x40353d7a, 0x6e717714, 0x60425319, 0x38f530c3), 15, {SECP256K1_FE_CONST(0xac42348f, 0x1b356822, 0x5bb7d4c0, 0x0feab37e, 0xa5fb7fbb, 0x0cc3879d, 0xc74e2dda, 0xf9a393bf), SECP256K1_FE_CONST(0xda7a45b2, 0x6c87dcb6, 0x4a934c1d, 0xc841d250, 0xf98af5f0, 0x511be2a3, 0x82d17bab, 0xe1e4a533), SECP256K1_FE_CONST(0xc3d9b9a6, 0x570ca9c8, 0xa640fc75, 0x945850b2, 0xcc86b6d6, 0x399b4496, 0x4288d76d, 0x832a32d7), SECP256K1_FE_CONST(0xbf5ebc2f, 0x4060abe7, 0x884a1fa7, 0xcc0883cb, 0x97535c5a, 0x31dc6df4, 0xc6968e9d, 0x8554f3b1)}},\n+    {SECP256K1_GE_CONST(0xf5f74fab, 0x3ebbbcfd, 0xdcaef6cc, 0xd14eb934, 0xf9435a4e, 0x4a1ed2d8, 0x75352c47, 0x306d6c2f, 0xea6a5b2a, 0xe109897d, 0x046e1504, 0xf7a382d6, 0x1eb49a8a, 0xae8852ef, 0x48e29466, 0x194d9e66), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xe8362df2, 0x38e0405b, 0x49218747, 0x74f9ebca, 0x36dfe21b, 0x1a49ae2d, 0x0fa23fd4, 0x11a262a6), SECP256K1_FE_CONST(0x9e453426, 0xac973155, 0x19d11d63, 0xc3bb27ee, 0x89a7ec85, 0x5661dce4, 0xe428f6cc, 0x0be059cc)}},\n+    {SECP256K1_GE_CONST(0x977694f6, 0x6f0a3005, 0x2c638916, 0x61432fa0, 0x605528a7, 0xad87d829, 0x5c9eb9a3, 0x973c6fed, 0x16515f14, 0x00186fec, 0x67f6314c, 0x8a9e2d43, 0x3d2020e9, 0x38f86465, 0x39f749a1, 0x51a793ed), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x8f091a42, 0xce496be8, 0x877d43fc, 0x2f2b2927, 0x42c9c1fb, 0x0dfe570b, 0x9c9fbd3e, 0x04afa709), SECP256K1_FE_CONST(0xb5930cf1, 0x4db355a5, 0xa92b9f78, 0x9390b59a, 0x013c8e27, 0x7c41ddd6, 0xd8221622, 0x93d39141)}},\n+    {SECP256K1_GE_CONST(0x9c970ce9, 0x39e8a4ec, 0x70237f33, 0xad858370, 0xc9d30e8a, 0xadaac257, 0x546d1e16, 0xf374973b, 0x95755fab, 0x1bcae32e, 0xc811c63f, 0xb1e56da8, 0x97a1e140, 0xb1aae97e, 0x0b6ae6c5, 0x3879f51c), 13, {SECP256K1_FE_CONST(0xa7424f55, 0x60b58ceb, 0xbb9a6ee1, 0x5fc41b18, 0xf282b2cd, 0xd9e2fb4d, 0x02626c1a, 0xc0a89ec4), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xd7016e9b, 0x94db9b4c, 0x5bc61c87, 0xaf3b3c9c, 0x72707e5e, 0x48332958, 0xce5371bf, 0xd501a006), SECP256K1_FE_CONST(0xe95cd3a1, 0x2cff74bd, 0x6761a782, 0x61f73f0d, 0x755a80f6, 0x39ccd117, 0x136f9963, 0xf422b82a)}},\n+    {SECP256K1_GE_CONST(0x48206211, 0x5e6fc771, 0x738b4859, 0x4da66901, 0xa0a8c36e, 0xa61122b7, 0x745cf5fe, 0xec932b64, 0x01c9e1a1, 0x59effb22, 0x4442c868, 0x9119fd26, 0x8cdca070, 0x7edbefb6, 0xea81d5f6, 0x86333768), 13, {SECP256K1_FE_CONST(0xf1047fb9, 0x4cfa6dcd, 0x202e1acc, 0xa85afc88, 0x46381925, 0x7adf32aa, 0x25e19e52, 0xbf3cadd8), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x94dc1b2b, 0x6a24bbdb, 0x36afab1a, 0x6e036e7f, 0xdf1ded22, 0x915bf761, 0x97e5e5a5, 0xc6261582), SECP256K1_FE_CONST(0x8dd664ba, 0x47061bac, 0x0c99d727, 0xac2ade9f, 0xf8d33aff, 0x995a7a28, 0x97f2968c, 0x558ef724)}},\n+    {SECP256K1_GE_CONST(0x47e54d7b, 0x86025d30, 0x248b18e6, 0xc6b2b128, 0x3f8eb11e, 0x60d11cad, 0xf59884ea, 0x56939f5a, 0xb618d932, 0x6110c200, 0xcbed144f, 0xc6376800, 0xd8ba0de1, 0xd87fa02d, 0x17d1d58d, 0x9652c498),  3, {SECP256K1_FE_CONST(0x8797d6a9, 0xe3614b34, 0x80e43cb6, 0x936cd932, 0xbe4eee02, 0x1e47e067, 0x2d1d9f2f, 0xd0148558), SECP256K1_FE_CONST(0xb19c75d0, 0xb4856c81, 0xb467f8f5, 0xb9f8d849, 0x0e5296f0, 0x4c60d639, 0x6f772b7f, 0x427c5d38), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8fa5ffb5, 0x597068f6, 0x06785a63, 0x1f74cd6f, 0x8b16e94b, 0xe6cee831, 0x2970e0ec, 0xa9ecda52, 0x6c4f0efe, 0xf1d0eef2, 0xe3281b13, 0x4f29289f, 0x0a9d7b4d, 0xb3118c5f, 0x1d2d1da4, 0x75569ebf),  3, {SECP256K1_FE_CONST(0xe66995d0, 0x9cfdddda, 0xadf4b4ec, 0xc00270ed, 0xaeaacf01, 0x2db38d37, 0xe4143baf, 0x0ae7dfa3), SECP256K1_FE_CONST(0xfe0d264e, 0x3121942c, 0xd5126e26, 0x0766f36c, 0x3a08a689, 0x4e8ec172, 0xf3fdb252, 0x70def1ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x016a682d, 0x1df4f869, 0xb32c48b0, 0xa9b442a1, 0x493949fb, 0x85d951d1, 0x21c1143b, 0xd3d5c1af, 0x38d33fe5, 0xd3f9b4b9, 0x82e37dff, 0x7561428d, 0x47ef4ddf, 0x654bd959, 0x51b04e90, 0xa3be50e7),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ec42424, 0xb4d2226f, 0x83f94258, 0xc737d0da, 0xf93a4eb1, 0x1d9b9e3f, 0xd500d5b9, 0xc3aa7c71, 0x84975819, 0xb703da77, 0xca98bd3c, 0xd9bbdc7a, 0xf1dbc7b5, 0x85c590eb, 0xcbd417fd, 0x739ad572),  1, {SECP256K1_FE_CONST(0x945faa12, 0x7e8bf378, 0x63581bfb, 0xde084bf7, 0x63caee39, 0x1449c610, 0xc2074f86, 0xff1bf16c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x69ee52b2, 0x88dfb06a, 0x449d3db8, 0x7602e094, 0xb4f131e3, 0xf6a4b249, 0xdc0a76ff, 0xdebe989a, 0x3922f1a4, 0xdd208f94, 0xcbac1c5d, 0x34a9278d, 0x84310781, 0x84ff4430, 0x31a14018, 0x95ffd9e6),  1, {SECP256K1_FE_CONST(0xdc1e4760, 0x15bda784, 0xa1b9527b, 0x0357786a, 0xdf2a8028, 0x03957837, 0xe10cff92, 0x5ef4ca7e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0x3ac01550, 0x68185039, 0x6068aaf0, 0xc3f24144, 0x9a267956, 0x698833d4, 0x80c03dc5, 0x678b67cf),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9ddddd8e, 0xc1814a29, 0x3fcca202, 0xebfbe14e, 0x5d808dda, 0x142eee64, 0xc6108381, 0xe99e5cff, 0xb5072d55, 0x37223f39, 0x3e4176d2, 0xcfd93c86, 0x82ca2c22, 0xcd25ec40, 0x877296bd, 0xbb7c08f6),  3, {SECP256K1_FE_CONST(0xadd34f27, 0xc5f90171, 0x75186c23, 0xd14f6ef2, 0xaa182896, 0x77d5373a, 0xd6c31e9f, 0xf6358ae8), SECP256K1_FE_CONST(0xf5ee8614, 0x1916fe03, 0x945d028b, 0xbc354c4a, 0x09f6d6ab, 0x1468ab9a, 0xd8742075, 0x1543c2a2), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ee7e9a7, 0xfcd56edf, 0xabf3712e, 0x72cc24a3, 0x0a476f5a, 0x97f77825, 0xf0308620, 0x162f31ad, 0x77bfc7de, 0xc2401a39, 0x8c5e8675, 0x417c8a7b, 0x632f5d64, 0x2f1a5059, 0x9a830b8c, 0x7981f636),  3, {SECP256K1_FE_CONST(0xb3a8d9e7, 0x368af258, 0x3785be92, 0x2ad54dfb, 0x47329513, 0x6ade2d18, 0x2f931cd6, 0x54f35d02), SECP256K1_FE_CONST(0xe1d420e5, 0xfab5c26d, 0xf4294b2b, 0x0c19eb9a, 0x188409bf, 0x48a3741f, 0x31f72acc, 0x6ea93418), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9e24d0a5, 0xd5014164, 0x987f86bb, 0x1709305a, 0x6fd352a0, 0xa3478fae, 0x3f85e594, 0x21d72a80, 0x3729c39b, 0xbbb26d97, 0xa4ec6bf7, 0xcb4e6453, 0x058e448e, 0x7530b028, 0xd1ae345e, 0x35608d3c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x15f2f1a4, 0x339f5f2a, 0x313b9501, 0x5cad8124, 0xd054a171, 0xac2f31cf, 0x529dda7c, 0xfb6a38b4, 0xfe1d0fa5, 0x95b4f7d3, 0x63e82c29, 0x0095189f, 0x5f2be99c, 0x880be4fc, 0x9742a31b, 0x40041eda),  1, {SECP256K1_FE_CONST(0xc1c3ed27, 0x17ffabfd, 0x01132f5e, 0x54dd73c3, 0x475297e0, 0xfdbff814, 0xdc9456b8, 0x4a57b698), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd383134d, 0x721cf055, 0x143570e7, 0x82bb323d, 0x5c542a61, 0xe455823e, 0xd60b940f, 0x86826d54, 0x5a88e50b, 0x3f59874e, 0x84dab4a2, 0x07d34623, 0xd836c376, 0xc68dded3, 0xc095a716, 0xf563e4fc),  1, {SECP256K1_FE_CONST(0xe4d2660c, 0x1d50d031, 0x97f5e610, 0x4d9c2066, 0x01f6c791, 0xadb52178, 0xe2bd6c88, 0xe89cf012), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  3, {SECP256K1_FE_CONST(0xd3779b57, 0x3cb17828, 0xac118cff, 0x74412ab5, 0xb84c86f8, 0xa92f48b8, 0xefcbe4c7, 0x0a675631), SECP256K1_FE_CONST(0xea6f729d, 0xdc884123, 0xf0130aa0, 0x339bda36, 0x2166d034, 0xfe50d9d7, 0x53bf0dde, 0x7721fa3f), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x99a70224, 0xc3062c32, 0x6c45d3c6, 0x46a545e9, 0xb152b75b, 0xee868378, 0x07e47951, 0x9e5b600d, 0x95b6675a, 0x10845b66, 0x37ff96e8, 0xe67f2a75, 0xbbf0f764, 0xc56d26c5, 0x4b2db5eb, 0xb026d7de),  3, {SECP256K1_FE_CONST(0xb74a9552, 0xc5b9b6ed, 0x575d380f, 0xec3df8ed, 0xdb524ed1, 0x80b13607, 0x81e2eec6, 0x7ad06c04), SECP256K1_FE_CONST(0xbb702282, 0x4194fbe4, 0x4a74c4f4, 0xabd01ee3, 0xdac8f4cb, 0x5a0e3a67, 0xd2276039, 0xdd4aac1a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb5902433, 0x3110b310, 0x8625f254, 0x47665c1e, 0xbf10c6a6, 0xbbe9f018, 0xc421f4b0, 0xdcb5a993, 0x43bae2cd, 0xaae9c002, 0xe57ac99a, 0x17926e22, 0x76a66728, 0xf92b11bb, 0x7dc953b9, 0xea6d49b7),  3, {SECP256K1_FE_CONST(0xd5a57c1b, 0x71916606, 0xbfb235f0, 0xce8d880d, 0xe9109a01, 0xb86d58c8, 0x2852b211, 0x0e55ee0f), SECP256K1_FE_CONST(0xca6cf74b, 0x128e1d79, 0x75482bfd, 0xc9e81416, 0x71a5c3e7, 0xe2af854b, 0x23707630, 0x97ba917b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb526749e, 0x35fa04ef, 0x5d20b1d6, 0xcda6f57e, 0x2f3c10c9, 0x85098901, 0xc390da79, 0x31769e34, 0x182093b3, 0xce5883a2, 0x7b834af6, 0x18547fd1, 0x6017cee0, 0x4e9398da, 0x6aaaed2b, 0x87ca0e7c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x901c52d6, 0xa39718c7, 0x255e94e3, 0x3189cbeb, 0x41f2fa97, 0x95279076, 0xbecd6678, 0x99684c17, 0xf988a838, 0x156cc39f, 0x2182bbc5, 0xf7e4f707, 0x9cf75bfb, 0x58638cff, 0x5b201fd3, 0xcf499fc0),  1, {SECP256K1_FE_CONST(0xa356db31, 0x44b754a3, 0xdafdf2a9, 0x0767b65a, 0xbaea92ca, 0x56c69c3a, 0x31a4ff5b, 0xd7914d9c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x957d4fd4, 0x4a10f38a, 0x0d0e1e46, 0x2656dd2e, 0x7f2b6b8c, 0x9545ee02, 0x903f28b0, 0x8f9a57e7, 0x3f4bf4de, 0x3731bea3, 0x291627e3, 0x9daa7dac, 0xcdcd4e13, 0xb2418482, 0x488730b7, 0xa7a816b7),  1, {SECP256K1_FE_CONST(0xa761cd3a, 0x58385878, 0x300c6963, 0xe918b545, 0x99eb0254, 0x550f6254, 0xe414628c, 0x2f431bbd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x0a7b6db2, 0x56f01aea, 0x797a0798, 0x5eaf98d6, 0x64486f82, 0x723758bf, 0x1a5f7b00, 0xb74887e1, 0xe07ce7ec, 0x5f24b6da, 0x199329ff, 0x674788c4, 0x1b7312d4, 0xbb63672f, 0x81ebbfd3, 0x6d962235), 15, {SECP256K1_FE_CONST(0x442e15e3, 0xac31958b, 0x7acdb8b9, 0x7977b6d0, 0x533b1ef0, 0x5094f496, 0x126a04d0, 0xc6d6c327), SECP256K1_FE_CONST(0xc565d637, 0x6c8f4fa4, 0xa22ab5d4, 0xe1c87f5d, 0x6f9beb27, 0x7764a77f, 0x8ebe3796, 0xaa82cba5), SECP256K1_FE_CONST(0x2082a3b7, 0x04d3729c, 0x71a73a0c, 0xd745c7ce, 0x7a7c5e26, 0x77c688e2, 0x772806d1, 0xdd1a849f), SECP256K1_FE_CONST(0xc00c8cc3, 0x5ea8122e, 0xf17b0a8e, 0xc69218d1, 0x8cb45a3f, 0x0227a2c5, 0x68fbd9f9, 0xc6d6d141)}},\n+    {SECP256K1_GE_CONST(0x770ed6cb, 0xf6d2156b, 0x362523eb, 0xc2908f68, 0x65ab182c, 0x43468bc8, 0x69d6754e, 0x68dc71a0, 0x2a378713, 0x10223129, 0xbaba56c2, 0x0dc4a1e9, 0x634dba32, 0xa034d21f, 0x3104176b, 0x870c9916), 15, {SECP256K1_FE_CONST(0x092c79ab, 0xbbafd66d, 0x58c56208, 0x7ba5c385, 0x9fed6c1b, 0x5f8005af, 0x0087cedb, 0xec7dc084), SECP256K1_FE_CONST(0x3f5c280a, 0x60802515, 0x16dfd84a, 0x4488df47, 0x96198d5f, 0xbce0be21, 0x1ab0ee7d, 0xa456e73e), SECP256K1_FE_CONST(0x94057b6b, 0xd54b13b2, 0xe2b9d322, 0x687569f5, 0xdd16727d, 0x3d912ba3, 0xeb8aa33d, 0x36c15108), SECP256K1_FE_CONST(0x098360ae, 0xcf93979e, 0x7cd6df39, 0x6e8fe2f3, 0x18fa1da3, 0x9efa707a, 0xeab95cd8, 0xcd5dca2a)}},\n+    {SECP256K1_GE_CONST(0xab01575c, 0x0604c63e, 0xe77d3153, 0x4a5bcfa2, 0x0ce66c9d, 0xf47d6054, 0xb822bfd8, 0x6934f8ec, 0xce488d85, 0xd0875b40, 0x4fb92b6e, 0x8068602a, 0x670ac4f8, 0xd76b78b6, 0xc246b713, 0x595e226b), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4ab21b18, 0x1009aa48, 0xb8ba5eb9, 0xd373919b, 0xcfcb36a6, 0xf34961b2, 0xc859f5a8, 0x6da8ba41), SECP256K1_FE_CONST(0x9a11c401, 0x9a4ba9fc, 0xf4698a71, 0x2d85c8e4, 0x70028e02, 0x545ef049, 0xf9f3083d, 0x187c5b41)}},\n+    {SECP256K1_GE_CONST(0x6084cfdd, 0xf8d9736e, 0xa90100eb, 0xdb43338f, 0x65e2ab43, 0xef35a799, 0x926e6ce3, 0x2a89ae17, 0x753998b5, 0x9eaae7a3, 0xdcab34d9, 0xa15dbc71, 0xe539cdff, 0xdcf05927, 0x0eb27c86, 0xab6b62a4), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x18b1f707, 0x3fca3167, 0x04e1b3b8, 0x8cc8ff5a, 0x702d79bc, 0x756e4dea, 0x2ff948cc, 0xdb43a9f4), SECP256K1_FE_CONST(0xca02e589, 0x89eb16d1, 0x520463d2, 0x435745cf, 0x6e69fa52, 0x6b5c7adc, 0x57cea2b3, 0xf5a6441c)}},\n+    {SECP256K1_GE_CONST(0xc9fbac00, 0x9d8eda5d, 0x25c9aabb, 0x2b6794bc, 0x9a801afd, 0x17adef78, 0x78c65392, 0x04eb0f82, 0x95ed9e51, 0x898b903e, 0xe689e6ed, 0xff2b54bf, 0xed5c2da1, 0x69e2bdd0, 0x415a392e, 0x16b3de2b), 13, {SECP256K1_FE_CONST(0x21a95220, 0x8577e3f0, 0xcc5b4b17, 0xf5e434b2, 0x2bbdbaaa, 0x51cd2659, 0xe37880a6, 0xa25aa7dd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xcfd1ca13, 0x2f8d3eae, 0x73a97895, 0x01d2c82a, 0x6f057566, 0x7949fab9, 0x267bc1e8, 0xef9bf5bd), SECP256K1_FE_CONST(0x9cde02aa, 0x3acd2596, 0xdbea4b82, 0xf9f47ad1, 0x994ad567, 0x3c0d4fb2, 0xe8a3dca5, 0xe8e067fb)}},\n+    {SECP256K1_GE_CONST(0x8dcb38d9, 0x0059d4f1, 0x270455af, 0x6f3dd40e, 0x8d671a34, 0xa1fad81d, 0x2470db8a, 0x13b18f76, 0x603ed5be, 0x7bc3e67f, 0x439067da, 0x29949bcb, 0xd3c96c9f, 0x94da4231, 0x3c9c0feb, 0xe5cdf560), 13, {SECP256K1_FE_CONST(0x3ef4008a, 0x8a190a3f, 0x5c97d211, 0x3bb539e1, 0xf4261a78, 0xf7cd85c4, 0xfd254837, 0xeaacd020), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x0fe7af4f, 0xcab80199, 0x37ee0026, 0x47d55d97, 0x575474b3, 0x4b9cc1bb, 0x133f4261, 0x017124a0), SECP256K1_FE_CONST(0x09dcec3b, 0x93c4ab42, 0x91d01dce, 0xccc19525, 0xc801add3, 0x77170c2c, 0x919f5488, 0xf41d6d3e)}},\n+    {SECP256K1_GE_CONST(0xf69dfe44, 0x890d2b09, 0x4b749a56, 0xf680e851, 0x50c47c4c, 0xd51e7796, 0x3fec4e6a, 0x09dcd0a1, 0xfb5d321c, 0x1e243b63, 0x6dfb71f3, 0xcf0e8a01, 0x2e52b22c, 0x905cec6d, 0x2f6ae32a, 0x6a4eb7be),  3, {SECP256K1_FE_CONST(0xa17fd528, 0x7276cbf6, 0xc168dcde, 0xb32aba14, 0xe1aeae2f, 0xe7f5bea5, 0xa87d384e, 0xe8046aac), SECP256K1_FE_CONST(0x637f176a, 0xf2fe854a, 0x968ab19b, 0xee010554, 0x313e3eff, 0xc6ff8cb4, 0xcb538a6d, 0xbaedd954), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x043a0631, 0x871a3f67, 0xac03c5f8, 0x406b69a0, 0xdc14bd5b, 0x23e55f27, 0xa5d4462b, 0x0f0a2d23, 0x247b9bcc, 0x0019091c, 0x31eb4b03, 0xe731a0b5, 0xa9b33f75, 0xad9e5e63, 0x39286573, 0xa6439d88),  3, {SECP256K1_FE_CONST(0xd65add13, 0xad3044d9, 0x2ebcd0e6, 0xd42853d8, 0xe5733ff6, 0x5297f544, 0x09a3ce89, 0xfdaffbdc), SECP256K1_FE_CONST(0x7281ad3c, 0x85de3870, 0x84f64e14, 0x42b37154, 0xeab39453, 0x8b1c0753, 0x4b303ae7, 0x37f3973e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8855508a, 0xade16ec5, 0x73d21e6a, 0x485dfd0a, 0x7624085c, 0x1a14b5ec, 0xdd6485de, 0x0c6839a4, 0xe50aaeba, 0xa0ceceec, 0xa1bce62e, 0x5f0fac4b, 0xe78ab03a, 0x7b2deaa6, 0xe5c17e88, 0x98e277e9),  1, {SECP256K1_FE_CONST(0x4e96da73, 0xae14fc85, 0x25eccb2d, 0xf4416924, 0x8a7fd269, 0xa065e065, 0x04d315e6, 0x63666b03), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xc66327bc, 0x5b0b8b90, 0x37adfd63, 0xc2a9f192, 0x2ce2144a, 0xa513b390, 0xd48bc387, 0xae3ebff6, 0x17a1ca89, 0x64eb0b41, 0x162894e6, 0x4fb4112b, 0x638f96ec, 0xe0c6f30d, 0xef7616fe, 0x0e78386a),  1, {SECP256K1_FE_CONST(0x56e8e17e, 0xfaf989d6, 0xa7efb81d, 0x5a602393, 0x6814930e, 0xbc3f6fdf, 0x72ebf472, 0x69ba4c9a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0xc53feaaf, 0x97e7afc6, 0x9f97550f, 0x3c0dbebb, 0x65d986a9, 0x9677cc2b, 0x7f3fc239, 0x98749460),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9d709c02, 0x74604cb6, 0x3b531fea, 0x35932e2e, 0xc965f4bf, 0x5913e577, 0xff31080b, 0x67727a2e, 0xf2b0b821, 0xa24081a9, 0xd0ca84d9, 0x303068cf, 0x7ea32788, 0x05926b0a, 0xb90b9af7, 0x498efbd5),  3, {SECP256K1_FE_CONST(0xb06abefa, 0x192a6498, 0xbce368ff, 0xacc843fb, 0xb39f8117, 0xa56a1870, 0xf57197ef, 0xd9312f6d), SECP256K1_FE_CONST(0x1263d142, 0xaac9cfc5, 0x64c56650, 0x0fa4a62f, 0x38e727fb, 0xb4dbeaf2, 0x6fdf7d05, 0xfd022c71), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb4955dcb, 0x4daaa784, 0x9b421c14, 0x53ec8945, 0xd685d554, 0xf41103f8, 0x12cbfb2f, 0x54a4539b, 0x354d18e4, 0xb1cee7a3, 0xf98b0651, 0xf5544091, 0xe8a00656, 0x0c74750d, 0xaadf460e, 0xc3f620ea),  3, {SECP256K1_FE_CONST(0x6281a8a7, 0x0a3b5745, 0xb897ce4f, 0x58305fb0, 0xd6a0f8ab, 0xa6c5ba18, 0xed278ce1, 0x50f7911c), SECP256K1_FE_CONST(0x5f95a708, 0x2d2f6d69, 0xf7ff9b74, 0x2b88063c, 0x39a3003b, 0xb03f333c, 0x7e3d7c5e, 0xd861fb04), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x6ad63dfd, 0xcd231967, 0xff2508f4, 0x75896976, 0xf8728e40, 0xdd7a2acc, 0x6b5ced37, 0xcada8291, 0xf93e5181, 0x8f5329b8, 0xd520a9af, 0xd72938e1, 0x2e3f8be6, 0x421d2bce, 0x89d7b14e, 0x25bf5336),  1, {SECP256K1_FE_CONST(0x0f050318, 0x622f79f1, 0x5a2b23d9, 0xf76329b7, 0x8e195f1a, 0x4651aae0, 0x65d58bcd, 0xdfa4d3b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa91b7f2a, 0xb93de821, 0xabeec175, 0x0258e4d4, 0xf5f09831, 0xb0a11dda, 0x47e89ddf, 0x6944d819, 0x22eb9bf6, 0x4a517df2, 0xc27d1c55, 0x1df07609, 0x166fc995, 0xe2b39fee, 0x0473ea46, 0xed14efc1),  1, {SECP256K1_FE_CONST(0x7a01651a, 0x81a7f09e, 0x2733cf34, 0x9e6472a1, 0x18c16780, 0x6f5c880f, 0x534b89a6, 0x52be06a7), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  3, {SECP256K1_FE_CONST(0x2c8864a8, 0xc34e87d7, 0x53ee7300, 0x8bbed54a, 0x47b37907, 0x56d0b747, 0x10341b37, 0xf598a5fe), SECP256K1_FE_CONST(0x15908d62, 0x2377bedc, 0x0fecf55f, 0xcc6425c9, 0xde992fcb, 0x01af2628, 0xac40f220, 0x88de01f0), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa64de96a, 0x6254cefc, 0xffbeaf89, 0x8f2c228a, 0xf6d405f3, 0xbcc6a4cc, 0xe068312a, 0xf7ccf8e1, 0x8f9b3a1b, 0x2d146ea9, 0x54bfc5e2, 0xcdfe861c, 0xcbed8431, 0xc741c5f9, 0xd32f16a3, 0x073ea496),  3, {SECP256K1_FE_CONST(0x4591d33d, 0x1a133a87, 0x94689b1b, 0x0ca445b7, 0x8ada3bce, 0xc2e812b0, 0x8315e2b1, 0x07940ad4), SECP256K1_FE_CONST(0xa763d217, 0x6027d40e, 0x8a8ff34b, 0xd9c639b7, 0x3e2ea045, 0x92274fdc, 0xfa4051c6, 0x6d93a1b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x49a0dc06, 0x8c3f117a, 0xefdc842d, 0x3d358153, 0xf677f04c, 0x6dabc9c9, 0x1b09d452, 0xfef27b66, 0x7b944da4, 0x8a175dbc, 0x444ead8d, 0xb82eff66, 0xb081a8aa, 0xe6453fed, 0x2bca9720, 0xb44dd6e5),  3, {SECP256K1_FE_CONST(0x7bf1e2b1, 0x720c1c44, 0x0db64687, 0xf16439fa, 0x41b39833, 0x8095f24e, 0xbeec0cfa, 0x88750dc9), SECP256K1_FE_CONST(0xdc97e26d, 0x3137445d, 0x6c1269b6, 0x1a765501, 0x0c19c36a, 0x2e361066, 0xe31e2bb1, 0x0403470b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd09a4047, 0xf158fe52, 0xf96c661d, 0x02c68657, 0xc4c976ea, 0x96ea85ef, 0x46d6985b, 0xd540756b, 0xe793bfaa, 0xe9300f18, 0xe6f9b55a, 0xae263223, 0x68b61d51, 0xae5022ef, 0xe266c72d, 0x574178bc),  1, {SECP256K1_FE_CONST(0x7e6175fd, 0xfbb9fb4f, 0xaf6e2b92, 0x5ef86c4a, 0x444d819a, 0xaa82dbee, 0x545d3d9b, 0x296375be), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x34986625, 0x04b73c7c, 0x8cecb6c3, 0x3cd493bd, 0xfc190e0f, 0x87d913d7, 0xff9ad42e, 0x222bfe95, 0x245b3a61, 0xb8d46997, 0xf14f2fea, 0x28748996, 0x91eb3254, 0x2b9907d6, 0x5eb9d21d, 0x42454021),  1, {SECP256K1_FE_CONST(0x7f556282, 0xc3dd9d26, 0x3390d6bb, 0xddada698, 0xab8fd7c7, 0xd1a06498, 0xf42b3043, 0x7c8361ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}}\n+};\n+\n+struct ellsq_enc_test {\n+    unsigned char ell64[64];\n+    unsigned char pubkey[33];\n+};\n+\n+/* Set of (ell64, point) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_enc_test ellsq_enc_tests[] = {\n+    {{0x54,0xca,0xd2,0x27,0xb2,0xc9,0x8d,0x5f,0x7c,0x78,0x8c,0xfc,0x3d,0xaf,0xd6,0x52,0xf5,0x8f,0x69,0xcf,0xef,0x63,0x2b,0x82,0x2b,0x35,0xd0,0xb0,0xe2,0x4f,0xc0,0x3a,0xd2,0x8c,0xa1,0x4b,0x6f,0x62,0xd4,0x53,0x79,0xc5,0x3f,0x70,0xee,0x40,0x5c,0xa9,0x2c,0xe7,0xb6,0xf9,0x70,0x83,0x13,0x05,0xf2,0x7d,0xc4,0x1e,0xb6,0x9d,0xe0,0x6e}, {0x02,0x11,0x62,0x89,0x03,0x32,0x88,0x91,0xae,0x09,0xd1,0x08,0xd8,0x92,0x43,0xe4,0x7e,0x10,0x9f,0xe7,0xb8,0xbb,0x1e,0x2d,0xf1,0xa3,0xae,0x9b,0x0e,0x78,0x08,0x54,0x9c}},\n+    {{0xfb,0xe6,0xce,0xab,0x4c,0x5f,0xdf,0xa5,0xfb,0xee,0x8f,0x3d,0x09,0xa2,0xf7,0x23,0x53,0xe7,0x4e,0x5a,0x9c,0xd4,0xab,0x8e,0x6a,0x34,0xd4,0x95,0x23,0xa7,0xd1,0xa2,0xc4,0x50,0xb7,0x45,0xda,0xb1,0xaf,0xa9,0x95,0x4b,0x3a,0x35,0x75,0xe4,0xe8,0xe2,0xdb,0x3d,0xa5,0xcd,0x4d,0x56,0x48,0xea,0xd0,0x0a,0x60,0xb4,0xcd,0xfe,0x84,0xb3}, {0x02,0xc0,0x4c,0x84,0x85,0xf9,0x8d,0x56,0x6c,0x79,0xbf,0x33,0xa7,0x0c,0xb2,0x32,0x54,0x9e,0x3d,0xe1,0xc3,0xe3,0x01,0xe3,0x57,0x1c,0x83,0x68,0x97,0xf0,0x7c,0x5d,0x12}},\n+    {{0x71,0x7e,0x63,0xd7,0x71,0xdb,0xda,0x67,0x67,0xd5,0x8f,0x26,0xab,0x5f,0x54,0x9b,0xd2,0xd1,0x8a,0xcf,0x59,0xff,0x50,0x77,0x5f,0x4e,0xb5,0x0a,0xc0,0x17,0x4d,0xf1,0x7d,0xd0,0x34,0xc8,0xed,0x08,0x11,0x61,0x5e,0x3e,0xbb,0x36,0xf8,0xf3,0x3e,0x09,0x23,0x8e,0x4d,0xa8,0xf5,0x01,0x9d,0x37,0x00,0x78,0x4f,0x37,0xc1,0x53,0x53,0x94}, {0x02,0x72,0x81,0x15,0x0c,0xeb,0xc3,0xd7,0xb3,0xbb,0xb9,0x92,0xf5,0x81,0xbb,0xcb,0x9e,0x30,0x4f,0x87,0x44,0xf0,0x19,0x98,0xa7,0x1f,0x5d,0xe1,0x14,0xf8,0x22,0x91,0xc4}},\n+    {{0x01,0xf0,0xbf,0xe4,0xf9,0xbd,0xee,0x52,0x5e,0xb7,0x7c,0x8e,0x35,0x1e,0x1f,0x88,0x3f,0xb9,0xcd,0x37,0x7e,0xf7,0xc5,0xbd,0xde,0xe4,0xf6,0x60,0x64,0x43,0x90,0xf5,0x95,0x3e,0x7d,0x2b,0x6c,0xde,0x36,0x90,0x3e,0xa1,0x34,0x4b,0x0d,0x16,0x33,0x5c,0xc5,0x11,0x5d,0xaa,0x97,0x7c,0x3c,0x2b,0xf9,0x31,0xac,0xde,0x2f,0xf5,0x78,0x9a}, {0x02,0x10,0x44,0x9d,0x7e,0xa0,0x62,0x3e,0x80,0xa5,0x87,0x01,0x9f,0xa5,0x11,0xaf,0xd3,0x94,0xb2,0x55,0xb0,0x8f,0x91,0xb5,0xf7,0x48,0x2a,0xe9,0xd1,0xa1,0xa7,0xfb,0x7c}},\n+    {{0x82,0xd5,0x87,0x1e,0x18,0x37,0x66,0xbd,0x22,0xe1,0x13,0xa8,0x52,0x79,0xaa,0x61,0x7e,0x6b,0x9f,0x73,0x52,0x2c,0xd4,0x6b,0x90,0x59,0xba,0x51,0x97,0xfa,0x56,0x44,0xaf,0x90,0x41,0x89,0x30,0x98,0x7d,0xb7,0xab,0x4a,0x84,0x0c,0x72,0x64,0x1b,0x58,0xb3,0x66,0xe5,0x7c,0x92,0x8c,0x98,0x3a,0x47,0x37,0x82,0x00,0x3c,0x36,0x10,0xab}, {0x03,0xc8,0xb2,0x62,0xf9,0x31,0x69,0x43,0x75,0x51,0x48,0x3b,0x8a,0x61,0x19,0x83,0x82,0xe3,0x11,0x41,0xaf,0x61,0xbf,0x36,0x10,0x0b,0xd0,0x68,0x46,0x5d,0xdd,0xa8,0x40}},\n+    {{0xda,0x82,0x53,0xb4,0x3b,0x5a,0xc2,0x3b,0x42,0x36,0x07,0xe9,0x18,0xab,0x5c,0xaa,0x5d,0x7d,0x34,0x3d,0x77,0xa3,0x99,0x6a,0x42,0xeb,0x33,0x2a,0x3b,0x55,0x1d,0x8c,0xda,0x6c,0xb6,0xf9,0x57,0x4c,0xe3,0x60,0x91,0x2c,0xf4,0x5b,0x90,0x9a,0x96,0x2e,0x4d,0xed,0x63,0xae,0x5a,0xac,0xb0,0xab,0x23,0x29,0x45,0xb1,0x01,0xf7,0x2b,0x62}, {0x02,0xe7,0x28,0x34,0x1d,0xf6,0x93,0x48,0x71,0xb3,0x94,0xbb,0x4f,0xb2,0x8b,0xd8,0xd2,0xdf,0x39,0x92,0x55,0xb0,0x30,0x02,0xed,0x6f,0xc3,0x8f,0x28,0xcf,0xbf,0x53,0x56}},\n+    {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x03,0x1b,0x41,0x2e,0x7a,0x96,0x6d,0x2c,0x24,0x3d,0xbc,0x5b,0x18,0xb7,0xf9,0xba,0xf1,0x85,0xbc,0xfe,0x41,0x38,0x96,0x04,0x79,0x64,0x1a,0xb1,0xe6,0x3b,0x38,0x1e,0x11}},\n+    {{0xdc,0x30,0x98,0xe4,0x00,0x61,0x83,0x30,0xf3,0x8b,0x19,0xe9,0x20,0x0a,0xdf,0x7f,0xfb,0x96,0x84,0x3f,0xa8,0x3c,0x49,0x1c,0xf6,0x7f,0x34,0xa7,0x90,0xbb,0xcf,0xe1,0x23,0xdc,0x30,0x07,0xa4,0xfd,0x13,0x3a,0x39,0x44,0x0b,0x06,0x03,0x1e,0x9e,0x2c,0x38,0x8e,0x41,0x47,0xaf,0x0e,0x82,0xbe,0xda,0x6d,0x56,0x4b,0xf8,0xcc,0x37,0xb1}, {0x02,0x5b,0x74,0x48,0x15,0x22,0xd4,0xc2,0x9f,0x2e,0x6a,0x2f,0x11,0x7f,0x9e,0x39,0xf9,0xab,0x01,0xb1,0xe9,0xf2,0xc3,0x4c,0x68,0xbe,0x8f,0x53,0x1b,0xe0,0x1f,0x6e,0xa7}},\n+    {{0x35,0xd7,0x0a,0x71,0x2c,0xc0,0x85,0x7f,0x8d,0xb1,0xbc,0x55,0x6a,0x6c,0x4e,0xf8,0x66,0x24,0xfd,0x0a,0x47,0x7f,0x96,0x7e,0xed,0xc0,0x32,0xfc,0xda,0xac,0xe7,0x96,0xc6,0x73,0xc5,0x43,0xd0,0x07,0x34,0x32,0x07,0x85,0x5b,0xeb,0xad,0x85,0xe9,0x4b,0xca,0xc7,0x78,0x2b,0x11,0x57,0x9a,0x70,0xdc,0x88,0xe2,0xa4,0x8d,0x9d,0xf2,0xd4}, {0x02,0xdb,0x21,0xb4,0x8f,0xe9,0xf9,0x95,0x08,0x3a,0x1f,0x9c,0x1f,0x3f,0x4b,0x31,0x1d,0x2c,0x43,0xa1,0x28,0xdb,0xb3,0xa4,0xd4,0x78,0x41,0xe4,0xff,0x5d,0xd0,0x2e,0x61}},\n+    {{0x5f,0xb8,0x07,0xce,0x10,0x0c,0x90,0xd2,0x83,0x7c,0xcf,0xc9,0x4d,0x8f,0x8b,0xa5,0xd3,0x5c,0xd3,0xd6,0xfa,0xfc,0xd2,0xf4,0x1f,0x24,0x5b,0x59,0x6e,0x36,0x00,0x57,0xa0,0x47,0xf8,0x31,0xef,0xf3,0x6f,0x2d,0x7c,0x83,0x30,0x36,0xb2,0x70,0x74,0x5a,0x2c,0xa3,0x2c,0x29,0x05,0x03,0x2d,0x0b,0xe0,0xdb,0xa4,0xa5,0x91,0xc9,0xfb,0xd8}, {0x03,0x41,0x58,0x28,0x65,0x43,0x5e,0xe9,0xc8,0xc9,0x27,0xc3,0x49,0xbd,0x3e,0x43,0x7b,0xce,0x2b,0x5c,0xfc,0xd0,0xc4,0x17,0x77,0xc3,0x4c,0x71,0xc6,0x7b,0x14,0x06,0x93}},\n+    {{0x1e,0x76,0x57,0x72,0xbf,0x72,0xde,0xb8,0x81,0x54,0x16,0xbd,0x54,0x45,0xdd,0x75,0x50,0xcd,0x86,0x7a,0xa2,0x5a,0xc6,0x3f,0x6f,0xd9,0xaf,0xd3,0x2f,0x92,0x1c,0xc8,0x8a,0x06,0x1a,0xb5,0xf6,0x98,0x1b,0x55,0x92,0x1b,0x90,0x5b,0x6f,0x4f,0x3d,0xf4,0x82,0x5d,0x79,0x72,0xd6,0x99,0xe3,0xb4,0x21,0x4e,0x40,0x44,0xcf,0xbe,0x65,0x34}, {0x03,0x90,0xd2,0x94,0x30,0x92,0xec,0x7e,0xd8,0xff,0x5a,0xf7,0x04,0x43,0x2d,0x0d,0xbe,0xb0,0x33,0x7c,0xbf,0x58,0x22,0x87,0x18,0x32,0x76,0x38,0x68,0x1f,0x70,0xd7,0xf0}},\n+    {{0x86,0xef,0x92,0xfd,0x28,0x09,0x85,0x4f,0x74,0xf7,0x5a,0xeb,0xbe,0xa1,0x8a,0xee,0xc0,0xee,0xdd,0x4e,0x81,0x92,0xc8,0x8c,0xd7,0xcf,0xf5,0xdf,0xc0,0x8a,0x57,0xdc,0x32,0x73,0xbf,0x6f,0x39,0x2d,0xee,0x48,0x4a,0x72,0x2c,0x3d,0xb0,0x0c,0x0e,0xfb,0x40,0xd5,0x1e,0x8a,0x72,0xfc,0xfb,0x78,0x3f,0xa7,0xeb,0xd4,0x30,0x82,0xdb,0x71}, {0x02,0x31,0x74,0x79,0x29,0x80,0x2d,0x79,0x76,0x02,0x26,0x71,0xb2,0xf7,0x5a,0xc0,0x31,0x18,0x56,0xb3,0x84,0xf4,0xb9,0xa8,0x00,0x0d,0x44,0xa2,0xab,0xc5,0x90,0x3a,0xd4}}\n+};\n+\n+void run_ellsq_tests(void) {\n+    int i = 0;\n+    /* Verify that secp256k1_ellsq_fe_to_ge_var maps everything to curve points for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {\n+        secp256k1_fe t;\n+        secp256k1_ge g;\n+        random_field_element_test(&t);\n+        secp256k1_ellsq_fe_to_ge_var(&g, &t);\n+        CHECK(secp256k1_ge_is_valid_var(&g));\n+    }\n+    /* Verify that secp256k1_ellsq_ge_to_fe_var + fe_to_ge_var roundtrips for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {",
      "path": "src/modules/ellsq/tests_impl.h",
      "position": 107,
      "original_position": 101,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 748522328,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good idea, added (slightly differently).",
      "created_at": "2021-11-16T21:06:11Z",
      "updated_at": "2021-11-16T21:06:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r750661721",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750661721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 107,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750661790",
      "pull_request_review_id": 807835585,
      "id": 750661790,
      "node_id": "PRRC_kwDOAP4Jqs4svjCe",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_TESTS_H\n+#define SECP256K1_MODULE_ELLSQ_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellsq.h\"\n+\n+struct ellsq_test {\n+    secp256k1_ge point;\n+    int enc_bitmap;\n+    secp256k1_fe encs[4];\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_test ellsq_tests[] = {\n+    {SECP256K1_GE_CONST(0xc27fb7a3, 0x283a7d3e, 0xc9f96421, 0x545ef6f5, 0x8ace7b71, 0x06c8a1b9, 0x07c0ae8a, 0x7598159c, 0xe05a060e, 0x839ef79f, 0xc0c1267c, 0xa17880c9, 0x584cdd34, 0xc05f9695, 0x55482207, 0xe6851f2a), 15, {SECP256K1_FE_CONST(0xc0ad127a, 0xa36824d6, 0x5b1f5be7, 0x4de1aa25, 0xbc4d5cbe, 0xcee15462, 0x0a12682a, 0xfc87df98), SECP256K1_FE_CONST(0xd40fd5bc, 0x51992484, 0x8f13273b, 0x1d857cba, 0x42d45e78, 0x9eaa4e47, 0xf458b83a, 0xbd5f8d1c), SECP256K1_FE_CONST(0xde636141, 0x7deb440b, 0x3a305924, 0x43635cf9, 0xcf42f9b5, 0xf5b891c1, 0x1e119f09, 0x71b570ac), SECP256K1_FE_CONST(0xd55135ce, 0x41bb4d05, 0x5b3757f4, 0xaf1d6537, 0x137376d7, 0x5270caae, 0xda68382d, 0x25d00708)}},\n+    {SECP256K1_GE_CONST(0x3f5ada4e, 0x8f646ec9, 0x10ffc1a2, 0xb74d94bb, 0xb1860631, 0xa3c2a349, 0xeddf55ca, 0xfd49cce9, 0x28ad9d8d, 0x77d9cd87, 0xf80aaa34, 0x8e9ad1b4, 0x40353d7a, 0x6e717714, 0x60425319, 0x38f530c3), 15, {SECP256K1_FE_CONST(0xac42348f, 0x1b356822, 0x5bb7d4c0, 0x0feab37e, 0xa5fb7fbb, 0x0cc3879d, 0xc74e2dda, 0xf9a393bf), SECP256K1_FE_CONST(0xda7a45b2, 0x6c87dcb6, 0x4a934c1d, 0xc841d250, 0xf98af5f0, 0x511be2a3, 0x82d17bab, 0xe1e4a533), SECP256K1_FE_CONST(0xc3d9b9a6, 0x570ca9c8, 0xa640fc75, 0x945850b2, 0xcc86b6d6, 0x399b4496, 0x4288d76d, 0x832a32d7), SECP256K1_FE_CONST(0xbf5ebc2f, 0x4060abe7, 0x884a1fa7, 0xcc0883cb, 0x97535c5a, 0x31dc6df4, 0xc6968e9d, 0x8554f3b1)}},\n+    {SECP256K1_GE_CONST(0xf5f74fab, 0x3ebbbcfd, 0xdcaef6cc, 0xd14eb934, 0xf9435a4e, 0x4a1ed2d8, 0x75352c47, 0x306d6c2f, 0xea6a5b2a, 0xe109897d, 0x046e1504, 0xf7a382d6, 0x1eb49a8a, 0xae8852ef, 0x48e29466, 0x194d9e66), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xe8362df2, 0x38e0405b, 0x49218747, 0x74f9ebca, 0x36dfe21b, 0x1a49ae2d, 0x0fa23fd4, 0x11a262a6), SECP256K1_FE_CONST(0x9e453426, 0xac973155, 0x19d11d63, 0xc3bb27ee, 0x89a7ec85, 0x5661dce4, 0xe428f6cc, 0x0be059cc)}},\n+    {SECP256K1_GE_CONST(0x977694f6, 0x6f0a3005, 0x2c638916, 0x61432fa0, 0x605528a7, 0xad87d829, 0x5c9eb9a3, 0x973c6fed, 0x16515f14, 0x00186fec, 0x67f6314c, 0x8a9e2d43, 0x3d2020e9, 0x38f86465, 0x39f749a1, 0x51a793ed), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x8f091a42, 0xce496be8, 0x877d43fc, 0x2f2b2927, 0x42c9c1fb, 0x0dfe570b, 0x9c9fbd3e, 0x04afa709), SECP256K1_FE_CONST(0xb5930cf1, 0x4db355a5, 0xa92b9f78, 0x9390b59a, 0x013c8e27, 0x7c41ddd6, 0xd8221622, 0x93d39141)}},\n+    {SECP256K1_GE_CONST(0x9c970ce9, 0x39e8a4ec, 0x70237f33, 0xad858370, 0xc9d30e8a, 0xadaac257, 0x546d1e16, 0xf374973b, 0x95755fab, 0x1bcae32e, 0xc811c63f, 0xb1e56da8, 0x97a1e140, 0xb1aae97e, 0x0b6ae6c5, 0x3879f51c), 13, {SECP256K1_FE_CONST(0xa7424f55, 0x60b58ceb, 0xbb9a6ee1, 0x5fc41b18, 0xf282b2cd, 0xd9e2fb4d, 0x02626c1a, 0xc0a89ec4), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xd7016e9b, 0x94db9b4c, 0x5bc61c87, 0xaf3b3c9c, 0x72707e5e, 0x48332958, 0xce5371bf, 0xd501a006), SECP256K1_FE_CONST(0xe95cd3a1, 0x2cff74bd, 0x6761a782, 0x61f73f0d, 0x755a80f6, 0x39ccd117, 0x136f9963, 0xf422b82a)}},\n+    {SECP256K1_GE_CONST(0x48206211, 0x5e6fc771, 0x738b4859, 0x4da66901, 0xa0a8c36e, 0xa61122b7, 0x745cf5fe, 0xec932b64, 0x01c9e1a1, 0x59effb22, 0x4442c868, 0x9119fd26, 0x8cdca070, 0x7edbefb6, 0xea81d5f6, 0x86333768), 13, {SECP256K1_FE_CONST(0xf1047fb9, 0x4cfa6dcd, 0x202e1acc, 0xa85afc88, 0x46381925, 0x7adf32aa, 0x25e19e52, 0xbf3cadd8), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x94dc1b2b, 0x6a24bbdb, 0x36afab1a, 0x6e036e7f, 0xdf1ded22, 0x915bf761, 0x97e5e5a5, 0xc6261582), SECP256K1_FE_CONST(0x8dd664ba, 0x47061bac, 0x0c99d727, 0xac2ade9f, 0xf8d33aff, 0x995a7a28, 0x97f2968c, 0x558ef724)}},\n+    {SECP256K1_GE_CONST(0x47e54d7b, 0x86025d30, 0x248b18e6, 0xc6b2b128, 0x3f8eb11e, 0x60d11cad, 0xf59884ea, 0x56939f5a, 0xb618d932, 0x6110c200, 0xcbed144f, 0xc6376800, 0xd8ba0de1, 0xd87fa02d, 0x17d1d58d, 0x9652c498),  3, {SECP256K1_FE_CONST(0x8797d6a9, 0xe3614b34, 0x80e43cb6, 0x936cd932, 0xbe4eee02, 0x1e47e067, 0x2d1d9f2f, 0xd0148558), SECP256K1_FE_CONST(0xb19c75d0, 0xb4856c81, 0xb467f8f5, 0xb9f8d849, 0x0e5296f0, 0x4c60d639, 0x6f772b7f, 0x427c5d38), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8fa5ffb5, 0x597068f6, 0x06785a63, 0x1f74cd6f, 0x8b16e94b, 0xe6cee831, 0x2970e0ec, 0xa9ecda52, 0x6c4f0efe, 0xf1d0eef2, 0xe3281b13, 0x4f29289f, 0x0a9d7b4d, 0xb3118c5f, 0x1d2d1da4, 0x75569ebf),  3, {SECP256K1_FE_CONST(0xe66995d0, 0x9cfdddda, 0xadf4b4ec, 0xc00270ed, 0xaeaacf01, 0x2db38d37, 0xe4143baf, 0x0ae7dfa3), SECP256K1_FE_CONST(0xfe0d264e, 0x3121942c, 0xd5126e26, 0x0766f36c, 0x3a08a689, 0x4e8ec172, 0xf3fdb252, 0x70def1ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x016a682d, 0x1df4f869, 0xb32c48b0, 0xa9b442a1, 0x493949fb, 0x85d951d1, 0x21c1143b, 0xd3d5c1af, 0x38d33fe5, 0xd3f9b4b9, 0x82e37dff, 0x7561428d, 0x47ef4ddf, 0x654bd959, 0x51b04e90, 0xa3be50e7),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ec42424, 0xb4d2226f, 0x83f94258, 0xc737d0da, 0xf93a4eb1, 0x1d9b9e3f, 0xd500d5b9, 0xc3aa7c71, 0x84975819, 0xb703da77, 0xca98bd3c, 0xd9bbdc7a, 0xf1dbc7b5, 0x85c590eb, 0xcbd417fd, 0x739ad572),  1, {SECP256K1_FE_CONST(0x945faa12, 0x7e8bf378, 0x63581bfb, 0xde084bf7, 0x63caee39, 0x1449c610, 0xc2074f86, 0xff1bf16c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x69ee52b2, 0x88dfb06a, 0x449d3db8, 0x7602e094, 0xb4f131e3, 0xf6a4b249, 0xdc0a76ff, 0xdebe989a, 0x3922f1a4, 0xdd208f94, 0xcbac1c5d, 0x34a9278d, 0x84310781, 0x84ff4430, 0x31a14018, 0x95ffd9e6),  1, {SECP256K1_FE_CONST(0xdc1e4760, 0x15bda784, 0xa1b9527b, 0x0357786a, 0xdf2a8028, 0x03957837, 0xe10cff92, 0x5ef4ca7e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0x3ac01550, 0x68185039, 0x6068aaf0, 0xc3f24144, 0x9a267956, 0x698833d4, 0x80c03dc5, 0x678b67cf),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9ddddd8e, 0xc1814a29, 0x3fcca202, 0xebfbe14e, 0x5d808dda, 0x142eee64, 0xc6108381, 0xe99e5cff, 0xb5072d55, 0x37223f39, 0x3e4176d2, 0xcfd93c86, 0x82ca2c22, 0xcd25ec40, 0x877296bd, 0xbb7c08f6),  3, {SECP256K1_FE_CONST(0xadd34f27, 0xc5f90171, 0x75186c23, 0xd14f6ef2, 0xaa182896, 0x77d5373a, 0xd6c31e9f, 0xf6358ae8), SECP256K1_FE_CONST(0xf5ee8614, 0x1916fe03, 0x945d028b, 0xbc354c4a, 0x09f6d6ab, 0x1468ab9a, 0xd8742075, 0x1543c2a2), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ee7e9a7, 0xfcd56edf, 0xabf3712e, 0x72cc24a3, 0x0a476f5a, 0x97f77825, 0xf0308620, 0x162f31ad, 0x77bfc7de, 0xc2401a39, 0x8c5e8675, 0x417c8a7b, 0x632f5d64, 0x2f1a5059, 0x9a830b8c, 0x7981f636),  3, {SECP256K1_FE_CONST(0xb3a8d9e7, 0x368af258, 0x3785be92, 0x2ad54dfb, 0x47329513, 0x6ade2d18, 0x2f931cd6, 0x54f35d02), SECP256K1_FE_CONST(0xe1d420e5, 0xfab5c26d, 0xf4294b2b, 0x0c19eb9a, 0x188409bf, 0x48a3741f, 0x31f72acc, 0x6ea93418), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9e24d0a5, 0xd5014164, 0x987f86bb, 0x1709305a, 0x6fd352a0, 0xa3478fae, 0x3f85e594, 0x21d72a80, 0x3729c39b, 0xbbb26d97, 0xa4ec6bf7, 0xcb4e6453, 0x058e448e, 0x7530b028, 0xd1ae345e, 0x35608d3c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x15f2f1a4, 0x339f5f2a, 0x313b9501, 0x5cad8124, 0xd054a171, 0xac2f31cf, 0x529dda7c, 0xfb6a38b4, 0xfe1d0fa5, 0x95b4f7d3, 0x63e82c29, 0x0095189f, 0x5f2be99c, 0x880be4fc, 0x9742a31b, 0x40041eda),  1, {SECP256K1_FE_CONST(0xc1c3ed27, 0x17ffabfd, 0x01132f5e, 0x54dd73c3, 0x475297e0, 0xfdbff814, 0xdc9456b8, 0x4a57b698), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd383134d, 0x721cf055, 0x143570e7, 0x82bb323d, 0x5c542a61, 0xe455823e, 0xd60b940f, 0x86826d54, 0x5a88e50b, 0x3f59874e, 0x84dab4a2, 0x07d34623, 0xd836c376, 0xc68dded3, 0xc095a716, 0xf563e4fc),  1, {SECP256K1_FE_CONST(0xe4d2660c, 0x1d50d031, 0x97f5e610, 0x4d9c2066, 0x01f6c791, 0xadb52178, 0xe2bd6c88, 0xe89cf012), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  3, {SECP256K1_FE_CONST(0xd3779b57, 0x3cb17828, 0xac118cff, 0x74412ab5, 0xb84c86f8, 0xa92f48b8, 0xefcbe4c7, 0x0a675631), SECP256K1_FE_CONST(0xea6f729d, 0xdc884123, 0xf0130aa0, 0x339bda36, 0x2166d034, 0xfe50d9d7, 0x53bf0dde, 0x7721fa3f), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x99a70224, 0xc3062c32, 0x6c45d3c6, 0x46a545e9, 0xb152b75b, 0xee868378, 0x07e47951, 0x9e5b600d, 0x95b6675a, 0x10845b66, 0x37ff96e8, 0xe67f2a75, 0xbbf0f764, 0xc56d26c5, 0x4b2db5eb, 0xb026d7de),  3, {SECP256K1_FE_CONST(0xb74a9552, 0xc5b9b6ed, 0x575d380f, 0xec3df8ed, 0xdb524ed1, 0x80b13607, 0x81e2eec6, 0x7ad06c04), SECP256K1_FE_CONST(0xbb702282, 0x4194fbe4, 0x4a74c4f4, 0xabd01ee3, 0xdac8f4cb, 0x5a0e3a67, 0xd2276039, 0xdd4aac1a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb5902433, 0x3110b310, 0x8625f254, 0x47665c1e, 0xbf10c6a6, 0xbbe9f018, 0xc421f4b0, 0xdcb5a993, 0x43bae2cd, 0xaae9c002, 0xe57ac99a, 0x17926e22, 0x76a66728, 0xf92b11bb, 0x7dc953b9, 0xea6d49b7),  3, {SECP256K1_FE_CONST(0xd5a57c1b, 0x71916606, 0xbfb235f0, 0xce8d880d, 0xe9109a01, 0xb86d58c8, 0x2852b211, 0x0e55ee0f), SECP256K1_FE_CONST(0xca6cf74b, 0x128e1d79, 0x75482bfd, 0xc9e81416, 0x71a5c3e7, 0xe2af854b, 0x23707630, 0x97ba917b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb526749e, 0x35fa04ef, 0x5d20b1d6, 0xcda6f57e, 0x2f3c10c9, 0x85098901, 0xc390da79, 0x31769e34, 0x182093b3, 0xce5883a2, 0x7b834af6, 0x18547fd1, 0x6017cee0, 0x4e9398da, 0x6aaaed2b, 0x87ca0e7c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x901c52d6, 0xa39718c7, 0x255e94e3, 0x3189cbeb, 0x41f2fa97, 0x95279076, 0xbecd6678, 0x99684c17, 0xf988a838, 0x156cc39f, 0x2182bbc5, 0xf7e4f707, 0x9cf75bfb, 0x58638cff, 0x5b201fd3, 0xcf499fc0),  1, {SECP256K1_FE_CONST(0xa356db31, 0x44b754a3, 0xdafdf2a9, 0x0767b65a, 0xbaea92ca, 0x56c69c3a, 0x31a4ff5b, 0xd7914d9c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x957d4fd4, 0x4a10f38a, 0x0d0e1e46, 0x2656dd2e, 0x7f2b6b8c, 0x9545ee02, 0x903f28b0, 0x8f9a57e7, 0x3f4bf4de, 0x3731bea3, 0x291627e3, 0x9daa7dac, 0xcdcd4e13, 0xb2418482, 0x488730b7, 0xa7a816b7),  1, {SECP256K1_FE_CONST(0xa761cd3a, 0x58385878, 0x300c6963, 0xe918b545, 0x99eb0254, 0x550f6254, 0xe414628c, 0x2f431bbd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x0a7b6db2, 0x56f01aea, 0x797a0798, 0x5eaf98d6, 0x64486f82, 0x723758bf, 0x1a5f7b00, 0xb74887e1, 0xe07ce7ec, 0x5f24b6da, 0x199329ff, 0x674788c4, 0x1b7312d4, 0xbb63672f, 0x81ebbfd3, 0x6d962235), 15, {SECP256K1_FE_CONST(0x442e15e3, 0xac31958b, 0x7acdb8b9, 0x7977b6d0, 0x533b1ef0, 0x5094f496, 0x126a04d0, 0xc6d6c327), SECP256K1_FE_CONST(0xc565d637, 0x6c8f4fa4, 0xa22ab5d4, 0xe1c87f5d, 0x6f9beb27, 0x7764a77f, 0x8ebe3796, 0xaa82cba5), SECP256K1_FE_CONST(0x2082a3b7, 0x04d3729c, 0x71a73a0c, 0xd745c7ce, 0x7a7c5e26, 0x77c688e2, 0x772806d1, 0xdd1a849f), SECP256K1_FE_CONST(0xc00c8cc3, 0x5ea8122e, 0xf17b0a8e, 0xc69218d1, 0x8cb45a3f, 0x0227a2c5, 0x68fbd9f9, 0xc6d6d141)}},\n+    {SECP256K1_GE_CONST(0x770ed6cb, 0xf6d2156b, 0x362523eb, 0xc2908f68, 0x65ab182c, 0x43468bc8, 0x69d6754e, 0x68dc71a0, 0x2a378713, 0x10223129, 0xbaba56c2, 0x0dc4a1e9, 0x634dba32, 0xa034d21f, 0x3104176b, 0x870c9916), 15, {SECP256K1_FE_CONST(0x092c79ab, 0xbbafd66d, 0x58c56208, 0x7ba5c385, 0x9fed6c1b, 0x5f8005af, 0x0087cedb, 0xec7dc084), SECP256K1_FE_CONST(0x3f5c280a, 0x60802515, 0x16dfd84a, 0x4488df47, 0x96198d5f, 0xbce0be21, 0x1ab0ee7d, 0xa456e73e), SECP256K1_FE_CONST(0x94057b6b, 0xd54b13b2, 0xe2b9d322, 0x687569f5, 0xdd16727d, 0x3d912ba3, 0xeb8aa33d, 0x36c15108), SECP256K1_FE_CONST(0x098360ae, 0xcf93979e, 0x7cd6df39, 0x6e8fe2f3, 0x18fa1da3, 0x9efa707a, 0xeab95cd8, 0xcd5dca2a)}},\n+    {SECP256K1_GE_CONST(0xab01575c, 0x0604c63e, 0xe77d3153, 0x4a5bcfa2, 0x0ce66c9d, 0xf47d6054, 0xb822bfd8, 0x6934f8ec, 0xce488d85, 0xd0875b40, 0x4fb92b6e, 0x8068602a, 0x670ac4f8, 0xd76b78b6, 0xc246b713, 0x595e226b), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4ab21b18, 0x1009aa48, 0xb8ba5eb9, 0xd373919b, 0xcfcb36a6, 0xf34961b2, 0xc859f5a8, 0x6da8ba41), SECP256K1_FE_CONST(0x9a11c401, 0x9a4ba9fc, 0xf4698a71, 0x2d85c8e4, 0x70028e02, 0x545ef049, 0xf9f3083d, 0x187c5b41)}},\n+    {SECP256K1_GE_CONST(0x6084cfdd, 0xf8d9736e, 0xa90100eb, 0xdb43338f, 0x65e2ab43, 0xef35a799, 0x926e6ce3, 0x2a89ae17, 0x753998b5, 0x9eaae7a3, 0xdcab34d9, 0xa15dbc71, 0xe539cdff, 0xdcf05927, 0x0eb27c86, 0xab6b62a4), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x18b1f707, 0x3fca3167, 0x04e1b3b8, 0x8cc8ff5a, 0x702d79bc, 0x756e4dea, 0x2ff948cc, 0xdb43a9f4), SECP256K1_FE_CONST(0xca02e589, 0x89eb16d1, 0x520463d2, 0x435745cf, 0x6e69fa52, 0x6b5c7adc, 0x57cea2b3, 0xf5a6441c)}},\n+    {SECP256K1_GE_CONST(0xc9fbac00, 0x9d8eda5d, 0x25c9aabb, 0x2b6794bc, 0x9a801afd, 0x17adef78, 0x78c65392, 0x04eb0f82, 0x95ed9e51, 0x898b903e, 0xe689e6ed, 0xff2b54bf, 0xed5c2da1, 0x69e2bdd0, 0x415a392e, 0x16b3de2b), 13, {SECP256K1_FE_CONST(0x21a95220, 0x8577e3f0, 0xcc5b4b17, 0xf5e434b2, 0x2bbdbaaa, 0x51cd2659, 0xe37880a6, 0xa25aa7dd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xcfd1ca13, 0x2f8d3eae, 0x73a97895, 0x01d2c82a, 0x6f057566, 0x7949fab9, 0x267bc1e8, 0xef9bf5bd), SECP256K1_FE_CONST(0x9cde02aa, 0x3acd2596, 0xdbea4b82, 0xf9f47ad1, 0x994ad567, 0x3c0d4fb2, 0xe8a3dca5, 0xe8e067fb)}},\n+    {SECP256K1_GE_CONST(0x8dcb38d9, 0x0059d4f1, 0x270455af, 0x6f3dd40e, 0x8d671a34, 0xa1fad81d, 0x2470db8a, 0x13b18f76, 0x603ed5be, 0x7bc3e67f, 0x439067da, 0x29949bcb, 0xd3c96c9f, 0x94da4231, 0x3c9c0feb, 0xe5cdf560), 13, {SECP256K1_FE_CONST(0x3ef4008a, 0x8a190a3f, 0x5c97d211, 0x3bb539e1, 0xf4261a78, 0xf7cd85c4, 0xfd254837, 0xeaacd020), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x0fe7af4f, 0xcab80199, 0x37ee0026, 0x47d55d97, 0x575474b3, 0x4b9cc1bb, 0x133f4261, 0x017124a0), SECP256K1_FE_CONST(0x09dcec3b, 0x93c4ab42, 0x91d01dce, 0xccc19525, 0xc801add3, 0x77170c2c, 0x919f5488, 0xf41d6d3e)}},\n+    {SECP256K1_GE_CONST(0xf69dfe44, 0x890d2b09, 0x4b749a56, 0xf680e851, 0x50c47c4c, 0xd51e7796, 0x3fec4e6a, 0x09dcd0a1, 0xfb5d321c, 0x1e243b63, 0x6dfb71f3, 0xcf0e8a01, 0x2e52b22c, 0x905cec6d, 0x2f6ae32a, 0x6a4eb7be),  3, {SECP256K1_FE_CONST(0xa17fd528, 0x7276cbf6, 0xc168dcde, 0xb32aba14, 0xe1aeae2f, 0xe7f5bea5, 0xa87d384e, 0xe8046aac), SECP256K1_FE_CONST(0x637f176a, 0xf2fe854a, 0x968ab19b, 0xee010554, 0x313e3eff, 0xc6ff8cb4, 0xcb538a6d, 0xbaedd954), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x043a0631, 0x871a3f67, 0xac03c5f8, 0x406b69a0, 0xdc14bd5b, 0x23e55f27, 0xa5d4462b, 0x0f0a2d23, 0x247b9bcc, 0x0019091c, 0x31eb4b03, 0xe731a0b5, 0xa9b33f75, 0xad9e5e63, 0x39286573, 0xa6439d88),  3, {SECP256K1_FE_CONST(0xd65add13, 0xad3044d9, 0x2ebcd0e6, 0xd42853d8, 0xe5733ff6, 0x5297f544, 0x09a3ce89, 0xfdaffbdc), SECP256K1_FE_CONST(0x7281ad3c, 0x85de3870, 0x84f64e14, 0x42b37154, 0xeab39453, 0x8b1c0753, 0x4b303ae7, 0x37f3973e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8855508a, 0xade16ec5, 0x73d21e6a, 0x485dfd0a, 0x7624085c, 0x1a14b5ec, 0xdd6485de, 0x0c6839a4, 0xe50aaeba, 0xa0ceceec, 0xa1bce62e, 0x5f0fac4b, 0xe78ab03a, 0x7b2deaa6, 0xe5c17e88, 0x98e277e9),  1, {SECP256K1_FE_CONST(0x4e96da73, 0xae14fc85, 0x25eccb2d, 0xf4416924, 0x8a7fd269, 0xa065e065, 0x04d315e6, 0x63666b03), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xc66327bc, 0x5b0b8b90, 0x37adfd63, 0xc2a9f192, 0x2ce2144a, 0xa513b390, 0xd48bc387, 0xae3ebff6, 0x17a1ca89, 0x64eb0b41, 0x162894e6, 0x4fb4112b, 0x638f96ec, 0xe0c6f30d, 0xef7616fe, 0x0e78386a),  1, {SECP256K1_FE_CONST(0x56e8e17e, 0xfaf989d6, 0xa7efb81d, 0x5a602393, 0x6814930e, 0xbc3f6fdf, 0x72ebf472, 0x69ba4c9a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0xc53feaaf, 0x97e7afc6, 0x9f97550f, 0x3c0dbebb, 0x65d986a9, 0x9677cc2b, 0x7f3fc239, 0x98749460),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9d709c02, 0x74604cb6, 0x3b531fea, 0x35932e2e, 0xc965f4bf, 0x5913e577, 0xff31080b, 0x67727a2e, 0xf2b0b821, 0xa24081a9, 0xd0ca84d9, 0x303068cf, 0x7ea32788, 0x05926b0a, 0xb90b9af7, 0x498efbd5),  3, {SECP256K1_FE_CONST(0xb06abefa, 0x192a6498, 0xbce368ff, 0xacc843fb, 0xb39f8117, 0xa56a1870, 0xf57197ef, 0xd9312f6d), SECP256K1_FE_CONST(0x1263d142, 0xaac9cfc5, 0x64c56650, 0x0fa4a62f, 0x38e727fb, 0xb4dbeaf2, 0x6fdf7d05, 0xfd022c71), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb4955dcb, 0x4daaa784, 0x9b421c14, 0x53ec8945, 0xd685d554, 0xf41103f8, 0x12cbfb2f, 0x54a4539b, 0x354d18e4, 0xb1cee7a3, 0xf98b0651, 0xf5544091, 0xe8a00656, 0x0c74750d, 0xaadf460e, 0xc3f620ea),  3, {SECP256K1_FE_CONST(0x6281a8a7, 0x0a3b5745, 0xb897ce4f, 0x58305fb0, 0xd6a0f8ab, 0xa6c5ba18, 0xed278ce1, 0x50f7911c), SECP256K1_FE_CONST(0x5f95a708, 0x2d2f6d69, 0xf7ff9b74, 0x2b88063c, 0x39a3003b, 0xb03f333c, 0x7e3d7c5e, 0xd861fb04), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x6ad63dfd, 0xcd231967, 0xff2508f4, 0x75896976, 0xf8728e40, 0xdd7a2acc, 0x6b5ced37, 0xcada8291, 0xf93e5181, 0x8f5329b8, 0xd520a9af, 0xd72938e1, 0x2e3f8be6, 0x421d2bce, 0x89d7b14e, 0x25bf5336),  1, {SECP256K1_FE_CONST(0x0f050318, 0x622f79f1, 0x5a2b23d9, 0xf76329b7, 0x8e195f1a, 0x4651aae0, 0x65d58bcd, 0xdfa4d3b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa91b7f2a, 0xb93de821, 0xabeec175, 0x0258e4d4, 0xf5f09831, 0xb0a11dda, 0x47e89ddf, 0x6944d819, 0x22eb9bf6, 0x4a517df2, 0xc27d1c55, 0x1df07609, 0x166fc995, 0xe2b39fee, 0x0473ea46, 0xed14efc1),  1, {SECP256K1_FE_CONST(0x7a01651a, 0x81a7f09e, 0x2733cf34, 0x9e6472a1, 0x18c16780, 0x6f5c880f, 0x534b89a6, 0x52be06a7), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  3, {SECP256K1_FE_CONST(0x2c8864a8, 0xc34e87d7, 0x53ee7300, 0x8bbed54a, 0x47b37907, 0x56d0b747, 0x10341b37, 0xf598a5fe), SECP256K1_FE_CONST(0x15908d62, 0x2377bedc, 0x0fecf55f, 0xcc6425c9, 0xde992fcb, 0x01af2628, 0xac40f220, 0x88de01f0), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa64de96a, 0x6254cefc, 0xffbeaf89, 0x8f2c228a, 0xf6d405f3, 0xbcc6a4cc, 0xe068312a, 0xf7ccf8e1, 0x8f9b3a1b, 0x2d146ea9, 0x54bfc5e2, 0xcdfe861c, 0xcbed8431, 0xc741c5f9, 0xd32f16a3, 0x073ea496),  3, {SECP256K1_FE_CONST(0x4591d33d, 0x1a133a87, 0x94689b1b, 0x0ca445b7, 0x8ada3bce, 0xc2e812b0, 0x8315e2b1, 0x07940ad4), SECP256K1_FE_CONST(0xa763d217, 0x6027d40e, 0x8a8ff34b, 0xd9c639b7, 0x3e2ea045, 0x92274fdc, 0xfa4051c6, 0x6d93a1b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x49a0dc06, 0x8c3f117a, 0xefdc842d, 0x3d358153, 0xf677f04c, 0x6dabc9c9, 0x1b09d452, 0xfef27b66, 0x7b944da4, 0x8a175dbc, 0x444ead8d, 0xb82eff66, 0xb081a8aa, 0xe6453fed, 0x2bca9720, 0xb44dd6e5),  3, {SECP256K1_FE_CONST(0x7bf1e2b1, 0x720c1c44, 0x0db64687, 0xf16439fa, 0x41b39833, 0x8095f24e, 0xbeec0cfa, 0x88750dc9), SECP256K1_FE_CONST(0xdc97e26d, 0x3137445d, 0x6c1269b6, 0x1a765501, 0x0c19c36a, 0x2e361066, 0xe31e2bb1, 0x0403470b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd09a4047, 0xf158fe52, 0xf96c661d, 0x02c68657, 0xc4c976ea, 0x96ea85ef, 0x46d6985b, 0xd540756b, 0xe793bfaa, 0xe9300f18, 0xe6f9b55a, 0xae263223, 0x68b61d51, 0xae5022ef, 0xe266c72d, 0x574178bc),  1, {SECP256K1_FE_CONST(0x7e6175fd, 0xfbb9fb4f, 0xaf6e2b92, 0x5ef86c4a, 0x444d819a, 0xaa82dbee, 0x545d3d9b, 0x296375be), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x34986625, 0x04b73c7c, 0x8cecb6c3, 0x3cd493bd, 0xfc190e0f, 0x87d913d7, 0xff9ad42e, 0x222bfe95, 0x245b3a61, 0xb8d46997, 0xf14f2fea, 0x28748996, 0x91eb3254, 0x2b9907d6, 0x5eb9d21d, 0x42454021),  1, {SECP256K1_FE_CONST(0x7f556282, 0xc3dd9d26, 0x3390d6bb, 0xddada698, 0xab8fd7c7, 0xd1a06498, 0xf42b3043, 0x7c8361ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}}\n+};\n+\n+struct ellsq_enc_test {\n+    unsigned char ell64[64];\n+    unsigned char pubkey[33];\n+};\n+\n+/* Set of (ell64, point) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_enc_test ellsq_enc_tests[] = {\n+    {{0x54,0xca,0xd2,0x27,0xb2,0xc9,0x8d,0x5f,0x7c,0x78,0x8c,0xfc,0x3d,0xaf,0xd6,0x52,0xf5,0x8f,0x69,0xcf,0xef,0x63,0x2b,0x82,0x2b,0x35,0xd0,0xb0,0xe2,0x4f,0xc0,0x3a,0xd2,0x8c,0xa1,0x4b,0x6f,0x62,0xd4,0x53,0x79,0xc5,0x3f,0x70,0xee,0x40,0x5c,0xa9,0x2c,0xe7,0xb6,0xf9,0x70,0x83,0x13,0x05,0xf2,0x7d,0xc4,0x1e,0xb6,0x9d,0xe0,0x6e}, {0x02,0x11,0x62,0x89,0x03,0x32,0x88,0x91,0xae,0x09,0xd1,0x08,0xd8,0x92,0x43,0xe4,0x7e,0x10,0x9f,0xe7,0xb8,0xbb,0x1e,0x2d,0xf1,0xa3,0xae,0x9b,0x0e,0x78,0x08,0x54,0x9c}},\n+    {{0xfb,0xe6,0xce,0xab,0x4c,0x5f,0xdf,0xa5,0xfb,0xee,0x8f,0x3d,0x09,0xa2,0xf7,0x23,0x53,0xe7,0x4e,0x5a,0x9c,0xd4,0xab,0x8e,0x6a,0x34,0xd4,0x95,0x23,0xa7,0xd1,0xa2,0xc4,0x50,0xb7,0x45,0xda,0xb1,0xaf,0xa9,0x95,0x4b,0x3a,0x35,0x75,0xe4,0xe8,0xe2,0xdb,0x3d,0xa5,0xcd,0x4d,0x56,0x48,0xea,0xd0,0x0a,0x60,0xb4,0xcd,0xfe,0x84,0xb3}, {0x02,0xc0,0x4c,0x84,0x85,0xf9,0x8d,0x56,0x6c,0x79,0xbf,0x33,0xa7,0x0c,0xb2,0x32,0x54,0x9e,0x3d,0xe1,0xc3,0xe3,0x01,0xe3,0x57,0x1c,0x83,0x68,0x97,0xf0,0x7c,0x5d,0x12}},\n+    {{0x71,0x7e,0x63,0xd7,0x71,0xdb,0xda,0x67,0x67,0xd5,0x8f,0x26,0xab,0x5f,0x54,0x9b,0xd2,0xd1,0x8a,0xcf,0x59,0xff,0x50,0x77,0x5f,0x4e,0xb5,0x0a,0xc0,0x17,0x4d,0xf1,0x7d,0xd0,0x34,0xc8,0xed,0x08,0x11,0x61,0x5e,0x3e,0xbb,0x36,0xf8,0xf3,0x3e,0x09,0x23,0x8e,0x4d,0xa8,0xf5,0x01,0x9d,0x37,0x00,0x78,0x4f,0x37,0xc1,0x53,0x53,0x94}, {0x02,0x72,0x81,0x15,0x0c,0xeb,0xc3,0xd7,0xb3,0xbb,0xb9,0x92,0xf5,0x81,0xbb,0xcb,0x9e,0x30,0x4f,0x87,0x44,0xf0,0x19,0x98,0xa7,0x1f,0x5d,0xe1,0x14,0xf8,0x22,0x91,0xc4}},\n+    {{0x01,0xf0,0xbf,0xe4,0xf9,0xbd,0xee,0x52,0x5e,0xb7,0x7c,0x8e,0x35,0x1e,0x1f,0x88,0x3f,0xb9,0xcd,0x37,0x7e,0xf7,0xc5,0xbd,0xde,0xe4,0xf6,0x60,0x64,0x43,0x90,0xf5,0x95,0x3e,0x7d,0x2b,0x6c,0xde,0x36,0x90,0x3e,0xa1,0x34,0x4b,0x0d,0x16,0x33,0x5c,0xc5,0x11,0x5d,0xaa,0x97,0x7c,0x3c,0x2b,0xf9,0x31,0xac,0xde,0x2f,0xf5,0x78,0x9a}, {0x02,0x10,0x44,0x9d,0x7e,0xa0,0x62,0x3e,0x80,0xa5,0x87,0x01,0x9f,0xa5,0x11,0xaf,0xd3,0x94,0xb2,0x55,0xb0,0x8f,0x91,0xb5,0xf7,0x48,0x2a,0xe9,0xd1,0xa1,0xa7,0xfb,0x7c}},\n+    {{0x82,0xd5,0x87,0x1e,0x18,0x37,0x66,0xbd,0x22,0xe1,0x13,0xa8,0x52,0x79,0xaa,0x61,0x7e,0x6b,0x9f,0x73,0x52,0x2c,0xd4,0x6b,0x90,0x59,0xba,0x51,0x97,0xfa,0x56,0x44,0xaf,0x90,0x41,0x89,0x30,0x98,0x7d,0xb7,0xab,0x4a,0x84,0x0c,0x72,0x64,0x1b,0x58,0xb3,0x66,0xe5,0x7c,0x92,0x8c,0x98,0x3a,0x47,0x37,0x82,0x00,0x3c,0x36,0x10,0xab}, {0x03,0xc8,0xb2,0x62,0xf9,0x31,0x69,0x43,0x75,0x51,0x48,0x3b,0x8a,0x61,0x19,0x83,0x82,0xe3,0x11,0x41,0xaf,0x61,0xbf,0x36,0x10,0x0b,0xd0,0x68,0x46,0x5d,0xdd,0xa8,0x40}},\n+    {{0xda,0x82,0x53,0xb4,0x3b,0x5a,0xc2,0x3b,0x42,0x36,0x07,0xe9,0x18,0xab,0x5c,0xaa,0x5d,0x7d,0x34,0x3d,0x77,0xa3,0x99,0x6a,0x42,0xeb,0x33,0x2a,0x3b,0x55,0x1d,0x8c,0xda,0x6c,0xb6,0xf9,0x57,0x4c,0xe3,0x60,0x91,0x2c,0xf4,0x5b,0x90,0x9a,0x96,0x2e,0x4d,0xed,0x63,0xae,0x5a,0xac,0xb0,0xab,0x23,0x29,0x45,0xb1,0x01,0xf7,0x2b,0x62}, {0x02,0xe7,0x28,0x34,0x1d,0xf6,0x93,0x48,0x71,0xb3,0x94,0xbb,0x4f,0xb2,0x8b,0xd8,0xd2,0xdf,0x39,0x92,0x55,0xb0,0x30,0x02,0xed,0x6f,0xc3,0x8f,0x28,0xcf,0xbf,0x53,0x56}},\n+    {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x03,0x1b,0x41,0x2e,0x7a,0x96,0x6d,0x2c,0x24,0x3d,0xbc,0x5b,0x18,0xb7,0xf9,0xba,0xf1,0x85,0xbc,0xfe,0x41,0x38,0x96,0x04,0x79,0x64,0x1a,0xb1,0xe6,0x3b,0x38,0x1e,0x11}},\n+    {{0xdc,0x30,0x98,0xe4,0x00,0x61,0x83,0x30,0xf3,0x8b,0x19,0xe9,0x20,0x0a,0xdf,0x7f,0xfb,0x96,0x84,0x3f,0xa8,0x3c,0x49,0x1c,0xf6,0x7f,0x34,0xa7,0x90,0xbb,0xcf,0xe1,0x23,0xdc,0x30,0x07,0xa4,0xfd,0x13,0x3a,0x39,0x44,0x0b,0x06,0x03,0x1e,0x9e,0x2c,0x38,0x8e,0x41,0x47,0xaf,0x0e,0x82,0xbe,0xda,0x6d,0x56,0x4b,0xf8,0xcc,0x37,0xb1}, {0x02,0x5b,0x74,0x48,0x15,0x22,0xd4,0xc2,0x9f,0x2e,0x6a,0x2f,0x11,0x7f,0x9e,0x39,0xf9,0xab,0x01,0xb1,0xe9,0xf2,0xc3,0x4c,0x68,0xbe,0x8f,0x53,0x1b,0xe0,0x1f,0x6e,0xa7}},\n+    {{0x35,0xd7,0x0a,0x71,0x2c,0xc0,0x85,0x7f,0x8d,0xb1,0xbc,0x55,0x6a,0x6c,0x4e,0xf8,0x66,0x24,0xfd,0x0a,0x47,0x7f,0x96,0x7e,0xed,0xc0,0x32,0xfc,0xda,0xac,0xe7,0x96,0xc6,0x73,0xc5,0x43,0xd0,0x07,0x34,0x32,0x07,0x85,0x5b,0xeb,0xad,0x85,0xe9,0x4b,0xca,0xc7,0x78,0x2b,0x11,0x57,0x9a,0x70,0xdc,0x88,0xe2,0xa4,0x8d,0x9d,0xf2,0xd4}, {0x02,0xdb,0x21,0xb4,0x8f,0xe9,0xf9,0x95,0x08,0x3a,0x1f,0x9c,0x1f,0x3f,0x4b,0x31,0x1d,0x2c,0x43,0xa1,0x28,0xdb,0xb3,0xa4,0xd4,0x78,0x41,0xe4,0xff,0x5d,0xd0,0x2e,0x61}},\n+    {{0x5f,0xb8,0x07,0xce,0x10,0x0c,0x90,0xd2,0x83,0x7c,0xcf,0xc9,0x4d,0x8f,0x8b,0xa5,0xd3,0x5c,0xd3,0xd6,0xfa,0xfc,0xd2,0xf4,0x1f,0x24,0x5b,0x59,0x6e,0x36,0x00,0x57,0xa0,0x47,0xf8,0x31,0xef,0xf3,0x6f,0x2d,0x7c,0x83,0x30,0x36,0xb2,0x70,0x74,0x5a,0x2c,0xa3,0x2c,0x29,0x05,0x03,0x2d,0x0b,0xe0,0xdb,0xa4,0xa5,0x91,0xc9,0xfb,0xd8}, {0x03,0x41,0x58,0x28,0x65,0x43,0x5e,0xe9,0xc8,0xc9,0x27,0xc3,0x49,0xbd,0x3e,0x43,0x7b,0xce,0x2b,0x5c,0xfc,0xd0,0xc4,0x17,0x77,0xc3,0x4c,0x71,0xc6,0x7b,0x14,0x06,0x93}},\n+    {{0x1e,0x76,0x57,0x72,0xbf,0x72,0xde,0xb8,0x81,0x54,0x16,0xbd,0x54,0x45,0xdd,0x75,0x50,0xcd,0x86,0x7a,0xa2,0x5a,0xc6,0x3f,0x6f,0xd9,0xaf,0xd3,0x2f,0x92,0x1c,0xc8,0x8a,0x06,0x1a,0xb5,0xf6,0x98,0x1b,0x55,0x92,0x1b,0x90,0x5b,0x6f,0x4f,0x3d,0xf4,0x82,0x5d,0x79,0x72,0xd6,0x99,0xe3,0xb4,0x21,0x4e,0x40,0x44,0xcf,0xbe,0x65,0x34}, {0x03,0x90,0xd2,0x94,0x30,0x92,0xec,0x7e,0xd8,0xff,0x5a,0xf7,0x04,0x43,0x2d,0x0d,0xbe,0xb0,0x33,0x7c,0xbf,0x58,0x22,0x87,0x18,0x32,0x76,0x38,0x68,0x1f,0x70,0xd7,0xf0}},\n+    {{0x86,0xef,0x92,0xfd,0x28,0x09,0x85,0x4f,0x74,0xf7,0x5a,0xeb,0xbe,0xa1,0x8a,0xee,0xc0,0xee,0xdd,0x4e,0x81,0x92,0xc8,0x8c,0xd7,0xcf,0xf5,0xdf,0xc0,0x8a,0x57,0xdc,0x32,0x73,0xbf,0x6f,0x39,0x2d,0xee,0x48,0x4a,0x72,0x2c,0x3d,0xb0,0x0c,0x0e,0xfb,0x40,0xd5,0x1e,0x8a,0x72,0xfc,0xfb,0x78,0x3f,0xa7,0xeb,0xd4,0x30,0x82,0xdb,0x71}, {0x02,0x31,0x74,0x79,0x29,0x80,0x2d,0x79,0x76,0x02,0x26,0x71,0xb2,0xf7,0x5a,0xc0,0x31,0x18,0x56,0xb3,0x84,0xf4,0xb9,0xa8,0x00,0x0d,0x44,0xa2,0xab,0xc5,0x90,0x3a,0xd4}}\n+};\n+\n+void run_ellsq_tests(void) {\n+    int i = 0;\n+    /* Verify that secp256k1_ellsq_fe_to_ge_var maps everything to curve points for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {\n+        secp256k1_fe t;\n+        secp256k1_ge g;\n+        random_field_element_test(&t);\n+        secp256k1_ellsq_fe_to_ge_var(&g, &t);\n+        CHECK(secp256k1_ge_is_valid_var(&g));",
      "path": "src/modules/ellsq/tests_impl.h",
      "position": 99,
      "original_position": 98,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 748520983,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good idea, done.",
      "created_at": "2021-11-16T21:06:19Z",
      "updated_at": "2021-11-16T21:06:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r750661790",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750661790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 99,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750671994",
      "pull_request_review_id": 807849653,
      "id": 750671994,
      "node_id": "PRRC_kwDOAP4Jqs4svlh6",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 277,
      "original_position": 277,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 749423567,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`secp256k1_pubkey_load` can actually return 0, through its `ARG_CHECK` macro.",
      "created_at": "2021-11-16T21:22:23Z",
      "updated_at": "2021-11-16T21:22:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r750671994",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750671994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750711426",
      "pull_request_review_id": 807902347,
      "id": 750711426,
      "node_id": "PRRC_kwDOAP4Jqs4svvKC",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 277,
      "original_position": 277,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 749423567,
      "user": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh nice, I missed that.\r\n\r\nDo we want more strict checks here than `ARG_CHECK(!secp256k1_fe_is_zero(&ge->x))`? For example the following passes, but I wouldn't expect 1000 randomly generate 64-byte strings to all produce valid pubkeys:\r\n\r\n```c\r\n        int N = 1000;\r\n        int j = 0, success = 0;\r\n        secp256k1_ge g;\r\n        secp256k1_pubkey pubkey;\r\n        secp256k1_testrand256(pubkey.data);\r\n        secp256k1_testrand256(pubkey.data + 32);\r\n        for (j = 0; j < N; j++) {\r\n            if (secp256k1_pubkey_load(ctx, &g, &pubkey)) success++;\r\n        }\r\n        CHECK(success == N);\r\n```",
      "created_at": "2021-11-16T22:25:58Z",
      "updated_at": "2021-11-16T22:27:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r750711426",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750711426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750713182",
      "pull_request_review_id": 807904594,
      "id": 750713182,
      "node_id": "PRRC_kwDOAP4Jqs4svvle",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;",
      "path": "src/modules/ellsq/main_impl.h",
      "position": 277,
      "original_position": 277,
      "commit_id": "d4cbedc023ab921631723a37ea8052d48b1c4537",
      "original_commit_id": "7b1e6260e215174561a2d1fdd7f500ba6eaf1489",
      "in_reply_to_id": 749423567,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think that's needed. That check is a last-resort sanity check (several functions will set pubkeys on output to all-zeros when they return failure). Triggering that situation implies you're already using the API incorrectly; a `secp256k1_pubkey` object must contain a valid public key, in normal usage.",
      "created_at": "2021-11-16T22:28:55Z",
      "updated_at": "2021-11-16T22:28:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/982#discussion_r750713182",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/750713182"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/982"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    }
  ]
}