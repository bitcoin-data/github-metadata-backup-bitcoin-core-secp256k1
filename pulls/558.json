{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558",
    "id": 218025785,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MjE4MDI1Nzg1",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/558.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/558.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
    "number": 558,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": " Add schnorrsig module which implements BIP-340 compliant signatures",
    "user": {
      "login": "jonasnick",
      "id": 2582071,
      "node_id": "MDQ6VXNlcjI1ODIwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasnick",
      "html_url": "https://github.com/jonasnick",
      "followers_url": "https://api.github.com/users/jonasnick/followers",
      "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasnick/orgs",
      "repos_url": "https://api.github.com/users/jonasnick/repos",
      "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jonasnick/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR implements signing, verification and batch verification as described in [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) in an experimental module named `schnorrsig`. It includes the test vectors and a benchmarking tool. \r\nThis PR also adds a module `extrakeys` that allows [BIP-341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)-style key tweaking.\r\n\r\n(Adding ChaCha20 as a CSPRNG and batch verification was moved to PR #760).\r\n\r\nIn order to enable the module run `./configure` with `--enable-experimental --enable-module-schnorrsig`.\r\n\r\nBased on apoelstra's work.\r\n",
    "labels": [],
    "created_at": "2018-09-25T15:33:00Z",
    "updated_at": "2020-09-19T13:54:56Z",
    "closed_at": "2020-09-11T19:26:27Z",
    "mergeable_state": "unknown",
    "merged_at": "2020-09-11T19:26:27Z",
    "merge_commit_sha": "8ab24e8dad9d43fc6661842149899e3cc9213b24",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "jonasnick:schnorrsig",
      "ref": "schnorrsig",
      "sha": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 57937974,
        "node_id": "MDEwOlJlcG9zaXRvcnk1NzkzNzk3NA==",
        "name": "secp256k1",
        "full_name": "jonasnick/secp256k1",
        "owner": {
          "login": "jonasnick",
          "id": 2582071,
          "node_id": "MDQ6VXNlcjI1ODIwNzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/jonasnick",
          "html_url": "https://github.com/jonasnick",
          "followers_url": "https://api.github.com/users/jonasnick/followers",
          "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
          "organizations_url": "https://api.github.com/users/jonasnick/orgs",
          "repos_url": "https://api.github.com/users/jonasnick/repos",
          "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/jonasnick/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/jonasnick/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/jonasnick/secp256k1",
        "archive_url": "https://api.github.com/repos/jonasnick/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/jonasnick/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/jonasnick/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/jonasnick/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/jonasnick/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/jonasnick/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/jonasnick/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/jonasnick/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/jonasnick/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/jonasnick/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/jonasnick/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/jonasnick/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/jonasnick/secp256k1/events",
        "forks_url": "https://api.github.com/repos/jonasnick/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/jonasnick/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/jonasnick/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/jonasnick/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/jonasnick/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/jonasnick/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/jonasnick/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/jonasnick/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/jonasnick/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/jonasnick/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/jonasnick/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/jonasnick/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/jonasnick/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/jonasnick/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/jonasnick/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/jonasnick/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:jonasnick/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/jonasnick/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/jonasnick/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/jonasnick/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/jonasnick/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/jonasnick/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/jonasnick/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/jonasnick/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/jonasnick/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/jonasnick/secp256k1/hooks",
        "svn_url": "https://github.com/jonasnick/secp256k1",
        "language": "C",
        "forks_count": 4,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 11430,
        "default_branch": "master",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-05-24T13:49:16Z",
        "created_at": "2016-05-03T03:14:21Z",
        "updated_at": "2023-03-16T11:44:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "f49c9896b0d03d7dc45515260760659879c5728e",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 948,
        "stargazers_count": 1768,
        "watchers_count": 1768,
        "size": 10062,
        "default_branch": "master",
        "open_issues_count": 142,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-12T16:38:48Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-06-12T17:38:13Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 2445,
    "deletions": 31,
    "changed_files": 20,
    "commits": 15,
    "review_comments": 440,
    "comments": 105
  },
  "events": [
    {
      "event": "mentioned",
      "id": 1866099328,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTg2NjA5OTMyOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1866099328",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-25T15:33:00Z"
    },
    {
      "event": "subscribed",
      "id": 1866099329,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDE4NjYwOTkzMjk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1866099329",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-25T15:33:00Z"
    },
    {
      "event": "reviewed",
      "id": 158625323,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4NjI1MzIz",
      "url": null,
      "actor": null,
      "commit_id": "ff3a22d1478b1ba364988d4cef52384e830d0f8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "DesWurstes",
        "id": 23437045,
        "node_id": "MDQ6VXNlcjIzNDM3MDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23437045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DesWurstes",
        "html_url": "https://github.com/DesWurstes",
        "followers_url": "https://api.github.com/users/DesWurstes/followers",
        "following_url": "https://api.github.com/users/DesWurstes/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DesWurstes/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DesWurstes/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DesWurstes/subscriptions",
        "organizations_url": "https://api.github.com/users/DesWurstes/orgs",
        "repos_url": "https://api.github.com/users/DesWurstes/repos",
        "events_url": "https://api.github.com/users/DesWurstes/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DesWurstes/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-158625323",
      "submitted_at": "2018-09-25T16:13:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1866275799,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTg2NjI3NTc5OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1866275799",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-25T16:40:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1866303859,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTg2NjMwMzg1OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1866303859",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-25T16:53:11Z"
    },
    {
      "event": "commented",
      "id": 424420460,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDQyMDQ2MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/424420460",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-25T16:54:22Z",
      "updated_at": "2018-09-25T16:54:22Z",
      "author_association": "MEMBER",
      "body": "Replaced the chacha20 commit with a similar commit from secp256k1-zkp (ElementsProject/secp256k1-zkp@c3794f9).",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-424420460",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 1868700900,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTg2ODcwMDkwMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1868700900",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-26T15:07:49Z"
    },
    {
      "event": "subscribed",
      "id": 1868700901,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDE4Njg3MDA5MDE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1868700901",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-26T15:07:49Z"
    },
    {
      "event": "reviewed",
      "id": 159048933,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU5MDQ4OTMz",
      "url": null,
      "actor": null,
      "commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-159048933",
      "submitted_at": "2018-09-26T15:07:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 159072126,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU5MDcyMTI2",
      "url": null,
      "actor": null,
      "commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-159072126",
      "submitted_at": "2018-09-26T15:53:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 424770793,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDc3MDc5Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/424770793",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-26T15:58:38Z",
      "updated_at": "2018-09-26T15:58:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK except nit about `sha` object, bikeshedding about the module name, and also I did not check that the static test vectors match those in the BIP.",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-424770793",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 425683889,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTY4Mzg4OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/425683889",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-09-30T00:19:53Z",
      "updated_at": "2018-09-30T00:19:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "Maybe we should consider adopting an anti-covert-channel warden workflow as the standard interface for this function?",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-425683889",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 160122617,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwMTIyNjE3",
      "url": null,
      "actor": null,
      "commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Nice! Such hype.\r\n\r\nI skipped the tests, hoping to get back around to them.",
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-160122617",
      "submitted_at": "2018-09-30T19:50:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 425962058,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTk2MjA1OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/425962058",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-01T15:59:31Z",
      "updated_at": "2018-10-01T15:59:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "@gmaxwell By anti-covert channel do you mean essentially sign-to-contracting random data? I would like this. One thing blocking it is that our nonce function does not take a secp context currently, which makes sign-to-contract unergonmic -- see [in sighacker how the sign-to-contract context needs to contain a pointer to the secp context](https://github.com/apoelstra/sighacker/blob/master/src/s2c.h#L6-L11).\r\n\r\nI think we should fix that but it should probably be in another PR.",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-425962058",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 1877126546,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTg3NzEyNjU0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1877126546",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-01T15:59:31Z"
    },
    {
      "event": "subscribed",
      "id": 1877126547,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDE4NzcxMjY1NDc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1877126547",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-01T15:59:31Z"
    },
    {
      "event": "commented",
      "id": 426196984,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjE5Njk4NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/426196984",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-02T08:47:02Z",
      "updated_at": "2018-10-02T08:47:02Z",
      "author_association": "MEMBER",
      "body": "Thanks @jimpo. I added a commit that addresses your comments.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-426196984",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 1878710498,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTg3ODcxMDQ5OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1878710498",
      "actor": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-02T08:47:02Z"
    },
    {
      "event": "subscribed",
      "id": 1878710500,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDE4Nzg3MTA1MDA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1878710500",
      "actor": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-02T08:47:02Z"
    },
    {
      "event": "commented",
      "id": 428015985,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyODAxNTk4NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/428015985",
      "actor": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-08T23:59:32Z",
      "updated_at": "2018-10-08T23:59:32Z",
      "author_association": "NONE",
      "body": "how does this relate to https://github.com/bitcoin-core/secp256k1/pull/212 ?",
      "user": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-428015985",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 428019534,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyODAxOTUzNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/428019534",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-09T00:21:02Z",
      "updated_at": "2018-10-09T00:21:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "#212 is not secure against rogue-key attacks nor does it commit to the public key being signed for.",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-428019534",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 428023591,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyODAyMzU5MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/428023591",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-09T00:48:20Z",
      "updated_at": "2018-10-09T00:48:20Z",
      "author_association": "MEMBER",
      "body": "and #212 was removed in #425",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-428023591",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 429264629,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyOTI2NDYyOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/429264629",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-12T09:28:55Z",
      "updated_at": "2018-10-12T09:28:55Z",
      "author_association": "MEMBER",
      "body": "Oh I was not aware of this PR.\r\nFYI, I suggested that a CSPRNG is not enough for batch validation and we need a hash function to generate the seed (https://github.com/sipa/bips/pull/15/files) but now I see that this PR is doing that anyway. :)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-429264629",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 164173997,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0MTczOTk3",
      "url": null,
      "actor": null,
      "commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-164173997",
      "submitted_at": "2018-10-12T11:51:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 429862591,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQyOTg2MjU5MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/429862591",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-15T13:57:36Z",
      "updated_at": "2018-10-15T13:57:36Z",
      "author_association": "MEMBER",
      "body": "@real-or-random Thanks for the review. I added a commit to address your comments.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-429862591",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 1904165648,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTkwNDE2NTY0OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1904165648",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-15T13:57:36Z"
    },
    {
      "event": "subscribed",
      "id": 1904165649,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDE5MDQxNjU2NDk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1904165649",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-15T13:57:36Z"
    },
    {
      "event": "mentioned",
      "id": 1906337521,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTkwNjMzNzUyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1906337521",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-16T09:57:07Z"
    },
    {
      "event": "subscribed",
      "id": 1906337522,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDE5MDYzMzc1MjI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1906337522",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-16T09:57:07Z"
    },
    {
      "event": "reviewed",
      "id": 165077679,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MDc3Njc5",
      "url": null,
      "actor": null,
      "commit_id": "40f8f7a44cf6fafa7a7299bf3cd0432da8635414",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-165077679",
      "submitted_at": "2018-10-16T09:57:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1907271875,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTkwNzI3MTg3NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1907271875",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-16T16:06:39Z"
    },
    {
      "event": "commented",
      "id": 432681178,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQzMjY4MTE3OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/432681178",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-10-24T14:29:58Z",
      "updated_at": "2018-10-24T14:29:58Z",
      "author_association": "MEMBER",
      "body": "Added a test to increase the coverage of schnorrsig_sign. Now coverage in the schnorrsig module is 100% when excluding the lines that can't be hit. See https://htmlpreview.github.io/?https://raw.githubusercontent.com/jonasnick/secp256k1/schnorrsig-stats/coverage.src_modules_schnorrsig_main_impl.h.html",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-432681178",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1941105577,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTk0MTEwNTU3Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1941105577",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-11-01T17:32:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1941109950,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTk0MTEwOTk1MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1941109950",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-11-01T17:34:11Z"
    },
    {
      "event": "commented",
      "id": 435121165,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTEyMTE2NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/435121165",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-11-01T17:34:52Z",
      "updated_at": "2018-11-01T17:34:52Z",
      "author_association": "MEMBER",
      "body": "squashed and rebased on master",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-435121165",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 171799261,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxNzk5MjYx",
      "url": null,
      "actor": null,
      "commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-171799261",
      "submitted_at": "2018-11-05T23:36:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 436962808,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjk2MjgwOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/436962808",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-11-08T11:26:20Z",
      "updated_at": "2018-11-08T11:27:05Z",
      "author_association": "MEMBER",
      "body": "Added commit that will switch to little endian format when interpreting chacha20 output, replace chacha20 tests with test vectors from the RFC, add sipa's chacha20 test.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-436962808",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 180541441,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNTQxNDQx",
      "url": null,
      "actor": null,
      "commit_id": "27b9d429f4cedcc805ce4a95bc96b5265666087e",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-180541441",
      "submitted_at": "2018-12-01T23:04:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2103174121,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjEwMzE3NDEyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2103174121",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-01-29T10:04:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2103208993,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjEwMzIwODk5Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2103208993",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-01-29T10:18:48Z"
    },
    {
      "event": "commented",
      "id": 458485661,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ1ODQ4NTY2MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/458485661",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-01-29T10:19:30Z",
      "updated_at": "2019-01-29T10:19:30Z",
      "author_association": "MEMBER",
      "body": "Adjusted tests to reflect most recent BIP-schnorr and squashed.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-458485661",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 479662263,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTY2MjI2Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/479662263",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-04-03T21:17:13Z",
      "updated_at": "2019-04-03T21:17:13Z",
      "author_association": "MEMBER",
      "body": "The `secp256k1_schnorrsig.h` file doesn't have \"#ifdef __cplusplus extern { #endif\" protections that make the header C++ compatible.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-479662263",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 480508535,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDUwODUzNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/480508535",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-04-06T14:29:05Z",
      "updated_at": "2019-04-06T14:29:05Z",
      "author_association": "MEMBER",
      "body": "fixed",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-480508535",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 234420649,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NDIwNjQ5",
      "url": null,
      "actor": null,
      "commit_id": "f532b338b2e4b2d4b0ca9eef2b0337463dd1310c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-234420649",
      "submitted_at": "2019-05-07T09:55:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 495378259,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTM3ODI1OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/495378259",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T20:45:01Z",
      "updated_at": "2019-05-23T20:45:01Z",
      "author_association": "NONE",
      "body": "This PR failed to build on s390x on Fedora Linux.\r\n\r\nThe patch was applied to commit a34bcaadf14442b86a5de120d4afd131f910d73d-\r\n\r\nLog: https://kojipkgs.fedoraproject.org//work/tasks/7518/35017518/build.log\r\nBuild task overview: https://koji.fedoraproject.org/koji/taskinfo?taskID=35017512",
      "user": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-495378259",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 495379966,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTM3OTk2Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/495379966",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T20:50:07Z",
      "updated_at": "2019-05-23T20:50:07Z",
      "author_association": "MEMBER",
      "body": "To save others from looking through it, the interesting lines are\r\n```\r\n+ ./tests\r\nBUILDSTDERR: src/tests.c:1044: test condition failed: secp256k1_scalar_eq(&exp_r1, &r1)\r\nBUILDSTDERR: /var/tmp/rpm-tmp.SSskCl: line 31: 56834 Aborted                 (core dumped) ./tests\r\n```",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-495379966",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 241443960,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDQzOTYw",
      "url": null,
      "actor": null,
      "commit_id": "f532b338b2e4b2d4b0ca9eef2b0337463dd1310c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-241443960",
      "submitted_at": "2019-05-23T20:50:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 495381679,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTM4MTY3OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/495381679",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T20:55:09Z",
      "updated_at": "2019-05-23T20:55:09Z",
      "author_association": "MEMBER",
      "body": "@hegjon \r\nDo you happen to have the stdout too (instead of only the stderr)? It contains a random seed for the entire test run. \r\nIs the failure reproducible?\r\n\r\n(Sorry for 3 comments in 5 min...)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-495381679",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 2363732449,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjM2MzczMjQ0OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2363732449",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T20:55:09Z"
    },
    {
      "event": "subscribed",
      "id": 2363732450,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDIzNjM3MzI0NTA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2363732450",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T20:55:09Z"
    },
    {
      "event": "commented",
      "id": 495383600,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTM4MzYwMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/495383600",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T21:01:21Z",
      "updated_at": "2019-05-23T21:01:21Z",
      "author_association": "NONE",
      "body": "> @hegjon\r\n> Do you happen to have the stdout too (instead of only the stderr)? It contains a random seed for the entire test run.\r\n> Is the failure reproducible?\r\n\r\nI can check and see if I am able to find them, I could also try to redirect stdout to stderr while debugging.\r\n\r\n\r\n> (Sorry for 3 comments in 5 min...)\r\n\r\nNo worries, thanks for replying\r\n",
      "user": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-495383600",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 2363747696,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjM2Mzc0NzY5Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2363747696",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T21:01:21Z"
    },
    {
      "event": "subscribed",
      "id": 2363747698,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDIzNjM3NDc2OTg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2363747698",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T21:01:21Z"
    },
    {
      "event": "commented",
      "id": 495403781,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTQwMzc4MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/495403781",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-23T22:12:37Z",
      "updated_at": "2019-05-23T22:12:37Z",
      "author_association": "NONE",
      "body": "> Is the failure reproducible?\r\n\r\nSeems like it fails every time for s390x, will try to get the stdout",
      "user": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-495403781",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 495718895,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTcxODg5NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/495718895",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-24T17:23:29Z",
      "updated_at": "2019-05-24T17:23:29Z",
      "author_association": "NONE",
      "body": "If someone want to debug this bug on a s390x system, paste your public ssh key, I and will try to grant you access to one",
      "user": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-495718895",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 495947606,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTk0NzYwNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/495947606",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-25T20:51:01Z",
      "updated_at": "2019-05-25T20:51:01Z",
      "author_association": "MEMBER",
      "body": "I can confirm that I get the same error on a big endian 64 bit mips system.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-495947606",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 242061155,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQyMDYxMTU1",
      "url": null,
      "actor": null,
      "commit_id": "f4153a29abab9bf87107846f125c4f6795879cae",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "jb55",
        "id": 45598,
        "node_id": "MDQ6VXNlcjQ1NTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/45598?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jb55",
        "html_url": "https://github.com/jb55",
        "followers_url": "https://api.github.com/users/jb55/followers",
        "following_url": "https://api.github.com/users/jb55/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jb55/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jb55/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jb55/subscriptions",
        "organizations_url": "https://api.github.com/users/jb55/orgs",
        "repos_url": "https://api.github.com/users/jb55/repos",
        "events_url": "https://api.github.com/users/jb55/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jb55/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-242061155",
      "submitted_at": "2019-05-27T00:02:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 496187860,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NjE4Nzg2MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/496187860",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-27T11:58:19Z",
      "updated_at": "2019-05-27T12:01:09Z",
      "author_association": "MEMBER",
      "body": "The suggestion by @real-or-random above is correct. Removing the `LE32` macro from the integer assignments makes the tests on my big endian machine pass. I'll add a commit to fix that later.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-496187860",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 2369207428,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjM2OTIwNzQyOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2369207428",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-27T11:58:19Z"
    },
    {
      "event": "subscribed",
      "id": 2369207429,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDIzNjkyMDc0Mjk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2369207429",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-27T11:58:19Z"
    },
    {
      "event": "commented",
      "id": 496304867,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NjMwNDg2Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/496304867",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-27T21:00:38Z",
      "updated_at": "2019-05-27T21:02:37Z",
      "author_association": "MEMBER",
      "body": "Pushed a commit that removes the `LE32` macro when doing the final chacha20 assignments. This didn't appear in the little endian tests because `LE32` is a noop there. I only ran the tests with 32 bit scalars on the big endian machine, because using 64 bit scalars is prohibited by `__int128` support not being available.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-496304867",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 496716953,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NjcxNjk1Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/496716953",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-28T22:42:36Z",
      "updated_at": "2019-05-28T22:42:36Z",
      "author_association": "NONE",
      "body": "Started a new build+tests now https://koji.fedoraproject.org/koji/taskinfo?taskID=35116811",
      "user": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-496716953",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 496725012,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NjcyNTAxMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/496725012",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-28T23:18:43Z",
      "updated_at": "2019-05-28T23:18:43Z",
      "author_association": "NONE",
      "body": "It builds+all tests passes on all arches for Fedora with the latest changes.\r\n\r\nI also added these configure flags:\r\n```\r\n--enable-experimental --enable-module-schnorrsig\r\n```\r\nare they required?\r\n",
      "user": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-496725012",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 496728257,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NjcyODI1Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/496728257",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-28T23:34:38Z",
      "updated_at": "2019-05-28T23:34:57Z",
      "author_association": "MEMBER",
      "body": "@hegjon Nice, thank you!\r\n\r\n> are they required?\r\n\r\nyes. Will add to OP.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-496728257",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 2373414946,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjM3MzQxNDk0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2373414946",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-28T23:34:38Z"
    },
    {
      "event": "subscribed",
      "id": 2373414947,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDIzNzM0MTQ5NDc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2373414947",
      "actor": {
        "login": "hegjon",
        "id": 12933,
        "node_id": "MDQ6VXNlcjEyOTMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/12933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hegjon",
        "html_url": "https://github.com/hegjon",
        "followers_url": "https://api.github.com/users/hegjon/followers",
        "following_url": "https://api.github.com/users/hegjon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hegjon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hegjon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hegjon/subscriptions",
        "organizations_url": "https://api.github.com/users/hegjon/orgs",
        "repos_url": "https://api.github.com/users/hegjon/repos",
        "events_url": "https://api.github.com/users/hegjon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hegjon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-28T23:34:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2378891123,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjM3ODg5MTEyMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2378891123",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-30T18:13:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2379153344,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjM3OTE1MzM0NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2379153344",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-30T19:59:59Z"
    },
    {
      "event": "commented",
      "id": 497465029,
      "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NzQ2NTAyOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/497465029",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-30T20:00:27Z",
      "updated_at": "2019-05-30T20:00:27Z",
      "author_association": "MEMBER",
      "body": "rebased",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-497465029",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2379251353,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjM3OTI1MTM1Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2379251353",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-05-30T20:39:48Z"
    },
    {
      "event": "mentioned",
      "id": 2412189450,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjQxMjE4OTQ1MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2412189450",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-06-13T23:36:16Z"
    },
    {
      "event": "subscribed",
      "id": 2412189452,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI0MTIxODk0NTI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2412189452",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-06-13T23:36:16Z"
    },
    {
      "event": "mentioned",
      "id": 2412191344,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjQxMjE5MTM0NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2412191344",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-06-13T23:37:28Z"
    },
    {
      "event": "subscribed",
      "id": 2412191346,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI0MTIxOTEzNDY=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2412191346",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-06-13T23:37:28Z"
    },
    {
      "event": "reviewed",
      "id": 249654149,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NjU0MTQ5",
      "url": null,
      "actor": null,
      "commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-249654149",
      "submitted_at": "2019-06-13T23:37:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 249660135,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NjYwMTM1",
      "url": null,
      "actor": null,
      "commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-249660135",
      "submitted_at": "2019-06-14T00:03:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 249670663,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NjcwNjYz",
      "url": null,
      "actor": null,
      "commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-249670663",
      "submitted_at": "2019-06-14T01:01:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 250205807,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMjA1ODA3",
      "url": null,
      "actor": null,
      "commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-250205807",
      "submitted_at": "2019-06-15T20:24:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 505393222,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUwNTM5MzIyMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/505393222",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-06-25T10:54:35Z",
      "updated_at": "2019-06-25T10:54:35Z",
      "author_association": "MEMBER",
      "body": "Can you add a line here? https://github.com/bitcoin-core/secp256k1/blob/a81efa5d01cced6bc9472580f16040a09a0025ff/configure.ac#L568",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-505393222",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 505412617,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUwNTQxMjYxNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/505412617",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-06-25T11:58:23Z",
      "updated_at": "2019-06-25T11:58:23Z",
      "author_association": "MEMBER",
      "body": "done",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-505412617",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2461351768,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjQ2MTM1MTc2OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2461351768",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-07-04T21:25:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2461353633,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjQ2MTM1MzYzMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2461353633",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-07-04T21:27:37Z"
    },
    {
      "event": "commented",
      "id": 508579350,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUwODU3OTM1MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/508579350",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-07-04T21:27:52Z",
      "updated_at": "2019-07-04T21:27:52Z",
      "author_association": "MEMBER",
      "body": "Removed `nonce_is_negated` out argument from `schnorrsig_sign` because it was only required for a follow-up sign-to-contract PR that I closed in favor of a different sign-to-contract PR which does not use a `nonce_is_negated` argument but instead adds `s2c_opening` and `s2c_data` arguments (PR #589).\r\n\r\nAlso squashed in order to allow to cleanly build the sign-to-contract PR on top.\r\n",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-508579350",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 258845418,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4ODQ1NDE4",
      "url": null,
      "actor": null,
      "commit_id": "a228e2f54d64692230ccb2937b12dd746c5157ed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-258845418",
      "submitted_at": "2019-07-08T11:36:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "mentioned",
      "id": 2579806838,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjU3OTgwNjgzOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2579806838",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-23T14:02:43Z"
    },
    {
      "event": "subscribed",
      "id": 2579806840,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI1Nzk4MDY4NDA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2579806840",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-23T14:02:43Z"
    },
    {
      "event": "mentioned",
      "id": 2583254914,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjU4MzI1NDkxNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2583254914",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-26T10:33:05Z"
    },
    {
      "event": "subscribed",
      "id": 2583254915,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI1ODMyNTQ5MTU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2583254915",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-26T10:33:05Z"
    },
    {
      "event": "mentioned",
      "id": 2583254918,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjU4MzI1NDkxOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2583254918",
      "actor": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-26T10:33:05Z"
    },
    {
      "event": "subscribed",
      "id": 2583254919,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI1ODMyNTQ5MTk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2583254919",
      "actor": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-26T10:33:05Z"
    },
    {
      "event": "commented",
      "id": 526344830,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjM0NDgzMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/526344830",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:18:26Z",
      "updated_at": "2019-08-29T20:18:26Z",
      "author_association": "MEMBER",
      "body": "I pushed new commits that do the following:\r\n\r\n* Introduce new `secp256k1_schnorrsig_pubkey` which is same as the normal pubkey except its y coordinate is always a quadratic residue. Also added creation function, as well as serialization and parsing according to bip-schnorr.\r\n* Add tagged hashing. This and above point means that the code should be compatible with the latest version of bip-schnorr (https://github.com/sipa/bips/blob/dc6b91c1a913f004ffa306c68295ac0b0f361264/bip-schnorr.mediawiki).\r\n* Disable the bip-schnorr test vectors for now until it is decided how to proceed with https://github.com/sipa/bips/pull/62\r\n* Fix the issue with nonce reuse and the `algo16` argument that @afk11 discovered\r\n* Fix the counter argument in the `bipschnorr_nonce_function` as it's exposed via secp.h but different values would not result in different nonces (no one compiles with -DVERIFY) which could result in nonce reuse.\r\n\r\nNow I'll add functions to commit to, verify and sign for a taproot commitments.\r\n\r\n",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-526344830",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 2595218591,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjU5NTIxODU5MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2595218591",
      "actor": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:18:26Z"
    },
    {
      "event": "subscribed",
      "id": 2595218592,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI1OTUyMTg1OTI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2595218592",
      "actor": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:18:26Z"
    },
    {
      "event": "mentioned",
      "id": 2611438240,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjYxMTQzODI0MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2611438240",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-05T16:52:08Z"
    },
    {
      "event": "subscribed",
      "id": 2611438241,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI2MTE0MzgyNDE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2611438241",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-05T16:52:08Z"
    },
    {
      "event": "commented",
      "id": 528526302,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyODUyNjMwMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/528526302",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-05T18:58:29Z",
      "updated_at": "2019-09-05T18:58:29Z",
      "author_association": "MEMBER",
      "body": ">     * Introduce new `secp256k1_schnorrsig_pubkey` which is same as the normal pubkey except its y coordinate is always a quadratic residue.\r\n\r\nI wonder if `secp256k1_32byte_pubkey` or similar is better name for the future. Not sure.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-528526302",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2629503955,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYyOTUwMzk1NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2629503955",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-12T14:57:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2629517700,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYyOTUxNzcwMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2629517700",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-12T15:00:43Z"
    },
    {
      "event": "commented",
      "id": 530867626,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzMDg2NzYyNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/530867626",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-12T15:02:07Z",
      "updated_at": "2019-09-12T15:02:07Z",
      "author_association": "MEMBER",
      "body": "I changed the schnorrsig_pubkey commits to rename the pubkey struct to `positive_pubkey` (alternative names runners-up: \"xonly\", \"short\"). Also, `positive_pubkey` related code was moved from the schnorrsig module into the main code. In principle it could be its own module, but if we expect more modules to use `positive_pubkeys` then I think not doing that is the easiest way.\r\n\r\nI added a new commit that introduces `positive_privkey_tweak_add`, `positive_pubkey_tweak_add`, `positive_pubkey_tweak_verify`, `positive_pubkey_from_signed` `and positive_pubkey_to_signed` in order to support bip-taproot operations. See https://github.com/bitcoin-core/secp256k1/pull/558/commits/59d10284ec18c74755d486cce6af55e46e25fbae#diff-4ad2dd2b8b6840915f8f0e99d18e1dc8R721 for an example of how to use these functions.\r\n\r\nIt's not particularly elegant to have all this conversion between positive and \"signed\" pubkeys but I didn't really find a way around it. One possible optimization of the API would be to have `privkey_tweak_add` take the corresponding pubkey as an argument which would avoid having to compute it.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-530867626",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 530875756,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzMDg3NTc1Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/530875756",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-12T15:20:37Z",
      "updated_at": "2019-09-12T15:20:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "Why positive?\nShouldn't it be `quad_pubkey` or something like that? ",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-530875756",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 530913782,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzMDkxMzc4Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/530913782",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-12T16:56:45Z",
      "updated_at": "2019-09-12T16:56:45Z",
      "author_association": "MEMBER",
      "body": "> Why positive?\r\n\r\nSo far it's the best option I've heard (h/t to @sipa). `quad_pubkey` is possible, but sounds overly technical and is not particularly precise (what's a quadratic pubkey?). Defining positive points as points where the Y coordinate has a quadratic residue makes it easy to talk about them. Look at how often we say \"point with a Y coordinate that is a quadratic residue\" in BIP-schnorr/taproot, which is irritating. The definition makes it easy to partition points into positive and negative and in that context we can use \"signed\" for the existing pubkey type where we don't care. Additionally, it's similar to the real numbers where positive numbers have a square root and negative numbers don't.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-530913782",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 2629890895,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjYyOTg5MDg5NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2629890895",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-12T16:56:45Z"
    },
    {
      "event": "subscribed",
      "id": 2629890898,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI2Mjk4OTA4OTg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2629890898",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-12T16:56:45Z"
    },
    {
      "event": "commented",
      "id": 531107751,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzMTEwNzc1MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/531107751",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-13T05:51:22Z",
      "updated_at": "2019-09-13T05:51:22Z",
      "author_association": "MEMBER",
      "body": "I guess \"positive\" may be confusing, and the opposite \"signed\" is probably even more confusing.\n\nI'm also ok with \"x-only\". Arguably, \"positive\" (if anything) is a property of the point, while having a Y coordinate at all is a property of the type of public key.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-531107751",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 531463556,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzMTQ2MzU1Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/531463556",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-14T09:04:29Z",
      "updated_at": "2019-09-14T09:04:29Z",
      "author_association": "MEMBER",
      "body": "\"x-only\" would need to be fleshed out more. How do you call existing pubkey types in that context? How do you call the `is_y_quad` bit which is simply called `sign` in this PR. `is_y_quad` also comes up in bip-taproot and would be much nicer if it could also be called `sign`.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-531463556",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 533338927,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzMzMzODkyNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/533338927",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-19T22:56:53Z",
      "updated_at": "2019-09-19T22:56:53Z",
      "author_association": "MEMBER",
      "body": "So what about this:\r\n* We introduce the term \"positive\" and \"negative\" as properties of EC points. Positive means Y is a quadratic residue; negative means Y is a quadratic nonresidue.\r\n* Then we defined x-only public keys as 32 bytes (in addition to compressed public keys of 33 bytes and uncompressed public keys of 65 bytes), which implicitly correspond to the positive point with the given X coordinate\r\n\r\nWhat do you think?",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-533338927",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2655587735,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY1NTU4NzczNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2655587735",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-23T19:13:39Z"
    },
    {
      "event": "commented",
      "id": 534243628,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzNDI0MzYyOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/534243628",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-23T19:15:24Z",
      "updated_at": "2019-09-23T19:15:24Z",
      "author_association": "MEMBER",
      "body": "Renamed `positive` to `xonly`, removed `signed_pks` and kept the `sign` bit. Also rebased on master to remove travis.yml conflict.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-534243628",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 534454543,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzNDQ1NDU0Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/534454543",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-24T08:35:18Z",
      "updated_at": "2019-09-24T08:35:18Z",
      "author_association": "MEMBER",
      "body": "> So what about this:\r\n> \r\n>     * We introduce the term \"positive\" and \"negative\" as properties of EC points. Positive means Y is a quadratic residue; negative means Y is a quadratic nonresidue.\r\n> \r\n>     * Then we defined x-only public keys as 32 bytes (in addition to compressed public keys of 33 bytes and uncompressed public keys of 65 bytes), which implicitly correspond to the positive point with the given X coordinate\r\n> \r\n> \r\n> What do you think?\r\n\r\nThis sounds great.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-534454543",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 292758739,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyNzU4NzM5",
      "url": null,
      "actor": null,
      "commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-292758739",
      "submitted_at": "2019-09-24T23:22:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "mentioned",
      "id": 2659826849,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjY1OTgyNjg0OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2659826849",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-24T23:23:53Z"
    },
    {
      "event": "subscribed",
      "id": 2659826851,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI2NTk4MjY4NTE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2659826851",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-24T23:23:53Z"
    },
    {
      "event": "reviewed",
      "id": 300363481,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMzYzNDgx",
      "url": null,
      "actor": null,
      "commit_id": "7eeb3aa49832015a8aa8caf17a008d263f373fc0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-300363481",
      "submitted_at": "2019-10-10T21:30:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 300926221,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwOTI2MjIx",
      "url": null,
      "actor": null,
      "commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-300926221",
      "submitted_at": "2019-10-11T21:03:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 300930330,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwOTMwMzMw",
      "url": null,
      "actor": null,
      "commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-300930330",
      "submitted_at": "2019-10-11T21:13:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "mentioned",
      "id": 2722984555,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjcyMjk4NDU1NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2722984555",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-17T22:45:00Z"
    },
    {
      "event": "subscribed",
      "id": 2722984557,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI3MjI5ODQ1NTc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2722984557",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-17T22:45:00Z"
    },
    {
      "event": "reviewed",
      "id": 303576278,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAzNTc2Mjc4",
      "url": null,
      "actor": null,
      "commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-303576278",
      "submitted_at": "2019-10-17T23:02:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 303593950,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAzNTkzOTUw",
      "url": null,
      "actor": null,
      "commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-303593950",
      "submitted_at": "2019-10-17T23:50:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "mentioned",
      "id": 2742003934,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mjc0MjAwMzkzNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2742003934",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-24T19:47:51Z"
    },
    {
      "event": "subscribed",
      "id": 2742003935,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI3NDIwMDM5MzU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2742003935",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-24T19:47:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2742132592,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc0MjEzMjU5Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2742132592",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-24T20:32:58Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2742149741,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc0MjE0OTc0MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2742149741",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-24T20:39:24Z"
    },
    {
      "event": "reviewed",
      "id": 308247685,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA4MjQ3Njg1",
      "url": null,
      "actor": null,
      "commit_id": "e28b61c290f4549dfeb94b421310ff68b661fea0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-308247685",
      "submitted_at": "2019-10-29T02:37:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 547306477,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU0NzMwNjQ3Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/547306477",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-29T08:18:36Z",
      "updated_at": "2019-10-29T08:18:36Z",
      "author_association": "MEMBER",
      "body": "Just a note:\r\nThe existing pubkey functions all have an `ec_` pubkey prefix but the `xonly_` do not. \r\n\r\nWe could add the `ec_` there too, just for consistency. However, I think it would be better to remove the `ec_` entirely but it's too late for this now.... So I think just `xonly_` is fine exactly because it does not have this annoying prefix.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-547306477",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 547312261,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU0NzMxMjI2MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/547312261",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-29T08:35:58Z",
      "updated_at": "2019-10-29T08:35:58Z",
      "author_association": "MEMBER",
      "body": "> The existing pubkey functions all have an ec_ pubkey prefix but the xonly_ do not.\r\n\r\nYes, this is on purpose and I agree that this is fine.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-547312261",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 2752635967,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mjc1MjYzNTk2Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2752635967",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-29T15:28:02Z"
    },
    {
      "event": "subscribed",
      "id": 2752635971,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI3NTI2MzU5NzE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2752635971",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-29T15:28:02Z"
    },
    {
      "event": "commented",
      "id": 548994153,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU0ODk5NDE1Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/548994153",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-02T00:52:15Z",
      "updated_at": "2019-11-02T00:56:17Z",
      "author_association": "MEMBER",
      "body": "I added a few commits addressing the feedback to\r\n1. change the tweak api from `pubkey` to `xonly_pubkey` and `is_positive` bit (which reduces taproot test loc quite a bit).\r\n2. remove xonly to pubkey conversion. Not necessary anymore with the new tweak api\r\n\r\nAlso, there was a mismatch with the spec where we had fed the non-negated seckey into the nonce function (to be clear, not a security problem). I also updated test vectors.\r\n\r\nI left the pubkey to xonly pubkey conversion. That's right now the only efficient way to tweak a seckey and get a corresponding xonly pubkey (with `is_positive` to allow verification):\r\n```\r\nsecp256k1_xonly_privkey_tweak_add(ctx, sk, tweak);\r\nsecp256k1_ec_pubkey_create(ctx, &xy_pk, sk);\r\nsecp256k1_xonly_pubkey_from_pubkey(ctx, &output_pk, &is_positive, &xy_pk);\r\n```\r\nAlternatively we could offer an `secp256k1_xonly_pubkey_create_tweaked` that in addition to the secret key takes a tweak and returns tweaked seckey and pubkey.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-548994153",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 549075935,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU0OTA3NTkzNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/549075935",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-02T19:59:21Z",
      "updated_at": "2019-11-02T19:59:21Z",
      "author_association": "MEMBER",
      "body": "Travis fails because of a single gcc test (`HOST=i686-linux-gnu ENDOMORPHISM=yes`). I've done a ./tests 100 iterations locally and wasn't able to reproduce this so I'm guessing it's just an accident. I opened #685 to improve reproducibility in the future.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-549075935",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 549186029,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU0OTE4NjAyOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/549186029",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-03T22:31:23Z",
      "updated_at": "2019-11-03T22:31:23Z",
      "author_association": "MEMBER",
      "body": "There was in fact an issue: uninitialized memory in a newly added test. Should have valground. Fixed now.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-549186029",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 549811098,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU0OTgxMTA5OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/549811098",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-05T12:55:28Z",
      "updated_at": "2019-11-05T12:55:28Z",
      "author_association": "MEMBER",
      "body": "Replaced positive/negative point terminology to has_square_y.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-549811098",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2799138423,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc5OTEzODQyMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2799138423",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-14T13:53:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2799140140,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc5OTE0MDE0MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2799140140",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-14T13:54:05Z"
    },
    {
      "event": "commented",
      "id": 553898586,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU1Mzg5ODU4Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/553898586",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-14T13:56:22Z",
      "updated_at": "2019-11-14T13:57:40Z",
      "author_association": "MEMBER",
      "body": "Squashed the fixup commits and made a few more logical commits.\r\n```\r\nAdd xonly_pubkeys which are serialized as 32 byte and whose Y coordinate is a quadratic residue\r\nAdd tweak functions for xonly_pubkeys that allow to add a tweak to a\r\nAdd chacha20 function\r\nAdd initialize_tagged to sha256 which initializes and writes the 64 byte string SHA256(tag)||SHA256(tag) into it.\r\nAdd schnorrsig module which implements BIP-schnorr [0] compatible signing, verification and batch verification\r\nAdd taproot test case to schnorrsig module\r\n```\r\nAlso rebased on master to fix conflicts and get travis to work again. There were no code changes except two typo fixes.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-553898586",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 318009650,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4MDA5NjUw",
      "url": null,
      "actor": null,
      "commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed everything except batch logic + tests + benchmarks.\r\nwill review later.\r\n\r\none note is can we be a bit consistent on privkey/seckey? #670",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-318009650",
      "submitted_at": "2019-11-17T11:41:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 318636289,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NjM2Mjg5",
      "url": null,
      "actor": null,
      "commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-318636289",
      "submitted_at": "2019-11-18T21:18:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 318638552,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NjM4NTUy",
      "url": null,
      "actor": null,
      "commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-318638552",
      "submitted_at": "2019-11-18T21:22:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 318712698,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NzEyNjk4",
      "url": null,
      "actor": null,
      "commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-318712698",
      "submitted_at": "2019-11-19T00:11:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 321603000,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIxNjAzMDAw",
      "url": null,
      "actor": null,
      "commit_id": "a5f6b33704cb6a925bc4b3820f810387cfd0626c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-321603000",
      "submitted_at": "2019-11-22T15:01:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 322411490,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNDExNDkw",
      "url": null,
      "actor": null,
      "commit_id": "a87a0576dcc7188f8babc3fc9ec5f2a68522ff6d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "f's look good :)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-322411490",
      "submitted_at": "2019-11-25T16:55:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 558846671,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU1ODg0NjY3MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/558846671",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-26T22:33:58Z",
      "updated_at": "2019-11-26T22:33:58Z",
      "author_association": "MEMBER",
      "body": "@real-or-random or @elichai may I ask you review the new fixup commits? Will squash and rebase then.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-558846671",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 2833684956,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjgzMzY4NDk1Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2833684956",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-26T22:33:59Z"
    },
    {
      "event": "mentioned",
      "id": 2833684957,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjgzMzY4NDk1Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2833684957",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-26T22:33:59Z"
    },
    {
      "event": "subscribed",
      "id": 2833684961,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI4MzM2ODQ5NjE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2833684961",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-26T22:33:59Z"
    },
    {
      "event": "subscribed",
      "id": 2833684963,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI4MzM2ODQ5NjM=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2833684963",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-26T22:33:59Z"
    },
    {
      "event": "reviewed",
      "id": 323340749,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMzQwNzQ5",
      "url": null,
      "actor": null,
      "commit_id": "c1b1bbca759b5394d7198b8eecf83fec41f75c4f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-323340749",
      "submitted_at": "2019-11-26T23:15:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 558858068,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU1ODg1ODA2OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/558858068",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-26T23:15:43Z",
      "updated_at": "2019-11-26T23:15:43Z",
      "author_association": "MEMBER",
      "body": "The fixups look good otherwise. Needs rebase.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-558858068",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 325369089,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1MzY5MDg5",
      "url": null,
      "actor": null,
      "commit_id": "a74a0132e416facc2da0972ee1f4e0a8917a3723",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-325369089",
      "submitted_at": "2019-12-02T16:42:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2847637042,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjg0NzYzNzA0Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2847637042",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-02T23:23:44Z"
    },
    {
      "event": "commented",
      "id": 560891554,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU2MDg5MTU1NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/560891554",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-02T23:27:56Z",
      "updated_at": "2019-12-02T23:27:56Z",
      "author_association": "MEMBER",
      "body": "Squashed and rebased",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-560891554",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "referenced",
      "id": 2851708247,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI4NTE3MDgyNDc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2851708247",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6afc7b23e8a92e5258639a1df5b4b3d8d94e49ba",
      "commit_url": "https://api.github.com/repos/jonasnick/secp256k1-zkp/commits/6afc7b23e8a92e5258639a1df5b4b3d8d94e49ba",
      "created_at": "2019-12-03T21:24:32Z"
    },
    {
      "event": "referenced",
      "id": 2851711564,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI4NTE3MTE1NjQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2851711564",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2c3910057de2b116fd6cb907578ce0e11fea3c8a",
      "commit_url": "https://api.github.com/repos/jonasnick/secp256k1-zkp/commits/2c3910057de2b116fd6cb907578ce0e11fea3c8a",
      "created_at": "2019-12-03T21:25:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2851732460,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjg1MTczMjQ2MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2851732460",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-03T21:32:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2851734067,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjg1MTczNDA2Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2851734067",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-03T21:33:01Z"
    },
    {
      "event": "commented",
      "id": 561366878,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU2MTM2Njg3OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/561366878",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-03T21:33:46Z",
      "updated_at": "2019-12-03T21:33:46Z",
      "author_association": "MEMBER",
      "body": "Had to force push to remove garbage in the commit messages.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-561366878",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "referenced",
      "id": 2851962038,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI4NTE5NjIwMzg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2851962038",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "562ccf41c35605a91636e16e43861b2ba976b629",
      "commit_url": "https://api.github.com/repos/jonasnick/secp256k1-zkp/commits/562ccf41c35605a91636e16e43861b2ba976b629",
      "created_at": "2019-12-03T22:52:51Z"
    },
    {
      "event": "reviewed",
      "id": 330591799,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwNTkxNzk5",
      "url": null,
      "actor": null,
      "commit_id": "1901f3bf9c6197f0bd3cc62e9f6c69296566a23a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-330591799",
      "submitted_at": "2019-12-11T14:45:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "referenced",
      "id": 2879176955,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI4NzkxNzY5NTU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2879176955",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a654ee5ebc8133d8554939e7b86aca8c177b4973",
      "commit_url": "https://api.github.com/repos/jonasnick/secp256k1-zkp/commits/a654ee5ebc8133d8554939e7b86aca8c177b4973",
      "created_at": "2019-12-12T19:51:48Z"
    },
    {
      "event": "referenced",
      "id": 2879183672,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI4NzkxODM2NzI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2879183672",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a76523297be40a6c23a977e6ff67104981f4ce51",
      "commit_url": "https://api.github.com/repos/jonasnick/secp256k1-zkp/commits/a76523297be40a6c23a977e6ff67104981f4ce51",
      "created_at": "2019-12-12T19:54:02Z"
    },
    {
      "event": "reviewed",
      "id": 346877566,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc3NTY2",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346877566",
      "submitted_at": "2020-01-22T20:23:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346877743,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc3NzQz",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346877743",
      "submitted_at": "2020-01-22T20:23:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346877875,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc3ODc1",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346877875",
      "submitted_at": "2020-01-22T20:23:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346878045,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc4MDQ1",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346878045",
      "submitted_at": "2020-01-22T20:24:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346878228,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc4MjI4",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346878228",
      "submitted_at": "2020-01-22T20:24:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346878378,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc4Mzc4",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346878378",
      "submitted_at": "2020-01-22T20:24:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346878589,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc4NTg5",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346878589",
      "submitted_at": "2020-01-22T20:25:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346878951,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc4OTUx",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346878951",
      "submitted_at": "2020-01-22T20:25:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346879128,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc5MTI4",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346879128",
      "submitted_at": "2020-01-22T20:26:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346879870,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc5ODcw",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346879870",
      "submitted_at": "2020-01-22T20:27:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346880690,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODgwNjkw",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346880690",
      "submitted_at": "2020-01-22T20:29:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346881396,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODgxMzk2",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346881396",
      "submitted_at": "2020-01-22T20:30:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346881783,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODgxNzgz",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346881783",
      "submitted_at": "2020-01-22T20:30:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346881984,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODgxOTg0",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346881984",
      "submitted_at": "2020-01-22T20:31:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346883091,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODgzMDkx",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346883091",
      "submitted_at": "2020-01-22T20:33:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346883391,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODgzMzkx",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346883391",
      "submitted_at": "2020-01-22T20:33:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 346886721,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODg2NzIx",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "This changes every occurrence of `BIP-Schnorr` [or similar writing] to `BIP-340`.\r\n\r\nI am unsure if this is the proper way of doing this, especially regarding the tagged hashes, thus I will suggest it for every occurrence, and ask you to please commit or close it depending if it is correct in that instance. \r\n\r\nMy suggestions [started in this PR](https://github.com/bitcoin/bitcoin/pull/17977#pullrequestreview-346630927).",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346886721",
      "submitted_at": "2020-01-22T20:39:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "comment_deleted",
      "id": 2973772819,
      "node_id": "MDE5OkNvbW1lbnREZWxldGVkRXZlbnQyOTczNzcyODE5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2973772819",
      "actor": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-23T13:44:14Z"
    },
    {
      "event": "comment_deleted",
      "id": 2973775072,
      "node_id": "MDE5OkNvbW1lbnREZWxldGVkRXZlbnQyOTczNzc1MDcy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2973775072",
      "actor": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-23T13:44:55Z"
    },
    {
      "event": "comment_deleted",
      "id": 2973775114,
      "node_id": "MDE5OkNvbW1lbnREZWxldGVkRXZlbnQyOTczNzc1MTE0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2973775114",
      "actor": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-23T13:44:56Z"
    },
    {
      "event": "reviewed",
      "id": 347306110,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MzA2MTEw",
      "url": null,
      "actor": null,
      "commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Sorry @sipa, I've removed the suggestions to keep `BIPSchnorrDerive`. What about `secp256k1_nonce_function_bipschnorr`?\r\n\r\nand yes @real-or-random I opened the multiple suggestions with the single batch commit in mind.",
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-347306110",
      "submitted_at": "2020-01-23T13:47:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 348403015,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NDAzMDE1",
      "url": null,
      "actor": null,
      "commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-348403015",
      "submitted_at": "2020-01-26T20:29:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 348406368,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NDA2MzY4",
      "url": null,
      "actor": null,
      "commit_id": "6603c32a10eb0025ac35adc159bf9c57b8e29334",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "constcast-glitch",
        "id": 60033096,
        "node_id": "MDQ6VXNlcjYwMDMzMDk2",
        "avatar_url": "https://avatars.githubusercontent.com/u/60033096?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/constcast-glitch",
        "html_url": "https://github.com/constcast-glitch",
        "followers_url": "https://api.github.com/users/constcast-glitch/followers",
        "following_url": "https://api.github.com/users/constcast-glitch/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/constcast-glitch/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/constcast-glitch/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/constcast-glitch/subscriptions",
        "organizations_url": "https://api.github.com/users/constcast-glitch/orgs",
        "repos_url": "https://api.github.com/users/constcast-glitch/repos",
        "events_url": "https://api.github.com/users/constcast-glitch/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/constcast-glitch/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-348406368",
      "submitted_at": "2020-01-26T21:36:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 348434042,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NDM0MDQy",
      "url": null,
      "actor": null,
      "commit_id": "6603c32a10eb0025ac35adc159bf9c57b8e29334",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "leishman",
        "id": 3648618,
        "node_id": "MDQ6VXNlcjM2NDg2MTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3648618?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/leishman",
        "html_url": "https://github.com/leishman",
        "followers_url": "https://api.github.com/users/leishman/followers",
        "following_url": "https://api.github.com/users/leishman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/leishman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/leishman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/leishman/subscriptions",
        "organizations_url": "https://api.github.com/users/leishman/orgs",
        "repos_url": "https://api.github.com/users/leishman/repos",
        "events_url": "https://api.github.com/users/leishman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/leishman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-348434042",
      "submitted_at": "2020-01-27T03:55:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "mentioned",
      "id": 2983731017,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mjk4MzczMTAxNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2983731017",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-27T23:08:42Z"
    },
    {
      "event": "subscribed",
      "id": 2983731018,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI5ODM3MzEwMTg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2983731018",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-27T23:08:42Z"
    },
    {
      "event": "mentioned",
      "id": 2983731021,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mjk4MzczMTAyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2983731021",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-27T23:08:42Z"
    },
    {
      "event": "subscribed",
      "id": 2983731022,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI5ODM3MzEwMjI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2983731022",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-27T23:08:42Z"
    },
    {
      "event": "mentioned",
      "id": 2984586533,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mjk4NDU4NjUzMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2984586533",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-28T07:48:51Z"
    },
    {
      "event": "subscribed",
      "id": 2984586539,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI5ODQ1ODY1Mzk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/2984586539",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-28T07:48:51Z"
    },
    {
      "event": "commented",
      "id": 582152117,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU4MjE1MjExNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/582152117",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-02-04T22:43:25Z",
      "updated_at": "2020-02-04T23:02:57Z",
      "author_association": "MEMBER",
      "body": "I pushed a few commits to experiment with bringing this PR in sync with the proposed changes to [bip-schnorr](https://github.com/sipa/bips/blob/bip-taproot/bip-0340.mediawiki): switching from squareness to evenness as tie breaker, new challenge and nonce hash tags, new nonce function that takes pubkeys as argument.\r\n\r\nIt was mentioned that with the evenness tiebreaker we could maybe remove the `xonly_pubkey` altogether. I created https://gist.github.com/jonasnick/a122acd8395ac4c6ae7b648450f5ec07 with three different versions of the taproot test (from `schnorrsig/tests_impl.h`):\r\n\r\n1. Current version\r\n2. `xonly_pubkey_create` is removed but the `xonly_pubkey` type still exists as arguments to `schnorrsig_verify` and `secp256k1_xonly_pubkey_tweak_test`. Output of `secp256k1_xonly_pubkey_tweak_add` is a normal pubkey\r\n3. There's no xonly_pubkey anymore. `schnorrsig_verify` and `xonly_pubkey_tweak_test` Return 0 if they get a pubkey with an uneven Y.\r\n\r\nWith 3 you can't simply use `schnorrsig_verify` with your normal pubkey because it will (or should) fail if called with an odd Y pubkey.\r\nYou'll need to call a convert function (or do a serialization roundtrip with the `XONLY` flag). Therefore, I think it's better to keep the `xonly_pubkey` type in the `schnorrsig_verify()` arguments.\r\n\r\nThe current sitation (1) isn't too bad actually. 2 has the advantage to gets rid of the `is_negated` variable which seems more redundant now that evenness is used as a tie breaker. But it will reappear in the form of conversion functions unless we want people to mess with the compressed pubkey format to make use of the evenness information in the taproot control block bit. This is how I originally proposed doing this, but it was viewed as too complicated.\r\nIn light of 2 (or 3), it would also make sense to rename `is_negated` in `taproot_tweak_pubkey` in bip-taproot (https://github.com/sipa/bips/blob/bip-taproot/bip-0341.mediawiki) to `is_even_y`.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-582152117",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3032493635,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzAzMjQ5MzYzNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3032493635",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-02-12T21:19:42Z"
    },
    {
      "event": "commented",
      "id": 585423928,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU4NTQyMzkyOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/585423928",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-02-12T21:22:23Z",
      "updated_at": "2020-02-12T21:22:23Z",
      "author_association": "MEMBER",
      "body": "Had to rebase because of a conflict in .travis.yml, and travis failing due to a 404 when fetching java dependencies (hehe).",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-585423928",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3032773968,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzAzMjc3Mzk2OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3032773968",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-02-12T22:54:35Z"
    },
    {
      "event": "mentioned",
      "id": 3043573661,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzA0MzU3MzY2MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3043573661",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-02-17T12:43:05Z"
    },
    {
      "event": "subscribed",
      "id": 3043573664,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDMwNDM1NzM2NjQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3043573664",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-02-17T12:43:06Z"
    },
    {
      "event": "reviewed",
      "id": 361754686,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNzU0Njg2",
      "url": null,
      "actor": null,
      "commit_id": "23c3b0050e9878379cd3028960a506f59550f87b",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-361754686",
      "submitted_at": "2020-02-20T09:39:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 363855096,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODU1MDk2",
      "url": null,
      "actor": null,
      "commit_id": "23c3b0050e9878379cd3028960a506f59550f87b",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-363855096",
      "submitted_at": "2020-02-25T03:50:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 596093025,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU5NjA5MzAyNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/596093025",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-07T14:17:27Z",
      "updated_at": "2020-03-07T14:17:27Z",
      "author_association": "MEMBER",
      "body": "PR should now match the updated BIP in https://github.com/bitcoin/bips/pull/893#pullrequestreview-366405395. I also added the new test vectors. Will rebase and squash once someone had a look at it.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-596093025",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 597736988,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU5NzczNjk4OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/597736988",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-11T16:33:57Z",
      "updated_at": "2020-03-11T16:33:57Z",
      "author_association": "MEMBER",
      "body": "To keep this PR consistent with BIP-taproot (latest updates https://github.com/bitcoin/bips/pull/893), I changed `xonly_tweak_test` to take the 32 bytes serialized output pubkey to prevent an unnecessary decompression. (@elichai you'll be happy to hear that `xonly_tweak_test` now has a better reason to exist :)",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-597736988",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3119605843,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzExOTYwNTg0Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3119605843",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-11T16:33:58Z"
    },
    {
      "event": "subscribed",
      "id": 3119605848,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDMxMTk2MDU4NDg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3119605848",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-11T16:33:58Z"
    },
    {
      "event": "reviewed",
      "id": 373987876,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTg3ODc2",
      "url": null,
      "actor": null,
      "commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-373987876",
      "submitted_at": "2020-03-13T00:57:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 598501407,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU5ODUwMTQwNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/598501407",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-13T01:15:02Z",
      "updated_at": "2020-03-13T01:15:02Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, enough to squash. I've reviewed the API, and read through the nonce generation, signing, and (non-batched) verification code.\r\n\r\nCan you include for `valgrind_ctime_test` support after rebase?",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-598501407",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 376279435,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2Mjc5NDM1",
      "url": null,
      "actor": null,
      "commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-376279435",
      "submitted_at": "2020-03-17T18:06:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3150884905,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzE1MDg4NDkwNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3150884905",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-20T20:57:04Z"
    },
    {
      "event": "reviewed",
      "id": 383337167,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzM3MTY3",
      "url": null,
      "actor": null,
      "commit_id": "372c4555cac1d2cba747ea691006876818c6adef",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-383337167",
      "submitted_at": "2020-03-28T18:27:39Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 606637142,
      "node_id": "MDEyOklzc3VlQ29tbWVudDYwNjYzNzE0Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/606637142",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-31T13:45:25Z",
      "updated_at": "2020-04-01T09:13:43Z",
      "author_association": "MEMBER",
      "body": "As a follow up to [above discussion](https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-582152117) about changing the API after switching to the y-parity tie-breaker I experimented with option 2 (remove `xonly_pubkey_create`). This works, but it introduces the additional step of converting your `pubkey` into an `xonly_pubkey` before being able to `schnorrsig_verify` your signature.\r\n\r\nTherefore, I took it a step further and experimented with what we actually want to have: a `secp256k1_keypair` type which holds both a secret key and a public key. This avoids needlessly recomputing the public key in `xonly_seckey_tweak_add` and `schnorrsig_tweak_add`.\r\n\r\nYou create a keypair by calling `secp256k1_keypair_create(ctx, &keypair, seckey)` with your 32 byte secret key. Instead of `xonly_seckey_tweak_add` there is a `keypair_xonly_tweak_add` that tweaks both parts of the keypair. I didn't add functions for (de-)serializing keypairs for now. There's no function to combine a secret key and a public key into a keypair, because that can easily lead to a vulnerability if the attacker controls the public key. But as far as I know, random bit corruption of keypairs is okay.\r\n\r\nTo see this in action, have a look at the taproot test in my branch https://github.com/jonasnick/secp256k1/blob/schnorrsig-keypair/src/modules/schnorrsig/tests_impl.h#L734. What's missing in the branch is API documentation and API tests. If there's no opposition, I suggest to go ahead with this approach because it's simpler than introducing functions that would be superseded later anyway by keypair functions.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-606637142",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 619579991,
      "node_id": "MDEyOklzc3VlQ29tbWVudDYxOTU3OTk5MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/619579991",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-04-26T16:26:43Z",
      "updated_at": "2020-04-26T16:26:43Z",
      "author_association": "MEMBER",
      "body": "Do we know how critical the PRG performance is for the overall performance? We might just use SHA256 instead. Don't get me wrong, we have a working ChaCha implementation here and ChaCha is lightweight, and I think it's a good choice. But if we're thinking about https://github.com/bitcoin-core/secp256k1/issues/702, sticking with SHA256 may be simpler, smaller binary, and even faster in the end.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-619579991",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 619598999,
      "node_id": "MDEyOklzc3VlQ29tbWVudDYxOTU5ODk5OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/619598999",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-04-26T18:16:18Z",
      "updated_at": "2020-04-26T18:16:18Z",
      "author_association": "MEMBER",
      "body": "The rough numbers I use as rule of thumb (and maybe outdated...) is that pure C (no intrinsics) implementations on x86_64 need 15 cycles/byte for SHA256 (so multiply by input length after padding), and 3 cycles/byte for ChaCha20 (multiply by the number of bytes produced, rounded up to a multiple of 64).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-619598999",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3336591630,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzMzNjU5MTYzMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3336591630",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-05-14T13:23:57Z"
    },
    {
      "event": "commented",
      "id": 628633672,
      "node_id": "MDEyOklzc3VlQ29tbWVudDYyODYzMzY3Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/628633672",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-05-14T13:26:08Z",
      "updated_at": "2020-05-14T13:26:08Z",
      "author_association": "MEMBER",
      "body": "Since I didn't get much response to the keypair idea mentioned above I went ahead with that and also took the opportunity to refactor a few other things. All in all, this should make this PR easier to review and to merge.\r\n\r\n1. There's a new experimental \"extrakeys\" module for xonly_pubkeys and keypairs. This is better than having those functions and structs in secp256k1.h because that way this PR does not touch secp256k1.h at all an therefore does not interfere with our goal of stabilizing all non-experimental parts of the library. The extrakeys module is enabled automatically if the schnorrsig module is enabled.\r\n2. For a similar reason I moved the bip-schnorr nonce function to schnorrsig module. It couldn't be used with ECDSA anyway because it has a different nonce function type (also the serialized xonly pubkey as argument).\r\n3. schnorrsig batch verification is removed. It's fairly well tested, but still wouldn't be comfortable with using this in Bitcoin Core for consensus in its current state because it relies on parts of the lib that are otherwise unused. Also there's been still some discussion on the RNG and synthetic randomness. For now, it's simpler to just remove it and add it again in a different PR - ideally with comprehensive fuzz tests.\r\n4. The Schnorr signature struct is removed. Instead, a schnorr sig is just a 64-byte array which matches the definition in the BIP. The schnorrsig struct didn't really serve a purpose, its parse and serialize functions were just memcpy'ing and I didn't come up with a future purpose for it.\r\n\r\nIf you tweak your secret key before signing (as is recommended by bip-taproot) schnorrsig_sign takes only 28.4us now vs 53.9us before because it does not have to recompute the public key thanks to keypairs.\r\nTo get an overview how the new API works have a look at the taproot test case at https://github.com/bitcoin-core/secp256k1/pull/558/commits/682a113f3a0a816c0f0391af9eef036133839335.\r\n\r\nThe state of this PR before the force push is archived at https://github.com/jonasnick/secp256k1/commits/schnorrsig-backup52.\r\n",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-628633672",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 417094764,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MDk0NzY0",
      "url": null,
      "actor": null,
      "commit_id": "7a3acdcef9207715b332da9d89e85e2b182a216f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Approach ACK, and reviewed most of the code.\r\n\r\nI really like the state this is in. It makes perfect sense to have the keypair data type in a separate module (for now), and the commit history is easy to follow. I've left a few suggestions in the code, but nothing major.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-417094764",
      "submitted_at": "2020-05-22T19:48:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 425759322,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NzU5MzIy",
      "url": null,
      "actor": null,
      "commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I also verified that the midstates are correct via an unrelated sha256 impl",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-425759322",
      "submitted_at": "2020-06-06T19:43:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "comment_deleted",
      "id": 3440963901,
      "node_id": "MDE5OkNvbW1lbnREZWxldGVkRXZlbnQzNDQwOTYzOTAx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3440963901",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-06-13T17:04:13Z"
    },
    {
      "event": "reviewed",
      "id": 434484548,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDg0NTQ4",
      "url": null,
      "actor": null,
      "commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-434484548",
      "submitted_at": "2020-06-21T09:18:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 447659118,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NjU5MTE4",
      "url": null,
      "actor": null,
      "commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-447659118",
      "submitted_at": "2020-07-13T22:38:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 657922810,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY1NzkyMjgxMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/657922810",
      "actor": {
        "login": "ZmnSCPxj",
        "id": 28175207,
        "node_id": "MDQ6VXNlcjI4MTc1MjA3",
        "avatar_url": "https://avatars.githubusercontent.com/u/28175207?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ZmnSCPxj",
        "html_url": "https://github.com/ZmnSCPxj",
        "followers_url": "https://api.github.com/users/ZmnSCPxj/followers",
        "following_url": "https://api.github.com/users/ZmnSCPxj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ZmnSCPxj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ZmnSCPxj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ZmnSCPxj/subscriptions",
        "organizations_url": "https://api.github.com/users/ZmnSCPxj/orgs",
        "repos_url": "https://api.github.com/users/ZmnSCPxj/repos",
        "events_url": "https://api.github.com/users/ZmnSCPxj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ZmnSCPxj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-14T02:06:00Z",
      "updated_at": "2020-07-14T02:06:00Z",
      "author_association": "NONE",
      "body": "> The Schnorr signature struct is removed. Instead, a schnorr sig is just a 64-byte array which matches the definition in the BIP. The schnorrsig struct didn't really serve a purpose, its parse and serialize functions were just memcpy'ing and I didn't come up with a future purpose for it.\r\n\r\nA 64-byte array is merely a blob of bytes.  I would argue that the art of programming is taking blobs of bytes and imbuing them with meaning.  Thus, a `schnorrsig` struct serves a purpose of imbuing meaning to a particular blob of 64 bytes, even if in the end the library is just `memcpy`ing it.  If I were to write an interface to `libsecp256k1` I would put types on almost anything, possibly with the ability to hack the bytes inside it, but would avoid flat arrays as much as possible.",
      "user": {
        "login": "ZmnSCPxj",
        "id": 28175207,
        "node_id": "MDQ6VXNlcjI4MTc1MjA3",
        "avatar_url": "https://avatars.githubusercontent.com/u/28175207?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ZmnSCPxj",
        "html_url": "https://github.com/ZmnSCPxj",
        "followers_url": "https://api.github.com/users/ZmnSCPxj/followers",
        "following_url": "https://api.github.com/users/ZmnSCPxj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ZmnSCPxj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ZmnSCPxj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ZmnSCPxj/subscriptions",
        "organizations_url": "https://api.github.com/users/ZmnSCPxj/orgs",
        "repos_url": "https://api.github.com/users/ZmnSCPxj/repos",
        "events_url": "https://api.github.com/users/ZmnSCPxj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ZmnSCPxj/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-657922810",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 657930464,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY1NzkzMDQ2NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/657930464",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-14T02:34:04Z",
      "updated_at": "2020-07-14T02:34:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I would put types on almost anything, possibly\r\n\r\nno strong opinion, but this principle is consistent with MISRA-C which mostly forbids primitive types... it's a little more complicated when you talk about an API boundary, however.",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-657930464",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 657932218,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY1NzkzMjIxOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/657932218",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-14T02:40:13Z",
      "updated_at": "2020-07-14T02:40:13Z",
      "author_association": "MEMBER",
      "body": "I conceptually agree with typing being useful, but I think there is also a pragmatic argument against: if pretty much all expected usage of the API will be `parse_into_schnorrsig(&sig, data_ptr); do_something_with_schnorrsig(&sig)` or `create_schnorrsig(&sig); serialize_schnorrsig(data_ptr, &sig)`, and those parse/serialize functions don't do anything but copy bytes - i'd say they just add clutter for the user.\r\n\r\nThis is very much specific to how BIP340 is constructed, where a signature is specified as a byte array. There isn't a distinction between \"format invalid\" and \"signature invalid\" like there is with ECDSA and DER signatures (where failing to parse a signature very well may have a different effect than failing to validate one).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-657932218",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 657975227,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY1Nzk3NTIyNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/657975227",
      "actor": {
        "login": "ZmnSCPxj",
        "id": 28175207,
        "node_id": "MDQ6VXNlcjI4MTc1MjA3",
        "avatar_url": "https://avatars.githubusercontent.com/u/28175207?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ZmnSCPxj",
        "html_url": "https://github.com/ZmnSCPxj",
        "followers_url": "https://api.github.com/users/ZmnSCPxj/followers",
        "following_url": "https://api.github.com/users/ZmnSCPxj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ZmnSCPxj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ZmnSCPxj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ZmnSCPxj/subscriptions",
        "organizations_url": "https://api.github.com/users/ZmnSCPxj/orgs",
        "repos_url": "https://api.github.com/users/ZmnSCPxj/repos",
        "events_url": "https://api.github.com/users/ZmnSCPxj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ZmnSCPxj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-14T05:27:55Z",
      "updated_at": "2020-07-14T05:35:09Z",
      "author_association": "NONE",
      "body": "Well, in C-Lighning we even have separate types for sha256-hash from sha256-applied-twice-hash (`struct sha256` vs `struct sha256d`).  And we can argue that hashes are just arrays of 32 bytes, we just `memcpy` them around and treat them as arrays of 32 bytes when serializing across our many internal boundaries.  But it is very convenient when passing them around between functions to have a distinct name for them, especially if those functions \"just\" pass them around, because those functions may be passing around other data of similar sizes anyway.\r\n\r\nAnyway, up to you; if you do not give a decent struct wrapper for signatures, we would on our side anyway.\r\n\r\nAlso, a good-enough C programmer knows how (and **when**) to typecast, especially if you admit that the structure is just a convenient tag for a flat array of 32 bytes.",
      "user": {
        "login": "ZmnSCPxj",
        "id": 28175207,
        "node_id": "MDQ6VXNlcjI4MTc1MjA3",
        "avatar_url": "https://avatars.githubusercontent.com/u/28175207?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ZmnSCPxj",
        "html_url": "https://github.com/ZmnSCPxj",
        "followers_url": "https://api.github.com/users/ZmnSCPxj/followers",
        "following_url": "https://api.github.com/users/ZmnSCPxj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ZmnSCPxj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ZmnSCPxj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ZmnSCPxj/subscriptions",
        "organizations_url": "https://api.github.com/users/ZmnSCPxj/orgs",
        "repos_url": "https://api.github.com/users/ZmnSCPxj/repos",
        "events_url": "https://api.github.com/users/ZmnSCPxj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ZmnSCPxj/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-657975227",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 658057933,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODA1NzkzMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/658057933",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-14T08:50:18Z",
      "updated_at": "2020-07-14T08:50:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "Perhaps best considered independent of this PR, regardless, as it would be a widespread API change.",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-658057933",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 658065565,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODA2NTU2NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/658065565",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-14T09:05:57Z",
      "updated_at": "2020-07-14T09:06:11Z",
      "author_association": "MEMBER",
      "body": "> But it is very convenient when passing them around between functions to have a distinct name for them, especially if those function\r\n\r\nIn addition to what Pieter said (simpler api, no unnecessary complexity, matches BIP340), I think there's value in suggesting to the user to treat the output of `sign` (or `prove` more generally) as a blob whose single purpose is to be transported to another program's `verify` function. This is a common concept in crypto libraries (see NaCl for example).\r\n\r\nOn the other hand BIP340 recommends to verify the signature immediately after signing. And the signature is input to a `adaptor_secret_extract` function in a musig module (but this is a less common use case).\r\n\r\nAgree that we can revisit this in a separate PR - this is an experimental module wrt the API after all.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-658065565",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 658080012,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY1ODA4MDAxMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/658080012",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-14T09:35:41Z",
      "updated_at": "2020-07-14T09:35:41Z",
      "author_association": "MEMBER",
      "body": "Using a plain byte array is also what we do in the API for secret keys, and it hasn't lead to trouble so far.\r\n\r\nAnd yes, this means you can screw up and use a signature as a secret key and the other way around. That's not nice but I believe if you do this, that's not a subtle bug and you don't need to type system to help you...",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-658080012",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 448344438,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MzQ0NDM4",
      "url": null,
      "actor": null,
      "commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "The `_keypair` flow is new and confused me a bit until I thought through the x-only pubkey considerations. Not sure what it would look like, but some explanation would probably be useful for \"layman\" users. Hard to mis-use at least as-is.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-448344438",
      "submitted_at": "2020-07-14T19:04:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 448391884,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MzkxODg0",
      "url": null,
      "actor": null,
      "commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-448391884",
      "submitted_at": "2020-07-14T19:14:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 660326742,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2MDMyNjc0Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/660326742",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-17T20:37:20Z",
      "updated_at": "2020-07-17T20:39:03Z",
      "author_association": "MEMBER",
      "body": "@instagibbs thank you for having a look!\r\n\r\n> some explanation would be useful\r\n\r\nYou mean an explanation of the rationale behind keypairs type or how to use it? For the latter best resource right now are the tests - in particular the [taproot test](https://github.com/bitcoin-core/secp256k1/commit/682a113f3a0a816c0f0391af9eef036133839335). EDIT: In the future we'll have usage examples (see https://github.com/bitcoin-core/secp256k1/pull/748).\r\n\r\nThe primary reason for keypairs isn't xonly, but that `schnorrsig_sign` requires a pubkey to compute the challenge hash. Recomputing the pubkey is expensive and if the function would accept a separate pubkey argument and it's attacker controlled somehow it can result in nonce reuse.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-660326742",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3559796102,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzU1OTc5NjEwMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3559796102",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-17T20:37:20Z"
    },
    {
      "event": "subscribed",
      "id": 3559796104,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM1NTk3OTYxMDQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3559796104",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-17T20:37:20Z"
    },
    {
      "event": "commented",
      "id": 660326786,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2MDMyNjc4Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/660326786",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-17T20:37:26Z",
      "updated_at": "2020-07-17T20:37:26Z",
      "author_association": "MEMBER",
      "body": "I pushed a few fixes. In particular, `tweak_add_test` is renamed to `tweak_add_check` to avoid confusion with tests and the attempt/counter argument of nonce_function_hardened is dropped because it doesn't have a purpose.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-660326786",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 451153752,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMTUzNzUy",
      "url": null,
      "actor": null,
      "commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I did a more thorough review of the entire diff (f39f99be0e6add959f534c03b93044cef066fe09...63bf929e60d913c6828b60ea08c96f37aa87a8ba) - only comment nits. \r\n\r\nWould it make sense to rebase and squash the fixups at this point? The final tree id I reviewed is 5f5227a7d432f5149d305085034b65a917d760c8.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-451153752",
      "submitted_at": "2020-07-19T19:42:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 451505447,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNTA1NDQ3",
      "url": null,
      "actor": null,
      "commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "LLFourn",
        "id": 3734083,
        "node_id": "MDQ6VXNlcjM3MzQwODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3734083?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LLFourn",
        "html_url": "https://github.com/LLFourn",
        "followers_url": "https://api.github.com/users/LLFourn/followers",
        "following_url": "https://api.github.com/users/LLFourn/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LLFourn/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LLFourn/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LLFourn/subscriptions",
        "organizations_url": "https://api.github.com/users/LLFourn/orgs",
        "repos_url": "https://api.github.com/users/LLFourn/repos",
        "events_url": "https://api.github.com/users/LLFourn/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LLFourn/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-451505447",
      "submitted_at": "2020-07-20T11:02:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 661295685,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTI5NTY4NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/661295685",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-20T19:44:38Z",
      "updated_at": "2020-07-20T19:44:38Z",
      "author_association": "MEMBER",
      "body": "@sipa\r\n\r\n> Attempt at improving: \"The expected parity of the output public key (whose serialization is passed in output_pubkey32). This must match the pk_parity value returned by secp256k1_xonly_pubkey_tweak_add when the output was created, or verification will fail.\"\r\n\r\npk_parity is created is not created by `secp256k1_xonly_pubkey_tweak_add` but by `secp256k1_xonly_pubkey_from_pubkey`. There's also some explanation at the top of the function. Tried to improve it nonetheless according to your suggestion.\r\n\r\n> Would it make sense to rebase and squash the fixups at this point?\r\n\r\nyes, will do.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-661295685",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3567539874,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzU2NzUzOTg3NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3567539874",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-20T19:44:38Z"
    },
    {
      "event": "subscribed",
      "id": 3567539881,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM1Njc1Mzk4ODE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3567539881",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-20T19:44:38Z"
    },
    {
      "event": "reviewed",
      "id": 452924933,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyOTI0OTMz",
      "url": null,
      "actor": null,
      "commit_id": "8d185a465bc63272caabd547b70cafb9968ffb30",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "benthecarman",
        "id": 15256660,
        "node_id": "MDQ6VXNlcjE1MjU2NjYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/15256660?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benthecarman",
        "html_url": "https://github.com/benthecarman",
        "followers_url": "https://api.github.com/users/benthecarman/followers",
        "following_url": "https://api.github.com/users/benthecarman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benthecarman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benthecarman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benthecarman/subscriptions",
        "organizations_url": "https://api.github.com/users/benthecarman/orgs",
        "repos_url": "https://api.github.com/users/benthecarman/repos",
        "events_url": "https://api.github.com/users/benthecarman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benthecarman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-452924933",
      "submitted_at": "2020-07-22T01:09:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3575428541,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzU3NTQyODU0MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3575428541",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-22T11:55:31Z"
    },
    {
      "event": "commented",
      "id": 662411367,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2MjQxMTM2Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/662411367",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-22T11:57:01Z",
      "updated_at": "2020-07-22T11:57:01Z",
      "author_association": "MEMBER",
      "body": "Squashed & rebased. Pre-force pushed version of this PR is archived at https://github.com/jonasnick/secp256k1/commit/8d185a465bc63272caabd547b70cafb9968ffb30.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-662411367",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 662689579,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2MjY4OTU3OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/662689579",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-22T20:50:45Z",
      "updated_at": "2020-07-23T19:06:33Z",
      "author_association": "MEMBER",
      "body": "I went through the comments on this PR again and everything has been addressed with the exception of\r\n\r\n- [ ] consider allowing variable len messages. I experimented with this in https://github.com/jonasnick/secp256k1/commits/schnorrsig-varmsg. There's not much to experiment though, it just adds a `size_t msg_len` argument and fixes the tests. (EDIT: this branch totally ignores domain separation)\r\n- [ ] the tweak apis are inconsistent (both legacy and xonly) as the seckey_tweak_add functions are constant time with respect to the tweak and pubkey_tweak_add are not. Similarly, the keypair_tweak_add is _not_ CT w.r.t. the tweak. This PR is consistent with the legacy API and reuses much of it's code. Therefore, if we consider changing this (I think we should), the easiest way is to change both legacy and xonly and that's best done in a different PR.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-662689579",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 662715520,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2MjcxNTUyMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/662715520",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-22T21:50:26Z",
      "updated_at": "2020-07-23T00:28:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "Variable length, if its done, can be done with another PR.  Same for tweak constant time stuff for the reason you gave. You should give this PR a better title (e.g. mention Bip340, I had one person I asked to review this respond in surprise that there wasn't a BIP assigned, I assume after they googled bip-schnorr and found an outdated doc) and also maybe remove mention of the batch stuff from the initial description (or change it to a pointer to the batch PR)",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-662715520",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "renamed",
      "id": 3581340517,
      "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50MzU4MTM0MDUxNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3581340517",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-23T19:07:06Z",
      "rename": {
        "from": " Add schnorrsig module which implements BIP-schnorr compliant signatures",
        "to": " Add schnorrsig module which implements BIP-340 compliant signatures"
      }
    },
    {
      "event": "commented",
      "id": 663187585,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2MzE4NzU4NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/663187585",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-23T19:21:13Z",
      "updated_at": "2020-07-23T19:21:13Z",
      "author_association": "MEMBER",
      "body": "Done. The link in the description  pointed to an outdated bip-schnorr document.\r\n\r\nI agree that variable length can be done in a different PR. It may even be preferable to add a new function for this because it'll need some mechanism to deal with domain separation.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-663187585",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 664383116,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NDM4MzExNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/664383116",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T13:03:58Z",
      "updated_at": "2020-07-27T13:03:58Z",
      "author_association": "NONE",
      "body": "I've read all the code in every commit, especially commit https://github.com/bitcoin-core/secp256k1/pull/558/commits/47dd51f6a16d30b072e6ba2182b6cc65000164f6 which seems to be where all the heavy lifting is done. I'm not an expert in cryptography, but I know how schnorr and ecdsa are meant to work. So hopefully this review is still useful. I only noticed an issue with one of the comments in the source code which I flagged up.",
      "user": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-664383116",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 664393224,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NDM5MzIyNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/664393224",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T13:22:23Z",
      "updated_at": "2020-07-27T13:22:23Z",
      "author_association": "MEMBER",
      "body": "> I've read all the code in every commit, especially commit [47dd51f](https://github.com/bitcoin-core/secp256k1/commit/47dd51f6a16d30b072e6ba2182b6cc65000164f6) which seems to be where all the heavy lifting is done. I'm not an expert in cryptography, but I know how schnorr and ecdsa are meant to work. \r\n\r\nThis is more than enough for a useful review! \r\n \r\n> I only noticed an issue with one of the comments in the source code which I flagged up.\r\n\r\nCan you point us to your comment again? I can't find it. (Sometimes GitHub seem to not display comments, in particular when you review the PR commit-by-commit and then comment on a single commit. Maybe that's the issue here.)  \r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-664393224",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 664393791,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NDM5Mzc5MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/664393791",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T13:23:24Z",
      "updated_at": "2020-07-27T13:23:24Z",
      "author_association": "MEMBER",
      "body": "@chris-belcher Thanks for the review! I can't fnd your comment here, but I saw it in my email inbox. Implicitly choosing the pubkey based on the evenness of the Y coordinate is consistent with BIP-340. But it's inconsistent with an older version of the BIP in @sipa's bips fork which is the first result when I google \"bip-schnorr\". @sipa can you remove that branch?",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-664393791",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3589831687,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzU4OTgzMTY4Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3589831687",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T13:23:24Z"
    },
    {
      "event": "subscribed",
      "id": 3589831690,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM1ODk4MzE2OTA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3589831690",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T13:23:24Z"
    },
    {
      "event": "mentioned",
      "id": 3589831702,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzU4OTgzMTcwMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3589831702",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T13:23:24Z"
    },
    {
      "event": "subscribed",
      "id": 3589831708,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM1ODk4MzE3MDg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3589831708",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T13:23:24Z"
    },
    {
      "event": "commented",
      "id": 664685881,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NDY4NTg4MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/664685881",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T23:16:53Z",
      "updated_at": "2020-07-27T23:19:30Z",
      "author_association": "MEMBER",
      "body": "ACK 2c8e321a1b543e1f008a32c0a9091b752ccf8e72\r\n\r\nReviewed the diff with my previous review (only rebase, addressing a few comments, `secp256k1_xonly_pubkey_tweak_add` wipes its output slightly earlier, `test_xonly_pubkey_tweak_add_check` is renamed to `test_xonly_pubkey_tweak_add`), and re-reviewed 47dd51f6a16d30b072e6ba2182b6cc65000164f6 on its own.\r\n\r\nThe variable-length API I think needs some more discussion, and can be done later.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-664685881",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 664687715,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NDY4NzcxNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/664687715",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T23:22:44Z",
      "updated_at": "2020-07-27T23:22:44Z",
      "author_association": "MEMBER",
      "body": "@jonasnick Deleted my outdated bip-schnorr branch (which was also my default branch, changed that as well).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-664687715",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3591992626,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzU5MTk5MjYyNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3591992626",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T23:22:45Z"
    },
    {
      "event": "subscribed",
      "id": 3591992628,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM1OTE5OTI2Mjg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3591992628",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-27T23:22:45Z"
    },
    {
      "event": "commented",
      "id": 665111893,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NTExMTg5Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/665111893",
      "actor": {
        "login": "gruve-p",
        "id": 11212268,
        "node_id": "MDQ6VXNlcjExMjEyMjY4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11212268?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gruve-p",
        "html_url": "https://github.com/gruve-p",
        "followers_url": "https://api.github.com/users/gruve-p/followers",
        "following_url": "https://api.github.com/users/gruve-p/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gruve-p/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gruve-p/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gruve-p/subscriptions",
        "organizations_url": "https://api.github.com/users/gruve-p/orgs",
        "repos_url": "https://api.github.com/users/gruve-p/repos",
        "events_url": "https://api.github.com/users/gruve-p/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gruve-p/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-28T15:34:45Z",
      "updated_at": "2020-07-28T15:34:45Z",
      "author_association": "NONE",
      "body": "ACK https://github.com/bitcoin-core/secp256k1/commit/2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "user": {
        "login": "gruve-p",
        "id": 11212268,
        "node_id": "MDQ6VXNlcjExMjEyMjY4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11212268?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gruve-p",
        "html_url": "https://github.com/gruve-p",
        "followers_url": "https://api.github.com/users/gruve-p/followers",
        "following_url": "https://api.github.com/users/gruve-p/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gruve-p/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gruve-p/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gruve-p/subscriptions",
        "organizations_url": "https://api.github.com/users/gruve-p/orgs",
        "repos_url": "https://api.github.com/users/gruve-p/repos",
        "events_url": "https://api.github.com/users/gruve-p/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gruve-p/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-665111893",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 455756677,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NzU2Njc3",
      "url": null,
      "actor": null,
      "commit_id": "95dd2c73c55ce48518d56f7a0d0fb48e59242ddd",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-455756677",
      "submitted_at": "2020-07-31T13:24:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 667117972,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NzExNzk3Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/667117972",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:24:40Z",
      "updated_at": "2020-07-31T13:24:40Z",
      "author_association": "NONE",
      "body": "I forgot to click \"Submit review\" on my comment, which is why it wasn't showing up. Fixed now.",
      "user": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-667117972",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 667119391,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NzExOTM5MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/667119391",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:27:55Z",
      "updated_at": "2020-07-31T13:29:29Z",
      "author_association": "NONE",
      "body": "> @chris-belcher Thanks for the review! I can't fnd your comment here, but I saw it in my email inbox. Implicitly choosing the pubkey based on the evenness of the Y coordinate is consistent with BIP-340. But it's inconsistent with an older version of the BIP in @sipa's bips fork which is the first result when I google \"bip-schnorr\". @sipa can you remove that branch?\r\n\r\nI'm reading the bip document [here](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) which is linked from the OP. I'll quote the part which confuses me (and add my italics):\r\n\r\n> **Implicit Y coordinates** In order to support efficient verification and batch verification, the Y coordinate of P and of R cannot be ambiguous (every valid X coordinate has two possible Y coordinates). We have a choice between several options for symmetry breaking:\r\n\r\n>    1. Implicitly choosing the Y coordinate that is in the lower half.\r\n>    2. Implicitly choosing the Y coordinate that is even[5].\r\n>    3. Implicitly choosing the Y coordinate that is a quadratic residue (has a square root modulo the field size, or \"is a square\" for short)[6].\r\n\r\n> In the case of R the third option is slower at signing time but a bit faster to verify, as it is possible to directly compute whether the Y coordinate is a square when the points are represented in Jacobian coordinates (a common optimization to avoid modular inverses for elliptic curve operations). The two other options require a possibly expensive conversion to affine coordinates first. This would even be the case if the sign or oddness were explicitly coded (option 2 in the list above). *We therefore choose option 3.*\r\n\r\nBy my reading, it looks like the bip uses the quadratic residue to determine the Y coordinate (i.e. option 3). and not the evenness (i.e. option 2). What am I missing?",
      "user": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-667119391",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3608516003,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzYwODUxNjAwMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3608516003",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:27:55Z"
    },
    {
      "event": "subscribed",
      "id": 3608516005,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM2MDg1MTYwMDU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3608516005",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:27:55Z"
    },
    {
      "event": "mentioned",
      "id": 3608516008,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzYwODUxNjAwOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3608516008",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:27:55Z"
    },
    {
      "event": "subscribed",
      "id": 3608516011,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM2MDg1MTYwMTE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3608516011",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:27:55Z"
    },
    {
      "event": "commented",
      "id": 667123406,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2NzEyMzQwNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/667123406",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:36:42Z",
      "updated_at": "2020-07-31T13:36:42Z",
      "author_association": "MEMBER",
      "body": "@chris-belcher You're missing the first few words in the paragraph: \"In the case of R\" (the nonce). That's what \"We therefore choose option 3\" refers to. The next paragraph states \"For P[...]. We choose the second option\".",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-667123406",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3608552710,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzYwODU1MjcxMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3608552710",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:36:42Z"
    },
    {
      "event": "subscribed",
      "id": 3608552712,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM2MDg1NTI3MTI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3608552712",
      "actor": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-07-31T13:36:42Z"
    },
    {
      "event": "reviewed",
      "id": 461832283,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODMyMjgz",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-461832283",
      "submitted_at": "2020-08-05T16:31:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 669332727,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY2OTMzMjcyNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/669332727",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-05T17:43:04Z",
      "updated_at": "2020-08-05T17:43:04Z",
      "author_association": "MEMBER",
      "body": "needs rebase (sorry :/)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-669332727",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 461893475,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODkzNDc1",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-461893475",
      "submitted_at": "2020-08-05T17:52:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 462586688,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNTg2Njg4",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-462586688",
      "submitted_at": "2020-08-06T14:41:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 462612908,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNjEyOTA4",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-462612908",
      "submitted_at": "2020-08-06T15:09:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463258321,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjU4MzIx",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463258321",
      "submitted_at": "2020-08-07T12:05:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463284669,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjg0NjY5",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463284669",
      "submitted_at": "2020-08-07T12:49:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463416567,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDE2NTY3",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463416567",
      "submitted_at": "2020-08-07T15:45:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463436401,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDM2NDAx",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463436401",
      "submitted_at": "2020-08-07T16:14:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463448270,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDQ4Mjcw",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I looked at the API. I'll have closer look again soon!",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463448270",
      "submitted_at": "2020-08-07T16:46:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463465650,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDY1NjUw",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463465650",
      "submitted_at": "2020-08-07T17:00:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463498840,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDk4ODQw",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463498840",
      "submitted_at": "2020-08-07T17:54:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463512636,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNTEyNjM2",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463512636",
      "submitted_at": "2020-08-07T18:17:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463530343,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNTMwMzQz",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463530343",
      "submitted_at": "2020-08-07T18:47:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 463590980,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNTkwOTgw",
      "url": null,
      "actor": null,
      "commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463590980",
      "submitted_at": "2020-08-07T20:26:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 671111590,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY3MTExMTU5MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/671111590",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-09T23:04:35Z",
      "updated_at": "2020-08-09T23:04:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "Anyone written an exhaustive test?  I just noticed there isn't one in this PR.",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-671111590",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 463921617,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTIxNjE3",
      "url": null,
      "actor": null,
      "commit_id": "c024c80af386e0fd9239db5c6967bdd6fd5b1ebb",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-463921617",
      "submitted_at": "2020-08-10T01:00:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 671125751,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY3MTEyNTc1MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/671125751",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-10T01:03:37Z",
      "updated_at": "2020-08-10T01:03:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "Test short-comings:\r\n\r\nThis should be caught both by a real test and probably by a vector (perhaps ideally by a vector that would be a valid signature if reduced mod the order), and ideally the boundary should also be tested exactly (but I think an exact boundary test would require mocking the schnorr hash). \r\n\r\n```diff\r\ndiff --git a/src/modules/schnorrsig/main_impl.h b/src/modules/schnorrsig/main_impl.h\r\nindex 2ec1cea..d8db70a 100644\r\n--- a/src/modules/schnorrsig/main_impl.h\r\n+++ b/src/modules/schnorrsig/main_impl.h\r\n@@ -202,7 +202,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\r\n     }\r\n \r\n     secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\r\n-    if (overflow) {\r\n+    if (0&&overflow) {\r\n         return 0;\r\n     }\r\n \r\n```\r\n\r\nThis one appears to be only tested by the BIP340 vectors. I think that ideally all major functionality should be tested by both a static vector and some kind of dynamic test since vectors are extremely brittle.  The brittleness is both an asset because they can be very sensitive and a liability because they tend to get blindly replaced when there are major changes (which were expected to break them) and aren't very broad (a bug might just happen to pass the few things there are vectors for).\r\n\r\nThis one can be resolved with a test that randomly signs stuff and negates the s and makes sure the result never passes.\r\n\r\n```diff\r\n diff --git a/src/modules/schnorrsig/main_impl.h b/src/modules/schnorrsig/main_impl.h\r\nindex 2ec1cea..5efdee4 100644\r\n--- a/src/modules/schnorrsig/main_impl.h\r\n+++ b/src/modules/schnorrsig/main_impl.h\r\n@@ -223,8 +223,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\r\n     secp256k1_gej_set_ge(&pkj, &pk);\r\n     secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\r\n \r\n-    return secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\r\n-            && secp256k1_gej_eq_x_var(&rx, &rj);\r\n+    return secp256k1_gej_eq_x_var(&rx, &rj);\r\n }\r\n \r\n #endif\r\n```\r\n\r\nI admit I'm being extremely nitpicky here, but I think it is best to not only have tests on a few constant values, and this passes with the BIP340 vectors off.  It should be easy to also test secp256k1_xonly_pubkey_parse on  random points on the twist in addition to zero. (though zero is a pretty good and important value too)\r\n\r\n```diff\r\ndiff --git a/src/modules/extrakeys/main_impl.h b/src/modules/extrakeys/main_impl.h\r\nindex a2abc6a..c5573dd 100644\r\n--- a/src/modules/extrakeys/main_impl.h\r\n+++ b/src/modules/extrakeys/main_impl.h\r\n@@ -30,7 +30,8 @@ int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_p\r\n     if (!secp256k1_fe_set_b32(&x, input32)) {\r\n         return 0;\r\n     }\r\n-    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\r\n+    secp256k1_ge_set_xo_var(&pk, &x, 0);\r\n+    if (secp256k1_fe_is_zero(&x)) {\r\n         return 0;\r\n     }\r\n     secp256k1_xonly_pubkey_save(pubkey, &pk);\r\n```\r\n\r\n\r\n[offtopic comment: ./tests 2 is a bit weak on some of these tests, I'm guessing that it is also weak on other ones outside of this module. It's only worth mentioning because some of the CI tests run with 2.  I don't think anything should be changed in this PR with respect to that, though perhaps all the fast random tests should get their base counts multiplied a bit so if they're 50/50 likely to pass they'll still get pretty reliably detected even with ./tests 2.]\r\n\r\nI think the tests in this PR are **extremely** good regardless of the above nitpicks.\r\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-671125751",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 464681927,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjgxOTI3",
      "url": null,
      "actor": null,
      "commit_id": "95dd2c73c55ce48518d56f7a0d0fb48e59242ddd",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-464681927",
      "submitted_at": "2020-08-11T01:02:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 464688314,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Njg4MzE0",
      "url": null,
      "actor": null,
      "commit_id": "8409443226b314d23e90f84c210fba0bd97beb78",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-464688314",
      "submitted_at": "2020-08-11T01:23:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 464690067,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjkwMDY3",
      "url": null,
      "actor": null,
      "commit_id": "8409443226b314d23e90f84c210fba0bd97beb78",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-464690067",
      "submitted_at": "2020-08-11T01:29:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 465164275,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MTY0Mjc1",
      "url": null,
      "actor": null,
      "commit_id": "e8a3d6ce063e9c08135130a83b93fd32385ce87b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-465164275",
      "submitted_at": "2020-08-11T15:09:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 672112150,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjExMjE1MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/672112150",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-11T17:22:57Z",
      "updated_at": "2020-08-11T17:22:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 2c8e321a1b543e1f008a32c0a9091b752ccf8e72 aside from nits others have noted. Ran test suite and benchmarks (for those commits which had them) in valgrind for every commit. Would be nice to have an exhaustive test.\r\n\r\nThis does need a rebase though :)",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-672112150",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 675588813,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY3NTU4ODgxMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/675588813",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-18T16:41:55Z",
      "updated_at": "2020-08-18T16:42:27Z",
      "author_association": "MEMBER",
      "body": "I pushed a few commits that should addresses all comments with the exception of\r\n\r\n- exhaustive tests. I think this PR is complex enough as it is and we can do this in a separate PR.\r\n- [simpler default sign function](https://github.com/bitcoin-core/secp256k1/pull/558/files/2c8e321a1b543e1f008a32c0a9091b752ccf8e72#r467189434)\r\n\r\nLet me know if the new commits are sufficient. I'll squash and rebase then.\r\n\r\n@gmaxwell\r\n\r\n```\r\n> -    if (overflow) {\r\n> +    if (0&&overflow) {\r\n```\r\n\r\nI don't think we can fix that with the current testing capabilities (i.e. without mocking the hash function, or low order generator mode). This branch is covered by test vector 13, but vector 13 fails regardless of the branch. I added a randomized test anyway.\r\n\r\n```\r\n-    return secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\r\n-            && secp256k1_gej_eq_x_var(&rx, &rj);\r\n+    return secp256k1_gej_eq_x_var(&rx, &rj);\r\n```\r\n\r\nAdded randomized test.\r\n\r\n```\r\n-    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\r\n+    secp256k1_ge_set_xo_var(&pk, &x, 0);\r\n+    if (secp256k1_fe_is_zero(&x)) {\r\n```\r\n\r\nThat's quite a sophisticated mutation. Added randomized test.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-675588813",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3667217392,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzY2NzIxNzM5Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3667217392",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-18T16:41:55Z"
    },
    {
      "event": "subscribed",
      "id": 3667217397,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM2NjcyMTczOTc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3667217397",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-18T16:41:55Z"
    },
    {
      "event": "reviewed",
      "id": 472939581,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTM5NTgx",
      "url": null,
      "actor": null,
      "commit_id": "cea1ed2b60b5b4c34a7ec7d95e9cf98b42e7c4fc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-472939581",
      "submitted_at": "2020-08-22T17:19:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 678668571,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY3ODY2ODU3MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/678668571",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-22T17:27:52Z",
      "updated_at": "2020-08-22T17:27:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "The above changes all look fine to me and can be squashed whenever people are done looking at them.",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-678668571",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 679100381,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY3OTEwMDM4MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/679100381",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-24T12:36:26Z",
      "updated_at": "2020-08-24T12:36:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks! that looks good!",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-679100381",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 679436043,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY3OTQzNjA0Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/679436043",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-25T00:40:11Z",
      "updated_at": "2020-08-25T00:40:11Z",
      "author_association": "MEMBER",
      "body": "ACK all the fixup changes. I'm happy with them being squashed.\r\n\r\nHow are you thinking of making the even-r changes? A separate commit on top that gets squashed in after the BIP change is complete?",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-679436043",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6M2UwOGIwMmUyYTc4ZjJhMWZjNDU3ZWZhYjY2NWRiOGFiODA4NTM3Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3e08b02e2a78f2a1fc457efab665db8ab8085373",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3e08b02e2a78f2a1fc457efab665db8ab8085373",
      "tree": {
        "sha": "037ed0171b3e40713b93d8aebc44edcdea85e47d",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/037ed0171b3e40713b93d8aebc44edcdea85e47d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/670cdd3f8be25f81472b2d16dcd228b0d24a5c45",
          "sha": "670cdd3f8be25f81472b2d16dcd228b0d24a5c45",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/670cdd3f8be25f81472b2d16dcd228b0d24a5c45"
        }
      ],
      "message": "Make the secp256k1_declassify argument constant\n\nThis is required to declassify pointers to constant memory. Declassify should\nnever modify its argument.",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-08-26T19:52:03Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-03-30T14:51:38Z"
      },
      "sha": "3e08b02e2a78f2a1fc457efab665db8ab8085373"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NDdlNjYxOGUxMTgxM2NmYWJlOTFmMDkwOWNhMDMxZjk2MGNiN2RkNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/47e6618e11813cfabe91f0909ca031f960cb7dd4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/47e6618e11813cfabe91f0909ca031f960cb7dd4",
      "tree": {
        "sha": "72a8ccd6fb6e83f070bb5a27627dfa9bbe40dfde",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/72a8ccd6fb6e83f070bb5a27627dfa9bbe40dfde"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3e08b02e2a78f2a1fc457efab665db8ab8085373",
          "sha": "3e08b02e2a78f2a1fc457efab665db8ab8085373",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3e08b02e2a78f2a1fc457efab665db8ab8085373"
        }
      ],
      "message": "extrakeys: Init empty experimental module\n\nThis is to prepare for xonly_pubkeys and keypairs.",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-08-26T19:52:55Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T13:58:47Z"
      },
      "sha": "47e6618e11813cfabe91f0909ca031f960cb7dd4"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3696576490,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzY5NjU3NjQ5MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3696576490",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-26T20:53:35Z"
    },
    {
      "event": "commented",
      "id": 681122143,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTEyMjE0Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/681122143",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-26T21:02:25Z",
      "updated_at": "2020-08-26T21:02:25Z",
      "author_association": "MEMBER",
      "body": "Added missing context frees in extrakeys tests, rebased and squashed. Checked that every commit compiles and runs the tests successfully.\r\n\r\n> A separate commit on top that gets squashed in after the BIP change is complete?\r\n\r\nYeah, that would be my plan. Fwiw I already wrote these commits to test the test vectors and pushed them to https://github.com/jonasnick/secp256k1/commits/schnorrsig-even-R.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-681122143",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 681380874,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTM4MDg3NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/681380874",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-27T04:18:41Z",
      "updated_at": "2020-08-27T04:18:41Z",
      "author_association": "MEMBER",
      "body": "Squash away: https://github.com/bitcoin/bips/pull/982",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-681380874",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 477104078,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTA0MDc4",
      "url": null,
      "actor": null,
      "commit_id": "2ebf20f30b733a940e3aacf2e6bf756f1ffc74d9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-477104078",
      "submitted_at": "2020-08-27T21:41:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 477117034,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTE3MDM0",
      "url": null,
      "actor": null,
      "commit_id": "79da28a01d28dd7792ab77cc5d3b16450e60303d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-477117034",
      "submitted_at": "2020-08-27T22:06:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 682251656,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4MjI1MTY1Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/682251656",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-28T00:06:28Z",
      "updated_at": "2020-08-28T00:06:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK BIP340 fixups.  Also I'd be fine with a commit that removes the unused stuff, or if @jonasnick  prefers that could be left for another PR.",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-682251656",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "mentioned",
      "id": 3701841193,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzcwMTg0MTE5Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3701841193",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-28T00:06:28Z"
    },
    {
      "event": "subscribed",
      "id": 3701841194,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM3MDE4NDExOTQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3701841194",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-28T00:06:28Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3711332709,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzcxMTMzMjcwOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3711332709",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-31T19:33:58Z"
    },
    {
      "event": "commented",
      "id": 683990472,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4Mzk5MDQ3Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/683990472",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-31T19:36:48Z",
      "updated_at": "2020-08-31T19:36:48Z",
      "author_association": "MEMBER",
      "body": "Squashed and did not remove the unused stuff because I'd prefer to avoid increasing the scope of this PR.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-683990472",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 684084998,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4NDA4NDk5OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/684084998",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-08-31T22:56:04Z",
      "updated_at": "2020-08-31T22:56:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK fb442254ef88d6bfcfe76cf25236ebda02bad795\r\n\r\nThanks for the trivial improvement to the ct tests in your latest update.  I reviewed that the squash was just a squash (plus the trivial additional fixup in the ct tests) and that the code otherwise matched exactly the version I had previously reviewed extensively and tested.  I also additionally tested the dist tarballs on a couple platforms, valgrinded the tests/benchmarks, and injected faults to make sure the tests failed.\r\n\r\nStuff I consider TODO for a follow-up PR: exhaustive tests and removal of the dead code.\r\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-684084998",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "referenced",
      "id": 3717318038,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM3MTczMTgwMzg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3717318038",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "f49c9896b0d03d7dc45515260760659879c5728e",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/f49c9896b0d03d7dc45515260760659879c5728e",
      "created_at": "2020-09-02T00:22:10Z"
    },
    {
      "event": "reviewed",
      "id": 480144996,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTQ0OTk2",
      "url": null,
      "actor": null,
      "commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Code Review ACK fb44225 pending on https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481480781, https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481498617 and https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481506817. I'm surely missing context, I'm not a cryptographer no more familiar with libsecp256k1.\r\n\r\nThe rest of comments reviews are mostly call for better comments/design questions and can be discarded.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-480144996",
      "submitted_at": "2020-09-02T00:50:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 480791168,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNzkxMTY4",
      "url": null,
      "actor": null,
      "commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jrawsthorne",
        "id": 777143,
        "node_id": "MDQ6VXNlcjc3NzE0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/777143?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jrawsthorne",
        "html_url": "https://github.com/jrawsthorne",
        "followers_url": "https://api.github.com/users/jrawsthorne/followers",
        "following_url": "https://api.github.com/users/jrawsthorne/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jrawsthorne/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jrawsthorne/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jrawsthorne/subscriptions",
        "organizations_url": "https://api.github.com/users/jrawsthorne/orgs",
        "repos_url": "https://api.github.com/users/jrawsthorne/repos",
        "events_url": "https://api.github.com/users/jrawsthorne/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jrawsthorne/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-480791168",
      "submitted_at": "2020-09-02T12:57:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "subscribed",
      "id": 3719940718,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM3MTk5NDA3MTg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3719940718",
      "actor": {
        "login": "ktinubu",
        "id": 17952332,
        "node_id": "MDQ6VXNlcjE3OTUyMzMy",
        "avatar_url": "https://avatars.githubusercontent.com/u/17952332?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ktinubu",
        "html_url": "https://github.com/ktinubu",
        "followers_url": "https://api.github.com/users/ktinubu/followers",
        "following_url": "https://api.github.com/users/ktinubu/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ktinubu/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ktinubu/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ktinubu/subscriptions",
        "organizations_url": "https://api.github.com/users/ktinubu/orgs",
        "repos_url": "https://api.github.com/users/ktinubu/repos",
        "events_url": "https://api.github.com/users/ktinubu/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ktinubu/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-02T13:50:05Z"
    },
    {
      "event": "reviewed",
      "id": 482188501,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTg4NTAx",
      "url": null,
      "actor": null,
      "commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Thanks for your review @ariard. ",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-482188501",
      "submitted_at": "2020-09-03T21:51:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 687197413,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4NzE5NzQxMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/687197413",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-04T14:53:18Z",
      "updated_at": "2020-09-04T14:53:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK latest fixups",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-687197413",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 687326450,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4NzMyNjQ1MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/687326450",
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-04T19:01:54Z",
      "updated_at": "2020-09-04T19:01:54Z",
      "author_association": "NONE",
      "body": "ACK 79785f0",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-687326450",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 687526383,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4NzUyNjM4Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/687526383",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-05T02:21:26Z",
      "updated_at": "2020-09-05T02:21:49Z",
      "author_association": "MEMBER",
      "body": "I've written exhaustive tests for the schnorrsig sign/verify (and also for part of the extrakeys functions): https://github.com/sipa/secp256k1/commits/202009_schnorrsig_exhaustive\r\n\r\nFeel free to cherry-pick, but it's probably better to add them as a follow-up (especially as it includes a few refactors as well).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-687526383",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3734368153,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzczNDM2ODE1Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3734368153",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-06T18:59:47Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NGNkMmVlNDc0ZDE3OGJkMWI1NjAyNDg2MTA0ZGIzNDZhNzU2MmM2Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4cd2ee474d178bd1b5602486104db346a7562c67",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4cd2ee474d178bd1b5602486104db346a7562c67",
      "tree": {
        "sha": "dac152a5c7e6708964d1edfc9ce02977a08a0bbd",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/dac152a5c7e6708964d1edfc9ce02977a08a0bbd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/47e6618e11813cfabe91f0909ca031f960cb7dd4",
          "sha": "47e6618e11813cfabe91f0909ca031f960cb7dd4",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/47e6618e11813cfabe91f0909ca031f960cb7dd4"
        }
      ],
      "message": "extrakeys: Add xonly_pubkey with serialize, parse and from_pubkey",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T18:59:50Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T14:40:28Z"
      },
      "sha": "4cd2ee474d178bd1b5602486104db346a7562c67"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MTc2YmZiMTExMDE0N2I1ZGNhMTgzNGVhMDcxYWNjODQ2ZmIxY2FiMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/176bfb1110147b5dca1834ea071acc846fb1cab3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/176bfb1110147b5dca1834ea071acc846fb1cab3",
      "tree": {
        "sha": "521627980ec68ee79f44832175df46175c77efbe",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/521627980ec68ee79f44832175df46175c77efbe"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4cd2ee474d178bd1b5602486104db346a7562c67",
          "sha": "4cd2ee474d178bd1b5602486104db346a7562c67",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4cd2ee474d178bd1b5602486104db346a7562c67"
        }
      ],
      "message": "Separate helper function for ec_pubkey_tweak_add\n\nThis is in preparation for allowing code reuse by xonly tweak add functions",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T18:59:57Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T14:45:22Z"
      },
      "sha": "176bfb1110147b5dca1834ea071acc846fb1cab3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6OTEwZDljMjg0YzMzYjc3Nzc0YTkzMTZkNDUyNGYzMTMzNTdkNDQxYw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/910d9c284c33b77774a9316d4524f313357d441c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/910d9c284c33b77774a9316d4524f313357d441c",
      "tree": {
        "sha": "a8860580123157cb0e9c050182e2945023fcc1c3",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a8860580123157cb0e9c050182e2945023fcc1c3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/176bfb1110147b5dca1834ea071acc846fb1cab3",
          "sha": "176bfb1110147b5dca1834ea071acc846fb1cab3",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/176bfb1110147b5dca1834ea071acc846fb1cab3"
        }
      ],
      "message": "extrakeys: Add xonly_pubkey_tweak_add & xonly_pubkey_tweak_add_test",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T18:59:57Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T14:49:12Z"
      },
      "sha": "910d9c284c33b77774a9316d4524f313357d441c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZjAwMTAzNDliODc2YmM2YjNmMGE2ZWM2YzhiYWQwYjEyY2ExN2I1MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f0010349b876bc6b3f0a6ec6c8bad0b12ca17b51",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f0010349b876bc6b3f0a6ec6c8bad0b12ca17b51",
      "tree": {
        "sha": "217eeec4f3ae8e2cef119ead603186f9c1f37a03",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/217eeec4f3ae8e2cef119ead603186f9c1f37a03"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/910d9c284c33b77774a9316d4524f313357d441c",
          "sha": "910d9c284c33b77774a9316d4524f313357d441c",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/910d9c284c33b77774a9316d4524f313357d441c"
        }
      ],
      "message": "Separate helper functions for pubkey_create and seckey_tweak_add\n\nThis is in preparation for allowing code reuse by keypair functions",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T18:59:57Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T14:43:48Z"
      },
      "sha": "f0010349b876bc6b3f0a6ec6c8bad0b12ca17b51"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NTgyNTQ0NjNmOWEyZTk2ZDg5MzE1N2EzNDFjOTk1M2M0NDBmZGY2MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/58254463f9a2e96d893157a341c9953c440fdf60",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/58254463f9a2e96d893157a341c9953c440fdf60",
      "tree": {
        "sha": "9473f2690fa802c7d31a7e10c2f3c9eca663b08b",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/9473f2690fa802c7d31a7e10c2f3c9eca663b08b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f0010349b876bc6b3f0a6ec6c8bad0b12ca17b51",
          "sha": "f0010349b876bc6b3f0a6ec6c8bad0b12ca17b51",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f0010349b876bc6b3f0a6ec6c8bad0b12ca17b51"
        }
      ],
      "message": "extrakeys: Add keypair struct with create, pub and pub_xonly",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T18:59:57Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T14:52:34Z"
      },
      "sha": "58254463f9a2e96d893157a341c9953c440fdf60"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NmZjYjViODQ1ZDI4MzJjZTAxOWQ2MDUwNzAzM2Y3NDQyNjI5MDc2OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/6fcb5b845d2832ce019d60507033f74426290768",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/6fcb5b845d2832ce019d60507033f74426290768",
      "tree": {
        "sha": "ab942556ae2244ada3bc64832898fdd16a9a9c98",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ab942556ae2244ada3bc64832898fdd16a9a9c98"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/58254463f9a2e96d893157a341c9953c440fdf60",
          "sha": "58254463f9a2e96d893157a341c9953c440fdf60",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/58254463f9a2e96d893157a341c9953c440fdf60"
        }
      ],
      "message": "extrakeys: Add keypair_xonly_tweak_add",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T19:00:00Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-07-22T09:09:34Z"
      },
      "sha": "6fcb5b845d2832ce019d60507033f74426290768"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZWFiZDliYzQ2YTMxYzBkYTZkYjZkODg4NDBlYWRiZTkwMDY0NDdiMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/eabd9bc46a31c0da6db6d88840eadbe9006447b1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/eabd9bc46a31c0da6db6d88840eadbe9006447b1",
      "tree": {
        "sha": "d96729fbbcaf9570e418611159579a016708f0d8",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/d96729fbbcaf9570e418611159579a016708f0d8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/6fcb5b845d2832ce019d60507033f74426290768",
          "sha": "6fcb5b845d2832ce019d60507033f74426290768",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/6fcb5b845d2832ce019d60507033f74426290768"
        }
      ],
      "message": "Allow initializing tagged sha256\n\nThis will be used by the schnorrsig module",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T19:00:03Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2019-11-14T13:53:46Z"
      },
      "sha": "eabd9bc46a31c0da6db6d88840eadbe9006447b1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6N2E3MDNmZDk3ZGIwMTYxYmFlMDdlZjg0NTEzZGRkZTZlMGQyNzM1Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7a703fd97db0161bae07ef84513ddde6e0d27353",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7a703fd97db0161bae07ef84513ddde6e0d27353",
      "tree": {
        "sha": "050103c56cd9997a65d0fdb235575e34d729a272",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/050103c56cd9997a65d0fdb235575e34d729a272"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/eabd9bc46a31c0da6db6d88840eadbe9006447b1",
          "sha": "eabd9bc46a31c0da6db6d88840eadbe9006447b1",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/eabd9bc46a31c0da6db6d88840eadbe9006447b1"
        }
      ],
      "message": "schnorrsig: Init empty experimental module",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T19:00:03Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T21:19:03Z"
      },
      "sha": "7a703fd97db0161bae07ef84513ddde6e0d27353"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NzMzMmQyZGI2YjYyZmRhODUxZjllZDhhZGJmZGExODdhODc1Yjg0ZQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7332d2db6b62fda851f9ed8adbfda187a875b84e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7332d2db6b62fda851f9ed8adbfda187a875b84e",
      "tree": {
        "sha": "3d5d2eaea67670fc49769440f20da0859cb6f86b",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3d5d2eaea67670fc49769440f20da0859cb6f86b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7a703fd97db0161bae07ef84513ddde6e0d27353",
          "sha": "7a703fd97db0161bae07ef84513ddde6e0d27353",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7a703fd97db0161bae07ef84513ddde6e0d27353"
        }
      ],
      "message": "schnorrsig: Add BIP-340 nonce function",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T19:00:03Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T21:23:22Z"
      },
      "sha": "7332d2db6b62fda851f9ed8adbfda187a875b84e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NGU0MzUyMDAyNmY1YmNkMTgyZDIxZjA3NTliYWMxNTllZjQ3YmI2Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4e43520026f5bcd182d21f0759bac159ef47bb62",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4e43520026f5bcd182d21f0759bac159ef47bb62",
      "tree": {
        "sha": "d91575c500735deda296557a37d6db2a2494f734",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/d91575c500735deda296557a37d6db2a2494f734"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7332d2db6b62fda851f9ed8adbfda187a875b84e",
          "sha": "7332d2db6b62fda851f9ed8adbfda187a875b84e",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7332d2db6b62fda851f9ed8adbfda187a875b84e"
        }
      ],
      "message": "schnorrsig: Add BIP-340 compatible signing and verification",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T19:00:03Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T16:17:59Z"
      },
      "sha": "4e43520026f5bcd182d21f0759bac159ef47bb62"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6OGRmZDUzZWUzZmEwNTk1NjI0ODNkMTg2NzgxNWY3OGI5ZTAwZDk0Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8dfd53ee3fa059562483d1867815f78b9e00d947",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8dfd53ee3fa059562483d1867815f78b9e00d947",
      "tree": {
        "sha": "d93ee69d0686e78fbf195dfacac454478a7e140d",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/d93ee69d0686e78fbf195dfacac454478a7e140d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4e43520026f5bcd182d21f0759bac159ef47bb62",
          "sha": "4e43520026f5bcd182d21f0759bac159ef47bb62",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4e43520026f5bcd182d21f0759bac159ef47bb62"
        }
      ],
      "message": "schnorrsig: Add benchmark for sign and verify",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T19:00:08Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-05-12T21:24:38Z"
      },
      "sha": "8dfd53ee3fa059562483d1867815f78b9e00d947"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MTZmZmE5ZDk3Y2VmOTNmNDk1NDRiMDE2MzM5YzEwNzg4MmY5YTFjMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/16ffa9d97cef93f49544b016339c107882f9a1c3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/16ffa9d97cef93f49544b016339c107882f9a1c3",
      "tree": {
        "sha": "559f86638989cbd7446a3b8bcb82bc9a5cd1e4cf",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/559f86638989cbd7446a3b8bcb82bc9a5cd1e4cf"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8dfd53ee3fa059562483d1867815f78b9e00d947",
          "sha": "8dfd53ee3fa059562483d1867815f78b9e00d947",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8dfd53ee3fa059562483d1867815f78b9e00d947"
        }
      ],
      "message": "schnorrsig: Add taproot test case",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T19:00:08Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2019-11-14T13:34:51Z"
      },
      "sha": "16ffa9d97cef93f49544b016339c107882f9a1c3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZjQzMWIzZjI4YWM5NWEzNjQ1YWQ1YTZkYzk2Yjg3OGZhMzBhMWRlMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "tree": {
        "sha": "dce3b9f0ce5b963d08a6ff2fbbf880c3716d82ca",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/dce3b9f0ce5b963d08a6ff2fbbf880c3716d82ca"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/16ffa9d97cef93f49544b016339c107882f9a1c3",
          "sha": "16ffa9d97cef93f49544b016339c107882f9a1c3",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/16ffa9d97cef93f49544b016339c107882f9a1c3"
        }
      ],
      "message": "valgrind_ctime_test: Add schnorrsig_sign",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-09-06T19:00:08Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2020-03-12T20:05:07Z"
      },
      "sha": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3"
    },
    {
      "event": "commented",
      "id": 687871250,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4Nzg3MTI1MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/687871250",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-06T19:01:47Z",
      "updated_at": "2020-09-09T07:02:49Z",
      "author_association": "MEMBER",
      "body": "Squashed in latest fixups. Updated post-merge todo list:\r\n\r\n> - [ ] consider allowing variable len messages. I experimented with this in https://github.com/jonasnick/secp256k1/commits/schnorrsig-varmsg. There's not much to experiment though, it just adds a size_t msg_len argument and fixes the tests. (this branch totally ignores domain separation)\r\n> - [ ] the tweak apis are inconsistent (both legacy and xonly) as the seckey_tweak_add functions are constant time with respect to the tweak and pubkey_tweak_add are not. Similarly, the keypair_tweak_add is not CT w.r.t. the tweak. This PR is consistent with the legacy API and reuses much of it's code. Therefore, if we consider changing this (I think we should), the easiest way is to change both legacy and xonly and that's best done in a different PR.\r\n\r\n- [ ] consider simplifying default schnorrsig_sign function by removing `noncefp` and clarifying that noncedata refers to aux_rand from BIP 340\r\n- [ ] Add exhaustive tests for schnorrsig and extrakeys (sipa wrote a few, see [comment above](https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-687526383))\r\n- [ ] Remove unused functions such as `secp256k1_gej_has_quad_y_var` (see https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-477117034).\r\n- [ ] Mention of schnorrsig module in README.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-687871250",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "commented",
      "id": 687894584,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4Nzg5NDU4NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/687894584",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-06T20:34:39Z",
      "updated_at": "2020-09-06T20:34:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK f431b3f28ac95a3645ad5a6dc96b878fa30a1de3  (exactly matches the previous post-fixup version which I have already reviewed and tested)",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-687894584",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 483785318,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzg1MzE4",
      "url": null,
      "actor": null,
      "commit_id": "4e43520026f5bcd182d21f0759bac159ef47bb62",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-483785318",
      "submitted_at": "2020-09-08T04:25:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "commented",
      "id": 688802977,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4ODgwMjk3Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/688802977",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-08T11:20:04Z",
      "updated_at": "2020-09-08T11:20:04Z",
      "author_association": "MEMBER",
      "body": "Sorry for not being helpful in the past week, I'll try to review/hopefully ACK this week.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-688802977",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "review_requested",
      "id": 3740431663,
      "node_id": "MDIwOlJldmlld1JlcXVlc3RlZEV2ZW50Mzc0MDQzMTY2Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3740431663",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-08T11:20:18Z",
      "requested_reviewer": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 689242303,
      "node_id": "MDEyOklzc3VlQ29tbWVudDY4OTI0MjMwMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/689242303",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-09T01:30:57Z",
      "updated_at": "2020-09-09T01:30:57Z",
      "author_association": "MEMBER",
      "body": "I ran my [exhaustive tests]( https://github.com/sipa/secp256k1/commits/202009_schnorrsig_exhaustive) on top of this, with both orders 13 and 199 (disabling the slowest other tests, as they take several CPU years for 199). All pass.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-689242303",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/558"
    },
    {
      "event": "reviewed",
      "id": 486122392,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MTIyMzky",
      "url": null,
      "actor": null,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-486122392",
      "submitted_at": "2020-09-10T16:43:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "reviewed",
      "id": 487053947,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MDUzOTQ3",
      "url": null,
      "actor": null,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK f431b3f28ac95a3645ad5a6dc96b878fa30a1de3 careful code review\r\n\r\nI have a few minor comments in my notes but all of those can be addressed later.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-487053947",
      "submitted_at": "2020-09-11T19:06:14Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
    },
    {
      "event": "merged",
      "id": 3757713027,
      "node_id": "MDExOk1lcmdlZEV2ZW50Mzc1NzcxMzAyNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3757713027",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8ab24e8dad9d43fc6661842149899e3cc9213b24",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/8ab24e8dad9d43fc6661842149899e3cc9213b24",
      "created_at": "2020-09-11T19:26:27Z"
    },
    {
      "event": "closed",
      "id": 3757713034,
      "node_id": "MDExOkNsb3NlZEV2ZW50Mzc1NzcxMzAzNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3757713034",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-09-11T19:26:27Z"
    },
    {
      "event": "referenced",
      "id": 3761267075,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM3NjEyNjcwNzU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3761267075",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "ba4b3fbcf21317a9410f3be913e4437d58968091",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba4b3fbcf21317a9410f3be913e4437d58968091",
      "created_at": "2020-09-14T03:52:47Z"
    },
    {
      "event": "referenced",
      "id": 3766345025,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM3NjYzNDUwMjU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3766345025",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "711b81967ae708deadda8ba846e4641889e469d0",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/711b81967ae708deadda8ba846e4641889e469d0",
      "created_at": "2020-09-15T04:35:31Z"
    },
    {
      "event": "referenced",
      "id": 3818732774,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg3MzI3NzQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818732774",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5ab6cb06f7c981c1984dead7fc6848718c452ab7",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/5ab6cb06f7c981c1984dead7fc6848718c452ab7",
      "created_at": "2020-09-29T10:24:13Z"
    },
    {
      "event": "referenced",
      "id": 3818811147,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg4MTExNDc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818811147",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "3374da576f72e33d92d073ccafef3d2e3299e52a",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/3374da576f72e33d92d073ccafef3d2e3299e52a",
      "created_at": "2020-09-29T10:42:17Z"
    },
    {
      "event": "referenced",
      "id": 3818826583,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg4MjY1ODM=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818826583",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "ee1b32cb0dd4488d8de8371e2eeeb35f31172ffc",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/ee1b32cb0dd4488d8de8371e2eeeb35f31172ffc",
      "created_at": "2020-09-29T10:45:43Z"
    },
    {
      "event": "referenced",
      "id": 3818826589,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg4MjY1ODk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818826589",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6a9d5cc855166a47e57ce5ab945898b1afd449c3",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/6a9d5cc855166a47e57ce5ab945898b1afd449c3",
      "created_at": "2020-09-29T10:45:43Z"
    },
    {
      "event": "referenced",
      "id": 3818838375,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg4MzgzNzU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818838375",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a7fc6797d4fab2c406aa0db127a0a2ab5b8c112f",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/a7fc6797d4fab2c406aa0db127a0a2ab5b8c112f",
      "created_at": "2020-09-29T10:48:21Z"
    },
    {
      "event": "referenced",
      "id": 3818862970,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg4NjI5NzA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818862970",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "ee00af3c8faff63e6e268cab20e83e0444311172",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/ee00af3c8faff63e6e268cab20e83e0444311172",
      "created_at": "2020-09-29T10:53:47Z"
    },
    {
      "event": "referenced",
      "id": 3818913612,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg5MTM2MTI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818913612",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "542c2efe4440f3317007934517309ea09a10c333",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/542c2efe4440f3317007934517309ea09a10c333",
      "created_at": "2020-09-29T11:05:08Z"
    },
    {
      "event": "referenced",
      "id": 3818913628,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg5MTM2Mjg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818913628",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a0bccf54f90f99e379fd1d81455af1a250872f33",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/a0bccf54f90f99e379fd1d81455af1a250872f33",
      "created_at": "2020-09-29T11:05:08Z"
    },
    {
      "event": "referenced",
      "id": 3818913634,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTg5MTM2MzQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3818913634",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "35ede4bdb6d4d61ba98a8ee523457e323c159efe",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/35ede4bdb6d4d61ba98a8ee523457e323c159efe",
      "created_at": "2020-09-29T11:05:08Z"
    },
    {
      "event": "referenced",
      "id": 3819180748,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTkxODA3NDg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3819180748",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "7cf7dc459e8fb7c32128786ea709fee238ddfd29",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/7cf7dc459e8fb7c32128786ea709fee238ddfd29",
      "created_at": "2020-09-29T12:05:09Z"
    },
    {
      "event": "referenced",
      "id": 3819180761,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTkxODA3NjE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3819180761",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6304e4528edf9fe7376cecfcca004a9be0d78d7d",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/6304e4528edf9fe7376cecfcca004a9be0d78d7d",
      "created_at": "2020-09-29T12:05:09Z"
    },
    {
      "event": "referenced",
      "id": 3819220302,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTkyMjAzMDI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3819220302",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "51407fcd5e95ac9f562962824678a5d616b3cecd",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/51407fcd5e95ac9f562962824678a5d616b3cecd",
      "created_at": "2020-09-29T12:13:37Z"
    },
    {
      "event": "referenced",
      "id": 3819220310,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTkyMjAzMTA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3819220310",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "11f99c1b9a0f3470fdfed145f235c96eabf90d93",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/11f99c1b9a0f3470fdfed145f235c96eabf90d93",
      "created_at": "2020-09-29T12:13:37Z"
    },
    {
      "event": "referenced",
      "id": 3819220315,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTkyMjAzMTU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3819220315",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "852d5e198982cae494863b90edc089ad4f53ed00",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/852d5e198982cae494863b90edc089ad4f53ed00",
      "created_at": "2020-09-29T12:13:37Z"
    },
    {
      "event": "referenced",
      "id": 3819220318,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MTkyMjAzMTg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3819220318",
      "actor": {
        "login": "jasonbcox",
        "id": 602513,
        "node_id": "MDQ6VXNlcjYwMjUxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/602513?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jasonbcox",
        "html_url": "https://github.com/jasonbcox",
        "followers_url": "https://api.github.com/users/jasonbcox/followers",
        "following_url": "https://api.github.com/users/jasonbcox/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jasonbcox/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jasonbcox/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jasonbcox/subscriptions",
        "organizations_url": "https://api.github.com/users/jasonbcox/orgs",
        "repos_url": "https://api.github.com/users/jasonbcox/repos",
        "events_url": "https://api.github.com/users/jasonbcox/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jasonbcox/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "10cf62f3c866fd7b43302ecd17e5c29884714a63",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/10cf62f3c866fd7b43302ecd17e5c29884714a63",
      "created_at": "2020-09-29T12:13:37Z"
    },
    {
      "event": "referenced",
      "id": 3822601945,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NDU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601945",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e3550eb534a01fbd63651820eaa4976e0cbdc7e7",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/e3550eb534a01fbd63651820eaa4976e0cbdc7e7",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601947,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NDc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601947",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "358281475be2262e5c65e4139a53fae471e15790",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/358281475be2262e5c65e4139a53fae471e15790",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601949,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NDk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601949",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e5ffbae0822f00caee7a5a9295daaeff0422d83f",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/e5ffbae0822f00caee7a5a9295daaeff0422d83f",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601950,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NTA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601950",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "cd45ae75e14133babd5c92f60ddd0efb0cc51dc8",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/cd45ae75e14133babd5c92f60ddd0efb0cc51dc8",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601951,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NTE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601951",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "58fd134ed000a1b8474859bdeae9f4c0dfd91953",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/58fd134ed000a1b8474859bdeae9f4c0dfd91953",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601953,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NTM=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601953",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1790105162fa391bb8600169b69c6a353610e7d6",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/1790105162fa391bb8600169b69c6a353610e7d6",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601954,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NTQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601954",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "c341d26b480a661125b1e726602511f00cd87122",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/c341d26b480a661125b1e726602511f00cd87122",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601955,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NTU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601955",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "d796ee6d86eaefbd0b6a7fe0b18af25492810805",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/d796ee6d86eaefbd0b6a7fe0b18af25492810805",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601956,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NTY=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601956",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "f995ae3e0e9ff9a92febb0e2f59ffcc1b96257ec",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/f995ae3e0e9ff9a92febb0e2f59ffcc1b96257ec",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601958,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NTg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601958",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b7697cd1f5dd58c60b88b3c3cc06fa2dfb26a383",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/b7697cd1f5dd58c60b88b3c3cc06fa2dfb26a383",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601959,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NTk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601959",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "50daa9ea41e9f1b0e85122308e1190b881b9a2b3",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/50daa9ea41e9f1b0e85122308e1190b881b9a2b3",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601960,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NjA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601960",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b448c7c5301c4ed1f4ee4c48433664b7ef13c798",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/b448c7c5301c4ed1f4ee4c48433664b7ef13c798",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601962,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NjI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601962",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "9da8345313193d6f19265788fe4b29eb124a9b1f",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/9da8345313193d6f19265788fe4b29eb124a9b1f",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601964,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5NjQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601964",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "29f529baed2ca2b8da6273b4db72b1517b6812e4",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/29f529baed2ca2b8da6273b4db72b1517b6812e4",
      "created_at": "2020-09-30T04:33:50Z"
    },
    {
      "event": "referenced",
      "id": 3822601967,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM4MjI2MDE5Njc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3822601967",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6e6e961d891fa5438c4ab87f4b37816fa61debc7",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/6e6e961d891fa5438c4ab87f4b37816fa61debc7",
      "created_at": "2020-09-30T04:33:51Z"
    },
    {
      "event": "referenced",
      "id": 5138105079,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDUxMzgxMDUwNzk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5138105079",
      "actor": {
        "login": "UdjinM6",
        "id": 1935069,
        "node_id": "MDQ6VXNlcjE5MzUwNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1935069?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/UdjinM6",
        "html_url": "https://github.com/UdjinM6",
        "followers_url": "https://api.github.com/users/UdjinM6/followers",
        "following_url": "https://api.github.com/users/UdjinM6/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/UdjinM6/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/UdjinM6/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/UdjinM6/subscriptions",
        "organizations_url": "https://api.github.com/users/UdjinM6/orgs",
        "repos_url": "https://api.github.com/users/UdjinM6/repos",
        "events_url": "https://api.github.com/users/UdjinM6/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/UdjinM6/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "c2ab8285d8cc702811be3708e0c3249f65cbd647",
      "commit_url": "https://api.github.com/repos/UdjinM6/dash/commits/c2ab8285d8cc702811be3708e0c3249f65cbd647",
      "created_at": "2021-08-10T22:22:01Z"
    },
    {
      "event": "referenced",
      "id": 5149897852,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDUxNDk4OTc4NTI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5149897852",
      "actor": {
        "login": "5tefan",
        "id": 5855806,
        "node_id": "MDQ6VXNlcjU4NTU4MDY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5855806?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/5tefan",
        "html_url": "https://github.com/5tefan",
        "followers_url": "https://api.github.com/users/5tefan/followers",
        "following_url": "https://api.github.com/users/5tefan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/5tefan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/5tefan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/5tefan/subscriptions",
        "organizations_url": "https://api.github.com/users/5tefan/orgs",
        "repos_url": "https://api.github.com/users/5tefan/repos",
        "events_url": "https://api.github.com/users/5tefan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/5tefan/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "abf9ac837f22bfc53383174e807bb5c81f39e69f",
      "commit_url": "https://api.github.com/repos/5tefan/dash/commits/abf9ac837f22bfc53383174e807bb5c81f39e69f",
      "created_at": "2021-08-12T14:39:48Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/220258957",
      "pull_request_review_id": 158625323,
      "id": 220258957,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDI1ODk1Nw==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, size_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ff3a22d1478b1ba364988d4cef52384e830d0f8f",
      "in_reply_to_id": null,
      "user": {
        "login": "DesWurstes",
        "id": 23437045,
        "node_id": "MDQ6VXNlcjIzNDM3MDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23437045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DesWurstes",
        "html_url": "https://github.com/DesWurstes",
        "followers_url": "https://api.github.com/users/DesWurstes/followers",
        "following_url": "https://api.github.com/users/DesWurstes/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DesWurstes/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DesWurstes/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DesWurstes/subscriptions",
        "organizations_url": "https://api.github.com/users/DesWurstes/orgs",
        "repos_url": "https://api.github.com/users/DesWurstes/repos",
        "events_url": "https://api.github.com/users/DesWurstes/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DesWurstes/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Travis with 32-bit `size_t` is failing because:\r\n\r\n```\r\n./src/scalar_8x32_impl.h:760:19: warning: shift count >= width of type [-Wshift-count-overflow]\r\n        x13 = idx >> 32;\r\n                  ^  ~~\r\n./src/scalar_8x32_impl.h:789:20: warning: shift count >= width of type [-Wshift-count-overflow]\r\n        x13 += idx >> 32;\r\n```\r\nI'd replace the `size_t` above with `uint32_t` or `uint64_t`.",
      "created_at": "2018-09-25T16:13:23Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r220258957",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/220258957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 801,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/220263008",
      "pull_request_review_id": 158630304,
      "id": 220263008,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDI2MzAwOA==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, size_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ff3a22d1478b1ba364988d4cef52384e830d0f8f",
      "in_reply_to_id": 220258957,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch. See also the version of this commit in secp-zkp (where Tim suggests making *all* the `size_t`s be `uint64_t`s.)\r\n\r\nhttps://github.com/ElementsProject/secp256k1-zkp/pull/23/commits/c3794f902b3265a52e904088f652cf2f1a82107c",
      "created_at": "2018-09-25T16:24:53Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r220263008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/220263008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 801,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/220604143",
      "pull_request_review_id": 159048933,
      "id": 220604143,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDYwNDE0Mw==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    const void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 75,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we should drop the `const` on `ndata`. @sipa thoughts?",
      "created_at": "2018-09-26T15:07:49Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r220604143",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/220604143"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/220622608",
      "pull_request_review_id": 159072126,
      "id": 220622608,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDYyMjYwOA==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if(secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if(!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if(idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* -R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_negate(sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* -eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_negate(sc, sc);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Hashes signature verification data into the randomization seed and initializes ecmult_context. */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Sums the s part of all signatures multiplied by their randomizer */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_scalar *s, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &ecmult_context->randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != (s1 + a2*s2 + ... + au*su)G - R1 - a2*R2 - ... - au*Ru - e1*P1 - (a2*e2)P2 - ... - (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+\n+    secp256k1_sha256_initialize(&sha);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 297,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can we pull the `sha` object into `secp256k1_schnorrsig_verify_batch_init_randomizer`?",
      "created_at": "2018-09-26T15:53:18Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r220622608",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/220622608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 341,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221443220",
      "pull_request_review_id": 160096977,
      "id": 221443220,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ0MzIyMA==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    const void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 75,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 220604143,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It shouldn't be const, as the sign to contract sort of usage needs to write back the certificate.",
      "created_at": "2018-09-30T00:18:24Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221443220",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221443220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221467463",
      "pull_request_review_id": 160122617,
      "id": 221467463,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2NzQ2Mw==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    secp256k1_schnorrsig sig;\n+\n+    for (i = 0; i < 1000; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        sk[0] = i;\n+        sk[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, &sig, msg, sk, NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+\n+    for (i = 0; i < 1000; i++) {\n+        secp256k1_pubkey pk;\n+        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pk, data->pk[i], 33) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+void bench_schnorrsig_verify_n(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i, j;\n+    const secp256k1_pubkey **pk = (const secp256k1_pubkey **)malloc(data->n * sizeof(*pk));\n+\n+    CHECK(pk != NULL);\n+    for (j = 0; j < MAX_SIGS/data->n; j++) {\n+        for (i = 0; i < data->n; i++) {\n+            secp256k1_pubkey *pk_nonconst = (secp256k1_pubkey *)malloc(sizeof(*pk_nonconst));\n+            CHECK(secp256k1_ec_pubkey_parse(data->ctx, pk_nonconst, data->pk[i], 33) == 1);\n+            pk[i] = pk_nonconst;\n+        }\n+        CHECK(secp256k1_schnorrsig_verify_batch(data->ctx, data->scratch, data->sigs, data->msgs, pk, data->n));\n+        for (i = 0; i < data->n; i++) {\n+            free((void *)pk[i]);\n+        }\n+    }\n+    free(pk);\n+}\n+\n+int main(void) {\n+    size_t i;\n+    bench_schnorrsig_data data;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);\n+    data.pk = (const unsigned char **)malloc(MAX_SIGS * 33);\n+    data.msgs = (const unsigned char **)malloc(MAX_SIGS * 32);\n+    data.sigs = (const secp256k1_schnorrsig **)malloc(MAX_SIGS * sizeof(*data.sigs));\n+\n+    for (i = 0; i < MAX_SIGS; i++) {\n+        unsigned char sk[32];\n+        unsigned char *msg = malloc(32);",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 85,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: cast to (unsigned char *)",
      "created_at": "2018-09-30T17:51:13Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221467463",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221467463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221467773",
      "pull_request_review_id": 160122617,
      "id": 221467773,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2Nzc3Mw==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    secp256k1_schnorrsig sig;\n+\n+    for (i = 0; i < 1000; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        sk[0] = i;\n+        sk[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, &sig, msg, sk, NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+\n+    for (i = 0; i < 1000; i++) {\n+        secp256k1_pubkey pk;\n+        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pk, data->pk[i], 33) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+void bench_schnorrsig_verify_n(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i, j;\n+    const secp256k1_pubkey **pk = (const secp256k1_pubkey **)malloc(data->n * sizeof(*pk));\n+\n+    CHECK(pk != NULL);\n+    for (j = 0; j < MAX_SIGS/data->n; j++) {\n+        for (i = 0; i < data->n; i++) {\n+            secp256k1_pubkey *pk_nonconst = (secp256k1_pubkey *)malloc(sizeof(*pk_nonconst));\n+            CHECK(secp256k1_ec_pubkey_parse(data->ctx, pk_nonconst, data->pk[i], 33) == 1);\n+            pk[i] = pk_nonconst;\n+        }\n+        CHECK(secp256k1_schnorrsig_verify_batch(data->ctx, data->scratch, data->sigs, data->msgs, pk, data->n));\n+        for (i = 0; i < data->n; i++) {\n+            free((void *)pk[i]);\n+        }\n+    }\n+    free(pk);\n+}\n+\n+int main(void) {\n+    size_t i;\n+    bench_schnorrsig_data data;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);\n+    data.pk = (const unsigned char **)malloc(MAX_SIGS * 33);",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 79,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Shouldn't this be `MAX_SIGS * sizeof(unsigned char*)`? (Same below)",
      "created_at": "2018-09-30T18:01:18Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221467773",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221467773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221467803",
      "pull_request_review_id": 160122617,
      "id": 221467803,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2NzgwMw==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    secp256k1_schnorrsig sig;\n+\n+    for (i = 0; i < 1000; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        sk[0] = i;\n+        sk[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, &sig, msg, sk, NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+\n+    for (i = 0; i < 1000; i++) {\n+        secp256k1_pubkey pk;\n+        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pk, data->pk[i], 33) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+void bench_schnorrsig_verify_n(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i, j;\n+    const secp256k1_pubkey **pk = (const secp256k1_pubkey **)malloc(data->n * sizeof(*pk));\n+\n+    CHECK(pk != NULL);\n+    for (j = 0; j < MAX_SIGS/data->n; j++) {\n+        for (i = 0; i < data->n; i++) {\n+            secp256k1_pubkey *pk_nonconst = (secp256k1_pubkey *)malloc(sizeof(*pk_nonconst));\n+            CHECK(secp256k1_ec_pubkey_parse(data->ctx, pk_nonconst, data->pk[i], 33) == 1);\n+            pk[i] = pk_nonconst;\n+        }\n+        CHECK(secp256k1_schnorrsig_verify_batch(data->ctx, data->scratch, data->sigs, data->msgs, pk, data->n));\n+        for (i = 0; i < data->n; i++) {\n+            free((void *)pk[i]);\n+        }\n+    }\n+    free(pk);\n+}\n+\n+int main(void) {\n+    size_t i;\n+    bench_schnorrsig_data data;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);\n+    data.pk = (const unsigned char **)malloc(MAX_SIGS * 33);\n+    data.msgs = (const unsigned char **)malloc(MAX_SIGS * 32);\n+    data.sigs = (const secp256k1_schnorrsig **)malloc(MAX_SIGS * sizeof(*data.sigs));\n+\n+    for (i = 0; i < MAX_SIGS; i++) {\n+        unsigned char sk[32];\n+        unsigned char *msg = malloc(32);\n+        secp256k1_schnorrsig *sig = (secp256k1_schnorrsig *)malloc(sizeof(*sig));",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 86,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe faster to do one big malloc for all msgs, pubkeys, and sigs outside the loop, then index into it.",
      "created_at": "2018-09-30T18:02:42Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221467803",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221467803"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221467923",
      "pull_request_review_id": 160122617,
      "id": 221467923,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2NzkyMw==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 29,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why does this use a this secret key and message instead of `data->sk[i]` (which could easily be added to the data struct) and `data->msgs[i]`?",
      "created_at": "2018-09-30T18:07:09Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221467923",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221467923"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221468306",
      "pull_request_review_id": 160122617,
      "id": 221468306,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2ODMwNg==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why not make this a `secp256k1_scalar *`, like in the `ecdsa_sig_sign` interface?",
      "created_at": "2018-09-30T18:18:48Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221468306",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221468306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221468667",
      "pull_request_review_id": 160122617,
      "id": 221468667,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2ODY2Nw==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "style nit: spacing after `if` is inconsistent in this file.",
      "created_at": "2018-09-30T18:30:15Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221468667",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221468667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221470493",
      "pull_request_review_id": 160122617,
      "id": 221470493,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ3MDQ5Mw==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if(secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if(!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if(idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* -R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_negate(sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* -eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_negate(sc, sc);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Hashes signature verification data into the randomization seed and initializes ecmult_context. */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Sums the s part of all signatures multiplied by their randomizer */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_scalar *s, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &ecmult_context->randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != (s1 + a2*s2 + ... + au*su)G - R1 - a2*R2 - ... - au*Ru - e1*P1 - (a2*e2)P2 - ... - (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    if(!secp256k1_schnorrsig_verify_batch_init_randomizer(ctx, &ecmult_context, &sha, sig, msg32, pk, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_sha256_finalize(&sha, ecmult_context.chacha_seed);\n+\n+    secp256k1_scalar_clear(&s);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 303,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This line feels like it belongs in `schnorrsig_verify_batch_sum_s`",
      "created_at": "2018-09-30T19:34:57Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221470493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221470493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221470697",
      "pull_request_review_id": 160122617,
      "id": 221470697,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ3MDY5Nw==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if(secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if(!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if(idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* -R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_negate(sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 203,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": null,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Time difference is probably negligible, but it seems easier to negate the single `sum_s` term in `verify_batch` rather than each one here.",
      "created_at": "2018-09-30T19:40:29Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221470697",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221470697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221678806",
      "pull_request_review_id": 160386368,
      "id": 221678806,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTY3ODgwNg==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221468306,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is a public-facing function, and `secp256k1_scalar` is not a public type.",
      "created_at": "2018-10-01T16:46:15Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221678806",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221678806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221679093",
      "pull_request_review_id": 160386693,
      "id": 221679093,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTY3OTA5Mw==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 29,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221467923,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Because this works and `malloc` is a PITA to use :P",
      "created_at": "2018-10-01T16:46:53Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221679093",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221679093"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221776878",
      "pull_request_review_id": 160509981,
      "id": 221776878,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTc3Njg3OA==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 29,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221467923,
      "user": {
        "login": "jimpo",
        "id": 881253,
        "node_id": "MDQ6VXNlcjg4MTI1Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jimpo",
        "html_url": "https://github.com/jimpo",
        "followers_url": "https://api.github.com/users/jimpo/followers",
        "following_url": "https://api.github.com/users/jimpo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jimpo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jimpo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
        "organizations_url": "https://api.github.com/users/jimpo/orgs",
        "repos_url": "https://api.github.com/users/jimpo/repos",
        "events_url": "https://api.github.com/users/jimpo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jimpo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sure, it's just a bit odd that `bench_schnorrsig_verify` and `bench_schnorrsig_verify_n` use the malloc'ed data while this doesn't. Feel free to ignore though.",
      "created_at": "2018-10-01T22:29:06Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221776878",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221776878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221865308",
      "pull_request_review_id": 160615104,
      "id": 221865308,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTg2NTMwOA==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    secp256k1_schnorrsig sig;\n+\n+    for (i = 0; i < 1000; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        sk[0] = i;\n+        sk[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, &sig, msg, sk, NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+\n+    for (i = 0; i < 1000; i++) {\n+        secp256k1_pubkey pk;\n+        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pk, data->pk[i], 33) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+void bench_schnorrsig_verify_n(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i, j;\n+    const secp256k1_pubkey **pk = (const secp256k1_pubkey **)malloc(data->n * sizeof(*pk));\n+\n+    CHECK(pk != NULL);\n+    for (j = 0; j < MAX_SIGS/data->n; j++) {\n+        for (i = 0; i < data->n; i++) {\n+            secp256k1_pubkey *pk_nonconst = (secp256k1_pubkey *)malloc(sizeof(*pk_nonconst));\n+            CHECK(secp256k1_ec_pubkey_parse(data->ctx, pk_nonconst, data->pk[i], 33) == 1);\n+            pk[i] = pk_nonconst;\n+        }\n+        CHECK(secp256k1_schnorrsig_verify_batch(data->ctx, data->scratch, data->sigs, data->msgs, pk, data->n));\n+        for (i = 0; i < data->n; i++) {\n+            free((void *)pk[i]);\n+        }\n+    }\n+    free(pk);\n+}\n+\n+int main(void) {\n+    size_t i;\n+    bench_schnorrsig_data data;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);\n+    data.pk = (const unsigned char **)malloc(MAX_SIGS * 33);\n+    data.msgs = (const unsigned char **)malloc(MAX_SIGS * 32);\n+    data.sigs = (const secp256k1_schnorrsig **)malloc(MAX_SIGS * sizeof(*data.sigs));\n+\n+    for (i = 0; i < MAX_SIGS; i++) {\n+        unsigned char sk[32];\n+        unsigned char *msg = malloc(32);",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 85,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221467463,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2018-10-02T08:36:12Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221865308",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221865308"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221865335",
      "pull_request_review_id": 160615136,
      "id": 221865335,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTg2NTMzNQ==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    secp256k1_schnorrsig sig;\n+\n+    for (i = 0; i < 1000; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        sk[0] = i;\n+        sk[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, &sig, msg, sk, NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+\n+    for (i = 0; i < 1000; i++) {\n+        secp256k1_pubkey pk;\n+        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pk, data->pk[i], 33) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+void bench_schnorrsig_verify_n(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i, j;\n+    const secp256k1_pubkey **pk = (const secp256k1_pubkey **)malloc(data->n * sizeof(*pk));\n+\n+    CHECK(pk != NULL);\n+    for (j = 0; j < MAX_SIGS/data->n; j++) {\n+        for (i = 0; i < data->n; i++) {\n+            secp256k1_pubkey *pk_nonconst = (secp256k1_pubkey *)malloc(sizeof(*pk_nonconst));\n+            CHECK(secp256k1_ec_pubkey_parse(data->ctx, pk_nonconst, data->pk[i], 33) == 1);\n+            pk[i] = pk_nonconst;\n+        }\n+        CHECK(secp256k1_schnorrsig_verify_batch(data->ctx, data->scratch, data->sigs, data->msgs, pk, data->n));\n+        for (i = 0; i < data->n; i++) {\n+            free((void *)pk[i]);\n+        }\n+    }\n+    free(pk);\n+}\n+\n+int main(void) {\n+    size_t i;\n+    bench_schnorrsig_data data;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);\n+    data.pk = (const unsigned char **)malloc(MAX_SIGS * 33);",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 79,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221467773,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2018-10-02T08:36:17Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221865335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221865335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221866960",
      "pull_request_review_id": 160617060,
      "id": 221866960,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTg2Njk2MA==",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+#define MAX_SIGS\t(32768)\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    size_t n;\n+    const unsigned char **pk;\n+    const secp256k1_schnorrsig **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+    unsigned char sk[32] = \"benchmarkexample secrettemplate\";\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    secp256k1_schnorrsig sig;\n+\n+    for (i = 0; i < 1000; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        sk[0] = i;\n+        sk[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, &sig, msg, sk, NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i;\n+\n+    for (i = 0; i < 1000; i++) {\n+        secp256k1_pubkey pk;\n+        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pk, data->pk[i], 33) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+void bench_schnorrsig_verify_n(void* arg) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    size_t i, j;\n+    const secp256k1_pubkey **pk = (const secp256k1_pubkey **)malloc(data->n * sizeof(*pk));\n+\n+    CHECK(pk != NULL);\n+    for (j = 0; j < MAX_SIGS/data->n; j++) {\n+        for (i = 0; i < data->n; i++) {\n+            secp256k1_pubkey *pk_nonconst = (secp256k1_pubkey *)malloc(sizeof(*pk_nonconst));\n+            CHECK(secp256k1_ec_pubkey_parse(data->ctx, pk_nonconst, data->pk[i], 33) == 1);\n+            pk[i] = pk_nonconst;\n+        }\n+        CHECK(secp256k1_schnorrsig_verify_batch(data->ctx, data->scratch, data->sigs, data->msgs, pk, data->n));\n+        for (i = 0; i < data->n; i++) {\n+            free((void *)pk[i]);\n+        }\n+    }\n+    free(pk);\n+}\n+\n+int main(void) {\n+    size_t i;\n+    bench_schnorrsig_data data;\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);\n+    data.pk = (const unsigned char **)malloc(MAX_SIGS * 33);\n+    data.msgs = (const unsigned char **)malloc(MAX_SIGS * 32);\n+    data.sigs = (const secp256k1_schnorrsig **)malloc(MAX_SIGS * sizeof(*data.sigs));\n+\n+    for (i = 0; i < MAX_SIGS; i++) {\n+        unsigned char sk[32];\n+        unsigned char *msg = malloc(32);\n+        secp256k1_schnorrsig *sig = (secp256k1_schnorrsig *)malloc(sizeof(*sig));",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 86,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221467803,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think that's measurably faster, setup code like this that is not in a `bench_*` function is not measured by the tool and it would increase code complexity.",
      "created_at": "2018-10-02T08:41:10Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221866960",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221866960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221867075",
      "pull_request_review_id": 160617216,
      "id": 221867075,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTg2NzA3NQ==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221468667,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed in multiple places. I hope I caught them all.",
      "created_at": "2018-10-02T08:41:33Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221867075",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221867075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221867244",
      "pull_request_review_id": 160617429,
      "id": 221867244,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTg2NzI0NA==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if(secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if(!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if(idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* -R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_negate(sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 203,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221470697,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "agreed",
      "created_at": "2018-10-02T08:42:02Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221867244",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221867244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221868367",
      "pull_request_review_id": 160618786,
      "id": 221868367,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTg2ODM2Nw==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if(secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if(!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if(idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* -R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_negate(sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* -eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_negate(sc, sc);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Hashes signature verification data into the randomization seed and initializes ecmult_context. */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Sums the s part of all signatures multiplied by their randomizer */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_scalar *s, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &ecmult_context->randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != (s1 + a2*s2 + ... + au*su)G - R1 - a2*R2 - ... - au*Ru - e1*P1 - (a2*e2)P2 - ... - (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    if(!secp256k1_schnorrsig_verify_batch_init_randomizer(ctx, &ecmult_context, &sha, sig, msg32, pk, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_sha256_finalize(&sha, ecmult_context.chacha_seed);\n+\n+    secp256k1_scalar_clear(&s);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 303,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 221470493,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd prefer to have it outside of `batch_sum_s` to allow combining similar helper functions in a more general batch verification function like\r\n```\r\n    secp256k1_scalar_clear(&s);\r\n    secp256k1_schnorrsig_verify_batch_sum_s(&s, ecmult_context.chacha_seed, sig, n_sigs)\r\n    secp256k1_taproot_verify_init(&s, ...);\r\n```\r\nI added better documentation to this helper function instead.",
      "created_at": "2018-10-02T08:45:31Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221868367",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221868367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221868542",
      "pull_request_review_id": 160619024,
      "id": 221868542,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTg2ODU0Mg==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if(secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if(!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if(idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* -R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_negate(sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* -eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_negate(sc, sc);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Hashes signature verification data into the randomization seed and initializes ecmult_context. */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Sums the s part of all signatures multiplied by their randomizer */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_scalar *s, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &ecmult_context->randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != (s1 + a2*s2 + ... + au*su)G - R1 - a2*R2 - ... - au*Ru - e1*P1 - (a2*e2)P2 - ... - (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+\n+    secp256k1_sha256_initialize(&sha);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 297,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 220622608,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "An argument against that is that it makes combining multiple `init_randomizers` less succinct. With a shared sha object it'd look like\r\n```\r\n    secp256k1_sha256_initialize(&sha);\r\n    secp256k1_schnorr_verify_init_randomizer(ctx, &ecmult_data.schnorr, &sha, sig, msg32, pk, n_sigs);\r\n    secp256k1_taproot_verify_init_randomizer(ctx, &sha, ...);\r\n    secp256k1_sha256_finalize(&sha, ecmult_data.schnorr.chacha_seed);\r\n```",
      "created_at": "2018-10-02T08:46:06Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221868542",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221868542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 341,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221951127",
      "pull_request_review_id": 160721103,
      "id": 221951127,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTk1MTEyNw==",
      "diff_hunk": "@@ -0,0 +1,312 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if(!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if(secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if(!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if(idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* -R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_negate(sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* -eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_negate(sc, sc);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Hashes signature verification data into the randomization seed and initializes ecmult_context. */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/* Helper function for batch verification.\n+ * Sums the s part of all signatures multiplied by their randomizer */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_scalar *s, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &ecmult_context->randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != (s1 + a2*s2 + ... + au*su)G - R1 - a2*R2 - ... - au*Ru - e1*P1 - (a2*e2)P2 - ... - (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+\n+    secp256k1_sha256_initialize(&sha);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 297,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 220622608,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Gotcha, thanks! I wasn't sure if this was done with an eye toward taproot.",
      "created_at": "2018-10-02T13:32:39Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r221951127",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/221951127"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 341,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224732385",
      "pull_request_review_id": 164173997,
      "id": 224732385,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDczMjM4NQ==",
      "diff_hunk": "@@ -0,0 +1,334 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if (idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_clear(sc);\n+        secp256k1_scalar_add(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Hashes signature verification data into the\n+ *  randomization seed and initializes ecmult_context.\n+ *\n+ *  Returns 1 if the randomizer was successfully initialized.\n+ *\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out: ecmult_context: context for batch_ecmult_callback\n+ *  In/Out   sha: an initialized sha256 object which hashes the schnorrsig input in order to get a\n+ *                seed for the randomizer PRNG\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Sums the s part of all signatures multiplied by their\n+ *  randomizer.\n+ *\n+ *  Returns 1 if s is successfully summed.\n+ *\n+ *  In/Out: s: the s part of the input sigs is added to this s argument\n+ *  In:  chacha_seed: PRNG seed for computing randomizers\n+ *        sig: array of signatures, or NULL if there are no signatures\n+ *     n_sigs: number of signatures in above array (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_scalar *s, unsigned char *chacha_seed, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    secp256k1_scalar randomizer_cache[2];\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(randomizer_cache, chacha_seed, i / 2);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 291,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Currently, we discard one random value in `secp256k1_schnorrsig_batch_randomizer()`. We could instead\r\n * initialize `randomizer_cache[0]` with 1\r\n * change the condition to `i % 2 == 1`\r\n * (remove the third argument of `secp256k1_schnorrsig_batch_randomizer()`)\r\n * (maybe swap the `&r[0]` and `&r[1]` in secp256k1_schnorrsig_batch_randomizer()` to make sure we don't use the scalars in a weird order -- but who cares?)\r\n\r\nAnd similarly for the other side of the verification equation / ecmult. I think that'll be `i % 4 == 2`",
      "created_at": "2018-10-12T09:52:40Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r224732385",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224732385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 291,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224744413",
      "pull_request_review_id": 164173997,
      "id": 224744413,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDc0NDQxMw==",
      "diff_hunk": "@@ -1,6 +1,7 @@\n bench_inv\n bench_ecdh\n bench_ecmult\n+bench_schnorrsig\n bench_sign\n bench_verify\n bench_schnorr_verify",
      "path": ".gitignore",
      "position": null,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You could remove this line; it was overlooked in #425",
      "created_at": "2018-10-12T10:43:40Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r224744413",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224744413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 7,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224745006",
      "pull_request_review_id": 164173997,
      "id": 224745006,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDc0NTAwNg==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 22,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `.` at end of line",
      "created_at": "2018-10-12T10:46:29Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r224745006",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224745006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224746160",
      "pull_request_review_id": 164173997,
      "id": 224746160,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDc0NjE2MA==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    const void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:      sig: the signature being verified (cannot be NULL)\n+ *         msg32: the 32-byte message hash being verified (cannot be NULL)\n+ *        pubkey: pointer to a public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies a set of Schnorr signatures",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 94,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "same here",
      "created_at": "2018-10-12T10:52:24Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r224746160",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224746160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224748197",
      "pull_request_review_id": 164173997,
      "id": 224748197,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDc0ODE5Nw==",
      "diff_hunk": "@@ -0,0 +1,334 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if (idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_clear(sc);\n+        secp256k1_scalar_add(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Hashes signature verification data into the\n+ *  randomization seed and initializes ecmult_context.\n+ *\n+ *  Returns 1 if the randomizer was successfully initialized.\n+ *\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out: ecmult_context: context for batch_ecmult_callback\n+ *  In/Out   sha: an initialized sha256 object which hashes the schnorrsig input in order to get a\n+ *                seed for the randomizer PRNG\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Sums the s part of all signatures multiplied by their\n+ *  randomizer.\n+ *\n+ *  Returns 1 if s is successfully summed.",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 276,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe add \"which is the case if all of the scalars in the signatures are in range\". (On the other hand, this is well enough for a helper function, so feel free to ignore.)",
      "created_at": "2018-10-12T11:02:12Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r224748197",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224748197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224758604",
      "pull_request_review_id": 164173997,
      "id": 224758604,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDc1ODYwNA==",
      "diff_hunk": "@@ -0,0 +1,334 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if (idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_clear(sc);\n+        secp256k1_scalar_add(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Hashes signature verification data into the\n+ *  randomization seed and initializes ecmult_context.\n+ *\n+ *  Returns 1 if the randomizer was successfully initialized.\n+ *\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out: ecmult_context: context for batch_ecmult_callback\n+ *  In/Out   sha: an initialized sha256 object which hashes the schnorrsig input in order to get a\n+ *                seed for the randomizer PRNG\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Sums the s part of all signatures multiplied by their\n+ *  randomizer.\n+ *\n+ *  Returns 1 if s is successfully summed.\n+ *\n+ *  In/Out: s: the s part of the input sigs is added to this s argument\n+ *  In:  chacha_seed: PRNG seed for computing randomizers\n+ *        sig: array of signatures, or NULL if there are no signatures\n+ *     n_sigs: number of signatures in above array (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_scalar *s, unsigned char *chacha_seed, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    secp256k1_scalar randomizer_cache[2];\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(randomizer_cache, chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != -(s1 + a2*s2 + ... + au*su)G + R1 + a2*R2 + ... + au*Ru + e1*P1 + (a2*e2)P2 + ... + (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    if (!secp256k1_schnorrsig_verify_batch_init_randomizer(ctx, &ecmult_context, &sha, sig, msg32, pk, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_sha256_finalize(&sha, ecmult_context.chacha_seed);\n+\n+    secp256k1_scalar_clear(&s);\n+    if (!secp256k1_schnorrsig_verify_batch_sum_s(&s, ecmult_context.chacha_seed, sig, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_negate(&s, &s);\n+\n+    return secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &rj, &s, secp256k1_schnorrsig_verify_batch_ecmult_callback, (void *) &ecmult_context, 2 * n_sigs)",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 330,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Possible integer overflow in `2 * n_sigs`.\r\n\r\nOkay, I need to give you at least 2^31 signatures (each one with s = 0) to exploit that, but then all my signatures suddenly verify. :P ",
      "created_at": "2018-10-12T11:50:56Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r224758604",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/224758604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225055208",
      "pull_request_review_id": 164569825,
      "id": 225055208,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTA1NTIwOA==",
      "diff_hunk": "@@ -0,0 +1,334 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if (idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_clear(sc);\n+        secp256k1_scalar_add(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Hashes signature verification data into the\n+ *  randomization seed and initializes ecmult_context.\n+ *\n+ *  Returns 1 if the randomizer was successfully initialized.\n+ *\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out: ecmult_context: context for batch_ecmult_callback\n+ *  In/Out   sha: an initialized sha256 object which hashes the schnorrsig input in order to get a\n+ *                seed for the randomizer PRNG\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Sums the s part of all signatures multiplied by their\n+ *  randomizer.\n+ *\n+ *  Returns 1 if s is successfully summed.\n+ *\n+ *  In/Out: s: the s part of the input sigs is added to this s argument\n+ *  In:  chacha_seed: PRNG seed for computing randomizers\n+ *        sig: array of signatures, or NULL if there are no signatures\n+ *     n_sigs: number of signatures in above array (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_scalar *s, unsigned char *chacha_seed, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    secp256k1_scalar randomizer_cache[2];\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(randomizer_cache, chacha_seed, i / 2);\n+        }\n+\n+        secp256k1_scalar_set_b32(&term, &sig[i]->data[32], &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&term, &term, &randomizer_cache[i % 2]);\n+        secp256k1_scalar_add(s, s, &term);\n+    }\n+    return 1;\n+}\n+\n+/* schnorrsig batch verification.\n+ * Seeds a random number generator with the inputs and derives a random number ai for every\n+ * signature i. Fails if y-coordinate of any R is not a quadratic residue or if\n+ * 0 != -(s1 + a2*s2 + ... + au*su)G + R1 + a2*R2 + ... + au*Ru + e1*P1 + (a2*e2)P2 + ... + (au*eu)Pu. */\n+int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_scratch *scratch, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    secp256k1_schnorrsig_verify_ecmult_context ecmult_context;\n+    secp256k1_sha256 sha;\n+    secp256k1_scalar s;\n+    secp256k1_gej rj;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(scratch != NULL);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    if (!secp256k1_schnorrsig_verify_batch_init_randomizer(ctx, &ecmult_context, &sha, sig, msg32, pk, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_sha256_finalize(&sha, ecmult_context.chacha_seed);\n+\n+    secp256k1_scalar_clear(&s);\n+    if (!secp256k1_schnorrsig_verify_batch_sum_s(&s, ecmult_context.chacha_seed, sig, n_sigs)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_negate(&s, &s);\n+\n+    return secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &rj, &s, secp256k1_schnorrsig_verify_batch_ecmult_callback, (void *) &ecmult_context, 2 * n_sigs)",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 330,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": 224758604,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch! Although you'd have to give *me* 2^63 sigs. Fixing this.",
      "created_at": "2018-10-15T07:00:22Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225055208",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225055208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225174685",
      "pull_request_review_id": 164716498,
      "id": 225174685,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTE3NDY4NQ==",
      "diff_hunk": "@@ -0,0 +1,334 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if (idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_clear(sc);\n+        secp256k1_scalar_add(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Hashes signature verification data into the\n+ *  randomization seed and initializes ecmult_context.\n+ *\n+ *  Returns 1 if the randomizer was successfully initialized.\n+ *\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out: ecmult_context: context for batch_ecmult_callback\n+ *  In/Out   sha: an initialized sha256 object which hashes the schnorrsig input in order to get a\n+ *                seed for the randomizer PRNG\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Sums the s part of all signatures multiplied by their\n+ *  randomizer.\n+ *\n+ *  Returns 1 if s is successfully summed.\n+ *\n+ *  In/Out: s: the s part of the input sigs is added to this s argument\n+ *  In:  chacha_seed: PRNG seed for computing randomizers\n+ *        sig: array of signatures, or NULL if there are no signatures\n+ *     n_sigs: number of signatures in above array (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_sum_s(secp256k1_scalar *s, unsigned char *chacha_seed, const secp256k1_schnorrsig *const *sig, size_t n_sigs) {\n+    secp256k1_scalar randomizer_cache[2];\n+    size_t i;\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        int overflow;\n+        secp256k1_scalar term;\n+        if (i % 2 == 0) {\n+            secp256k1_schnorrsig_batch_randomizer(randomizer_cache, chacha_seed, i / 2);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 291,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": 224732385,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yup, I like that. We can remove the batch_randomizer function entirely and save unnecessary PRNG calls.",
      "created_at": "2018-10-15T13:56:12Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225174685",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225174685"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 291,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225174800",
      "pull_request_review_id": 164716581,
      "id": 225174800,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTE3NDgwMA==",
      "diff_hunk": "@@ -1,6 +1,7 @@\n bench_inv\n bench_ecdh\n bench_ecmult\n+bench_schnorrsig\n bench_sign\n bench_verify\n bench_schnorr_verify",
      "path": ".gitignore",
      "position": null,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": 224744413,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2018-10-15T13:56:21Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225174800",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225174800"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 7,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225174845",
      "pull_request_review_id": 164716649,
      "id": 225174845,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTE3NDg0NQ==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 22,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": 224745006,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2018-10-15T13:56:28Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225174845",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225174845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225174876",
      "pull_request_review_id": 164716697,
      "id": 225174876,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTE3NDg3Ng==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    const void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:      sig: the signature being verified (cannot be NULL)\n+ *         msg32: the 32-byte message hash being verified (cannot be NULL)\n+ *        pubkey: pointer to a public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies a set of Schnorr signatures",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 94,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": 224746160,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2018-10-15T13:56:34Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225174876",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225174876"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225473814",
      "pull_request_review_id": 165077679,
      "id": 225473814,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ3MzgxNA==",
      "diff_hunk": "@@ -314,12 +306,19 @@ int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_sc\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(scratch != NULL);\n+    /* Check that n_sigs is less than half of the maximum size_t value. This is necessary because\n+     * the number of points given to ecmult_multi is 2*n_sigs. */\n+    ARG_CHECK(n_sigs < (size_t)1 << (sizeof(size_t)*8-1));",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "40f8f7a44cf6fafa7a7299bf3cd0432da8635414",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`1 << sizeof(size_t)*8-1` is not necessarily half of the maximum value that can be represented by size_t. For example, there could be unused \"padding bits\" in the integer. This is only a problem on exotic platforms that we don't support anyway but yeah... Anyway,  a simpler expression is `MAX_SIZE >> 1` (only in C99) or equivalently `(size_t)(-1) >> 1` because we want C89.\r\n\r\nBUT I don't know if we need to go this far, I guess there are a lot of places where the code anyway assumes that `size_t` is at least 32 bits. So we probably can just use the check below? @sipa ",
      "created_at": "2018-10-16T09:57:07Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225473814",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225473814"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225539443",
      "pull_request_review_id": 165159034,
      "id": 225539443,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUzOTQ0Mw==",
      "diff_hunk": "@@ -314,12 +306,19 @@ int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_sc\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(scratch != NULL);\n+    /* Check that n_sigs is less than half of the maximum size_t value. This is necessary because\n+     * the number of points given to ecmult_multi is 2*n_sigs. */\n+    ARG_CHECK(n_sigs < (size_t)1 << (sizeof(size_t)*8-1));",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "40f8f7a44cf6fafa7a7299bf3cd0432da8635414",
      "in_reply_to_id": 225473814,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I would prefer `(size_t)(-1) >> 1` because it's easier to read. Or even use `/ 2` instead of `>> 1`, this will be evaluated at compile-time anyway.",
      "created_at": "2018-10-16T13:30:34Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225539443",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225539443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225582899",
      "pull_request_review_id": 165213790,
      "id": 225582899,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTU4Mjg5OQ==",
      "diff_hunk": "@@ -314,12 +306,19 @@ int secp256k1_schnorrsig_verify_batch(const secp256k1_context *ctx, secp256k1_sc\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(scratch != NULL);\n+    /* Check that n_sigs is less than half of the maximum size_t value. This is necessary because\n+     * the number of points given to ecmult_multi is 2*n_sigs. */\n+    ARG_CHECK(n_sigs < (size_t)1 << (sizeof(size_t)*8-1));",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "40f8f7a44cf6fafa7a7299bf3cd0432da8635414",
      "in_reply_to_id": 225473814,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2018-10-16T15:08:54Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225582899",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225582899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225610769",
      "pull_request_review_id": 165248523,
      "id": 225610769,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTYxMDc2OQ==",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    const void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 75,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "547ad32c79c3e98802b5cf510dcd410219788357",
      "in_reply_to_id": 220604143,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2018-10-16T16:16:16Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r225610769",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/225610769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/230941756",
      "pull_request_review_id": 171795830,
      "id": 230941756,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDk0MTc1Ng==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, size_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ff3a22d1478b1ba364988d4cef52384e830d0f8f",
      "in_reply_to_id": 220258957,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Marking as resolved, as `idx` has been changed to `uint64_t`.",
      "created_at": "2018-11-05T22:42:45Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r230941756",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/230941756"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 801,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/230944555",
      "pull_request_review_id": 171799261,
      "id": 230944555,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDk0NDU1NQ==",
      "diff_hunk": "@@ -961,12 +961,70 @@ void scalar_test(void) {\n \n }\n \n+void scalar_chacha_tests(void) {\n+    unsigned char expected1[64] = {\n+        0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90,\n+        0x40, 0x5d, 0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28,\n+        0xbd, 0xd2, 0x19, 0xb8, 0xa0, 0x8d, 0xed, 0x1a,\n+        0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77, 0x0d, 0xc7,\n+        0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n+        0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37,\n+        0x6a, 0x43, 0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c,\n+        0xc3, 0x87, 0xb6, 0x69, 0xb2, 0xee, 0x65, 0x86\n+    };\n+    unsigned char expected2[64] = {\n+        0x45, 0x40, 0xf0, 0x5a, 0x9f, 0x1f, 0xb2, 0x96,\n+        0xd7, 0x73, 0x6e, 0x7b, 0x20, 0x8e, 0x3c, 0x96,\n+        0xeb, 0x4f, 0xe1, 0x83, 0x46, 0x88, 0xd2, 0x60,\n+        0x4f, 0x45, 0x09, 0x52, 0xed, 0x43, 0x2d, 0x41,\n+        0xbb, 0xe2, 0xa0, 0xb6, 0xea, 0x75, 0x66, 0xd2,\n+        0xa5, 0xd1, 0xe7, 0xe2, 0x0d, 0x42, 0xaf, 0x2c,\n+        0x53, 0xd7, 0x92, 0xb1, 0xc4, 0x3f, 0xea, 0x81,\n+        0x7e, 0x9a, 0xd2, 0x75, 0xae, 0x54, 0x69, 0x63\n+    };\n+    unsigned char expected3[64] = {\n+        0x47, 0x4a, 0x4f, 0x35, 0x4f, 0xee, 0x93, 0x59,\n+        0xbb, 0x65, 0x81, 0xe5, 0xd9, 0x15, 0xa6, 0x01,\n+        0xb6, 0x8c, 0x68, 0x03, 0x38, 0xff, 0x65, 0xe6,\n+        0x56, 0x4a, 0x3e, 0x65, 0x59, 0xfc, 0x12, 0x3f,\n+        0xa9, 0xb2, 0xf9, 0x3e, 0x57, 0xc3, 0xa5, 0xcb,\n+        0xe0, 0x72, 0x74, 0x27, 0x88, 0x1c, 0x23, 0xdf,\n+        0xe2, 0xb6, 0xcc, 0xfb, 0x93, 0xed, 0xcb, 0x02,\n+        0xd7, 0x50, 0x52, 0x45, 0x84, 0x88, 0xbb, 0xea\n+    };\n+\n+    secp256k1_scalar exp_r1, exp_r2;\n+    secp256k1_scalar r1, r2;\n+    unsigned char seed1[32] = { 0 };\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed1, 0);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected1[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected1[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    seed1[31] = 1;\n+    secp256k1_scalar_chacha20(&r1, &r2, seed1, 0);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected2[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected2[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed1, 100);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected3[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected3[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+}",
      "path": "src/tests.c",
      "position": null,
      "original_position": 58,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's perhaps useful to add one test case with some arbitrary input and position, to make sure an implementation isn't swapping some of the first 31 bytes of the input seed for example.\r\n\r\nHere is a suggestion:\r\n```\r\n+    unsigned char input4[32] = {\r\n+        0x32, 0x56, 0x56, 0xf4, 0x29, 0x02, 0xc2, 0xf8,\r\n+        0xa3, 0x4b, 0x96, 0xf5, 0xa7, 0xf7, 0xe3, 0x6c,\r\n+        0x92, 0xad, 0xa5, 0x18, 0x1c, 0xe3, 0x41, 0xae,\r\n+        0xc3, 0xf3, 0x18, 0xd0, 0xfa, 0x5b, 0x72, 0x53\r\n+    };\r\n+    unsigned char expected4[64] = {\r\n+        0x28, 0xd3, 0x56, 0xe7, 0x5c, 0x19, 0xc6, 0xe9,\r\n+        0x21, 0x8e, 0x17, 0x6f, 0x11, 0x72, 0x1e, 0x8c,\r\n+        0x0d, 0x17, 0xbd, 0xe7, 0xe9, 0xad, 0x14, 0xac,\r\n+        0x92, 0xb6, 0x9f, 0x3d, 0xfb, 0x20, 0x09, 0xd6,\r\n+        0x6d, 0x3b, 0x8e, 0x43, 0xc7, 0xdc, 0x33, 0xe3,\r\n+        0xbb, 0x6f, 0x07, 0x6c, 0xb5, 0xc8, 0xb4, 0x1f,\r\n+        0x12, 0xe5, 0x6c, 0xe3, 0x0c, 0x64, 0xd7, 0xd9,\r\n+        0xab, 0x0d, 0xa7, 0xf5, 0x81, 0xf1, 0x03, 0x79\r\n+    };\r\n+\r\n+    secp256k1_scalar_chacha20(&r1, &r2, input4, 0x6ff8602a7a78e2f2ULL);\r\n+    secp256k1_scalar_set_b32(&exp_r1, &expected4[0], NULL);\r\n+    secp256k1_scalar_set_b32(&exp_r2, &expected4[32], NULL);\r\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\r\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\r\n```\r\n",
      "created_at": "2018-11-05T22:53:52Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r230944555",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/230944555"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1093,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/230949114",
      "pull_request_review_id": 171799261,
      "id": 230949114,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDk0OTExNA==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = BE32(x0);",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is it necessary to define our PRNG function as \"output bytes of ChaCha20 interpreted as BE-encoded scalars\"? Using LE would be (very slightly) faster on almost every architecture, if we're not bound by any specific standard.",
      "created_at": "2018-11-05T23:12:28Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r230949114",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/230949114"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/230953311",
      "pull_request_review_id": 171799261,
      "id": 230953311,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDk1MzMxMQ==",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 9,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f12dd1a8597e7f9da0176acc4c86371c2c3caa92",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As the Schnorr signature BIP defines the actual byte representation of signatures, there is no distinction between \"invalid because incorrect values\" and \"invalid because incorrect serialization\" (as is the case with ECDSA and DER encoding).\r\n\r\nBecause of that, there seems to not be any strict need for separately exposed parse/serialize functions. That is unless we expect operations besides sign/verify that operate on signatures, which one is expected to use without intervening serialization step. In that case we may opt to later change the representation inside to be a `secp256k1_fe_storage` and a `secp256k1_scalar`.",
      "created_at": "2018-11-05T23:31:52Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r230953311",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/230953311"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231126234",
      "pull_request_review_id": 172022156,
      "id": 231126234,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTEyNjIzNA==",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 9,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f12dd1a8597e7f9da0176acc4c86371c2c3caa92",
      "in_reply_to_id": 230953311,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We cannot use `secp256k1_fe_storage` or `secp256k1_scalar` because the size of these objects is not exported, so it would prevent users building them on the stack.\r\n\r\nEliminating parse/serialize operations will prevent any future changes we might want to do that could use a more efficient format. On the other hand, I can't imagine what future changes those might be.",
      "created_at": "2018-11-06T13:44:51Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r231126234",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231126234"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231126709",
      "pull_request_review_id": 172022784,
      "id": 231126709,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTEyNjcwOQ==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = BE32(x0);",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": 230949114,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sounds good. AFAIK we do not use this rng anywhere where a verifier could detect it anyway (it is used in Bulletproof rewinding, but that only requires sender/recipient to agree on a rng, not that it be anything in particular).",
      "created_at": "2018-11-06T13:46:18Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r231126709",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231126709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231157634",
      "pull_request_review_id": 172062229,
      "id": 231157634,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTE1NzYzNA==",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 9,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f12dd1a8597e7f9da0176acc4c86371c2c3caa92",
      "in_reply_to_id": 230953311,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Look at how `secp256k1_pubkey_load` works :)\n\nAnd yes, I can't imagine what those operations would be either. I'd like to make sure we're not committing to an unnecessarily complex API without reason.\n",
      "created_at": "2018-11-06T15:04:37Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r231157634",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231157634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231205069",
      "pull_request_review_id": 172122842,
      "id": 231205069,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTIwNTA2OQ==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = BE32(x0);",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": 230949114,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, and even if we're using it somewhere else, it wouldn't matter. As I understand it, this discussion is about interpreting the output bytes. So we're anyway using it according to the standard.",
      "created_at": "2018-11-06T16:54:06Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r231205069",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231205069"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231674782",
      "pull_request_review_id": 172696637,
      "id": 231674782,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTY3NDc4Mg==",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 9,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f12dd1a8597e7f9da0176acc4c86371c2c3caa92",
      "in_reply_to_id": 230953311,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Makes sense to me to remove the parse/serialize functions. In the event that there's a better representation it could be its own struct.",
      "created_at": "2018-11-07T21:00:37Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r231674782",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231674782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231708878",
      "pull_request_review_id": 172738078,
      "id": 231708878,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTcwODg3OA==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = BE32(x0);",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": 230949114,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "[RFC](https://tools.ietf.org/html/rfc8439) even says LE (for keystreams but we're getting scalars so I agree it doesn't matter): \"At the end of 20 rounds (or 10 iterations of the above list), we add\r\n   the original input words to the output words, and serialize the\r\n   result by sequencing the words one-by-one in little-endian order.\"",
      "created_at": "2018-11-07T22:51:46Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r231708878",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231708878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231884049",
      "pull_request_review_id": 172951893,
      "id": 231884049,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTg4NDA0OQ==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = BE32(x0);",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": 230949114,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "But we don't care about the concrete PRG instantiation and other implementations can use whatever they like, right? Or do we want to standardize it (in the BIP)?\r\n\r\nI'm just asking to be sure, I don't think it's necessary to standardize it. Advantages are 1) implementations can be (consensus-)consistent with each other, but that's only relevant in cases that should happen with at most negligible probability, and 2) maybe people won't get the idea to use their home-made PRG. The obvious disadvantage is less flexibility.\r\n",
      "created_at": "2018-11-08T13:23:30Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r231884049",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/231884049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/238079378",
      "pull_request_review_id": 180541441,
      "id": 238079378,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODA3OTM3OA==",
      "diff_hunk": "@@ -0,0 +1,669 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+void test_schnorrsig_serialize(void) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char in[64];\n+    unsigned char out[64];\n+\n+    memset(in, 0x12, 64);\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, in));\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, out, &sig));\n+    CHECK(memcmp(in, out, 64) == 0);\n+}\n+\n+void test_schnorrsig_api(secp256k1_scratch_space *scratch) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    unsigned char sig64[64];\n+    secp256k1_pubkey pk[3];\n+    secp256k1_schnorrsig sig;\n+    const secp256k1_schnorrsig *sigptr = &sig;\n+    const unsigned char *msgptr = msg;\n+    const secp256k1_pubkey *pkptr = &pk[0];\n+    int negated_nonce;\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk1) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[1], sk2) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[2], sk3) == 1);\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, NULL, msg, sk1, NULL, NULL) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, NULL, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, &sig) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_serialize(none, NULL, &sig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, sig64) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, NULL, sig64) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, NULL) == 0);\n+    CHECK(ecount == 4);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify(none, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify_batch(none, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify_batch(sign, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, 1) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, NULL, NULL, 0) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, NULL, &pkptr, 1) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, NULL, 1) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, (size_t)1 << (sizeof(size_t)*8-1)) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, 1 << 31) == 0);\n+    CHECK(ecount == 7);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Signs the message and checks that it's the same as expected_sig. */\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, const unsigned char *msg, const unsigned char *expected_sig, const int expected_negated_nonce) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char serialized_sig[64];\n+    secp256k1_pubkey pk;\n+    int negated_nonce;\n+\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, &negated_nonce, msg, sk, NULL, NULL));\n+    CHECK(negated_nonce == expected_negated_nonce);\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, serialized_sig, &sig));\n+    CHECK(memcmp(serialized_sig, expected_sig, 64) == 0);\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, &sig, msg, &pk));\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Checks that both verify and verify_batch return the same value as expected. */\n+void test_schnorrsig_bip_vectors_check_verify(secp256k1_scratch_space *scratch, const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *sig_serialized, int expected) {\n+    const unsigned char *msg_arr[1];\n+    const secp256k1_schnorrsig *sig_arr[1];\n+    const secp256k1_pubkey *pk_arr[1];\n+    secp256k1_pubkey pk;\n+    secp256k1_schnorrsig sig;\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, sig_serialized));\n+\n+    sig_arr[0] = &sig;\n+    msg_arr[0] = msg32;\n+    pk_arr[0] = &pk;\n+\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, &sig, msg32, &pk));\n+    CHECK(expected == secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 1));\n+}\n+\n+void test_schnorrsig_bip_vectors(secp256k1_scratch_space *scratch) {\n+    {\n+        /* Test vector 1 */\n+        const unsigned char sk1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        };\n+        const unsigned char pk1[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig1[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x70, 0x31, 0xA9, 0x88, 0x31, 0x85, 0x9D, 0xC3,\n+            0x4D, 0xFF, 0xEE, 0xDD, 0xA8, 0x68, 0x31, 0x84,\n+            0x2C, 0xCD, 0x00, 0x79, 0xE1, 0xF9, 0x2A, 0xF1,\n+            0x77, 0xF7, 0xF2, 0x2C, 0xC1, 0xDC, 0xED, 0x05\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk1, pk1, msg1, sig1, 1);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk1, msg1, sig1, 1);\n+    }\n+    {\n+        /* Test vector 2 */\n+        const unsigned char sk2[32] = {\n+            0xB7, 0xE1, 0x51, 0x62, 0x8A, 0xED, 0x2A, 0x6A,\n+            0xBF, 0x71, 0x58, 0x80, 0x9C, 0xF4, 0xF3, 0xC7,\n+            0x62, 0xE7, 0x16, 0x0F, 0x38, 0xB4, 0xDA, 0x56,\n+            0xA7, 0x84, 0xD9, 0x04, 0x51, 0x90, 0xCF, 0xEF\n+        };\n+        const unsigned char pk2[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg2[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig2[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk2, pk2, msg2, sig2, 0);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk2, msg2, sig2, 1);\n+    }\n+    {\n+        /* Test vector 3 */\n+        const unsigned char sk3[32] = {\n+            0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n+            0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n+            0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n+            0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x14, 0xE5, 0xC7\n+        };\n+        const unsigned char pk3[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg3[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig3[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0x00, 0x88, 0x03, 0x71, 0xD0, 0x17, 0x66, 0x93,\n+            0x5B, 0x92, 0xD2, 0xAB, 0x4C, 0xD5, 0xC8, 0xA2,\n+            0xA5, 0x83, 0x7E, 0xC5, 0x7F, 0xED, 0x76, 0x60,\n+            0x77, 0x3A, 0x05, 0xF0, 0xDE, 0x14, 0x23, 0x80\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk3, pk3, msg3, sig3, 0);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk3, msg3, sig3, 1);\n+    }\n+    {\n+        /* Test vector 4 */\n+        const unsigned char pk4[33] = {\n+            0x03, 0xDE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        const unsigned char msg4[32] = {\n+            0x4D, 0xF3, 0xC3, 0xF6, 0x8F, 0xCC, 0x83, 0xB2,\n+            0x7E, 0x9D, 0x42, 0xC9, 0x04, 0x31, 0xA7, 0x24,\n+            0x99, 0xF1, 0x78, 0x75, 0xC8, 0x1A, 0x59, 0x9B,\n+            0x56, 0x6C, 0x98, 0x89, 0xB9, 0x69, 0x67, 0x03\n+        };\n+        const unsigned char sig4[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x3B, 0x78, 0xCE, 0x56, 0x3F,\n+            0x89, 0xA0, 0xED, 0x94, 0x14, 0xF5, 0xAA, 0x28,\n+            0xAD, 0x0D, 0x96, 0xD6, 0x79, 0x5F, 0x9C, 0x63,\n+            0x02, 0xA8, 0xDC, 0x32, 0xE6, 0x4E, 0x86, 0xA3,\n+            0x33, 0xF2, 0x0E, 0xF5, 0x6E, 0xAC, 0x9B, 0xA3,\n+            0x0B, 0x72, 0x46, 0xD6, 0xD2, 0x5E, 0x22, 0xAD,\n+            0xB8, 0xC6, 0xBE, 0x1A, 0xEB, 0x08, 0xD4, 0x9D\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk4, msg4, sig4, 1);\n+    }\n+    {\n+        /* Test vector 4B */\n+        const unsigned char pk4B[33] = {\n+            0x03, 0x1B, 0x84, 0xC5, 0x56, 0x7B, 0x12, 0x64,\n+            0x40, 0x99, 0x5D, 0x3E, 0xD5, 0xAA, 0xBA, 0x05,\n+            0x65, 0xD7, 0x1E, 0x18, 0x34, 0x60, 0x48, 0x19,\n+            0xFF, 0x9C, 0x17, 0xF5, 0xE9, 0xD5, 0xDD, 0x07,\n+            0x8F\n+        };\n+        const unsigned char msg4B[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig4B[64] = {\n+            0x52, 0x81, 0x85, 0x79, 0xAC, 0xA5, 0x97, 0x67,\n+            0xE3, 0x29, 0x1D, 0x91, 0xB7, 0x6B, 0x63, 0x7B,\n+            0xEF, 0x06, 0x20, 0x83, 0x28, 0x49, 0x92, 0xF2,\n+            0xD9, 0x5F, 0x56, 0x4C, 0xA6, 0xCB, 0x4E, 0x35,\n+            0x30, 0xB1, 0xDA, 0x84, 0x9C, 0x8E, 0x83, 0x04,\n+            0xAD, 0xC0, 0xCF, 0xE8, 0x70, 0x66, 0x03, 0x34,\n+            0xB3, 0xCF, 0xC1, 0x8E, 0x82, 0x5E, 0xF1, 0xDB,\n+            0x34, 0xCF, 0xAE, 0x3D, 0xFC, 0x5D, 0x81, 0x87\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk4B, msg4B, sig4B, 1);\n+    }\n+    {\n+        /* Test vector 5 */\n+        const unsigned char pk5[33] = {\n+            0x03, 0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        secp256k1_pubkey pk5_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_ec_pubkey_parse(ctx, &pk5_parsed, pk5, 33));\n+    }\n+    {\n+        /* Test vector 6 */\n+        const unsigned char pk6[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg6[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig6[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFA, 0x16, 0xAE, 0xE0, 0x66, 0x09, 0x28, 0x0A,\n+            0x19, 0xB6, 0x7A, 0x24, 0xE1, 0x97, 0x7E, 0x46,\n+            0x97, 0x71, 0x2B, 0x5F, 0xD2, 0x94, 0x39, 0x14,\n+            0xEC, 0xD5, 0xF7, 0x30, 0x90, 0x1B, 0x4A, 0xB7\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk6, msg6, sig6, 0);\n+    }\n+    {\n+        /* Test vector 7 */\n+        const unsigned char pk7[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg7[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig7[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0xD0, 0x92, 0xF9, 0xD8, 0x60, 0xF1, 0x77, 0x6A,\n+            0x1F, 0x74, 0x12, 0xAD, 0x8A, 0x1E, 0xB5, 0x0D,\n+            0xAC, 0xCC, 0x22, 0x2B, 0xC8, 0xC0, 0xE2, 0x6B,\n+            0x20, 0x56, 0xDF, 0x2F, 0x27, 0x3E, 0xFD, 0xEC\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk7, msg7, sig7, 0);\n+    }\n+    {\n+        /* Test vector 8 */\n+        const unsigned char pk8[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg8[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig8[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x8F, 0xCE, 0x56, 0x77, 0xCE, 0x7A, 0x62, 0x3C,\n+            0xB2, 0x00, 0x11, 0x22, 0x57, 0x97, 0xCE, 0x7A,\n+            0x8D, 0xE1, 0xDC, 0x6C, 0xCD, 0x4F, 0x75, 0x4A,\n+            0x47, 0xDA, 0x6C, 0x60, 0x0E, 0x59, 0x54, 0x3C\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk8, msg8, sig8, 0);\n+    }\n+    {\n+        /* Test vector 9 */\n+        const unsigned char pk9[33] = {\n+            0x03, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg9[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig9[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk9, msg9, sig9, 0);\n+    }\n+    {\n+        /* Test vector 10 */\n+        const unsigned char pk10[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg10[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig10[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x8C, 0x34, 0x28, 0x86, 0x9A, 0x66, 0x3E, 0xD1,\n+            0xE9, 0x54, 0x70, 0x5B, 0x02, 0x0C, 0xBB, 0x3E,\n+            0x7B, 0xB6, 0xAC, 0x31, 0x96, 0x5B, 0x9E, 0xA4,\n+            0xC7, 0x3E, 0x22, 0x7B, 0x17, 0xC5, 0xAF, 0x5A\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk10, msg10, sig10, 0);\n+    }\n+    {\n+        /* Test vector 11 */\n+        const unsigned char pk11[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg11[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig11[64] = {\n+            0x4A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk11, msg11, sig11, 0);\n+    }\n+    {\n+        /* Test vector 12 */\n+        const unsigned char pk12[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg12[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig12[64] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x2F,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk12, msg12, sig12, 0);\n+    }\n+    {\n+        /* Test vector 13 */\n+        const unsigned char pk13[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg13[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig13[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk13, msg13, sig13, 0);\n+    }",
      "path": "src/modules/schnorrsig/tests_impl.h",
      "position": 633,
      "original_position": 553,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "27b9d429f4cedcc805ce4a95bc96b5265666087e",
      "in_reply_to_id": null,
      "user": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be beneficial to know what theses test vector are actually testing for, especially the negative ones.\r\n\r\nI gather that:\r\nTest 6 check what happen when R.y is not a quadratic residue.\r\nTest 7 is test 3 with an invalid value for s ? Is that value somehow specific ?\r\nTest 8 is test 1 with negated s ?\r\nTest 9 is test 9 with a negated pubkey.\r\nTest 10 is test 2 with s such as s * G = e * P so R goes to infinity.\r\nTest 11 is test 2 with an invalid value for r.\r\nTest 12 is test 2 with r >= n.\r\nTest 13 is test 2 with s >= p.\r\n\r\nWhile I can gather why most of them are doing, some of them still are unclear, and, in any case, I do not think it is beneficial that detective work is required to figure this out.",
      "created_at": "2018-12-01T23:04:39Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r238079378",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/238079378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 633,
      "original_line": 633,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/238581323",
      "pull_request_review_id": 181155311,
      "id": 238581323,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODU4MTMyMw==",
      "diff_hunk": "@@ -0,0 +1,669 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+void test_schnorrsig_serialize(void) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char in[64];\n+    unsigned char out[64];\n+\n+    memset(in, 0x12, 64);\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, in));\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, out, &sig));\n+    CHECK(memcmp(in, out, 64) == 0);\n+}\n+\n+void test_schnorrsig_api(secp256k1_scratch_space *scratch) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    unsigned char sig64[64];\n+    secp256k1_pubkey pk[3];\n+    secp256k1_schnorrsig sig;\n+    const secp256k1_schnorrsig *sigptr = &sig;\n+    const unsigned char *msgptr = msg;\n+    const secp256k1_pubkey *pkptr = &pk[0];\n+    int negated_nonce;\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk1) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[1], sk2) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[2], sk3) == 1);\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, NULL, msg, sk1, NULL, NULL) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, NULL, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, &sig) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_serialize(none, NULL, &sig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, sig64) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, NULL, sig64) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, NULL) == 0);\n+    CHECK(ecount == 4);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify(none, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify_batch(none, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify_batch(sign, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, 1) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, NULL, NULL, 0) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, NULL, &pkptr, 1) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, NULL, 1) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, (size_t)1 << (sizeof(size_t)*8-1)) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, 1 << 31) == 0);\n+    CHECK(ecount == 7);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Signs the message and checks that it's the same as expected_sig. */\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, const unsigned char *msg, const unsigned char *expected_sig, const int expected_negated_nonce) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char serialized_sig[64];\n+    secp256k1_pubkey pk;\n+    int negated_nonce;\n+\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, &negated_nonce, msg, sk, NULL, NULL));\n+    CHECK(negated_nonce == expected_negated_nonce);\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, serialized_sig, &sig));\n+    CHECK(memcmp(serialized_sig, expected_sig, 64) == 0);\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, &sig, msg, &pk));\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Checks that both verify and verify_batch return the same value as expected. */\n+void test_schnorrsig_bip_vectors_check_verify(secp256k1_scratch_space *scratch, const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *sig_serialized, int expected) {\n+    const unsigned char *msg_arr[1];\n+    const secp256k1_schnorrsig *sig_arr[1];\n+    const secp256k1_pubkey *pk_arr[1];\n+    secp256k1_pubkey pk;\n+    secp256k1_schnorrsig sig;\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, sig_serialized));\n+\n+    sig_arr[0] = &sig;\n+    msg_arr[0] = msg32;\n+    pk_arr[0] = &pk;\n+\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, &sig, msg32, &pk));\n+    CHECK(expected == secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 1));\n+}\n+\n+void test_schnorrsig_bip_vectors(secp256k1_scratch_space *scratch) {\n+    {\n+        /* Test vector 1 */\n+        const unsigned char sk1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        };\n+        const unsigned char pk1[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig1[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x70, 0x31, 0xA9, 0x88, 0x31, 0x85, 0x9D, 0xC3,\n+            0x4D, 0xFF, 0xEE, 0xDD, 0xA8, 0x68, 0x31, 0x84,\n+            0x2C, 0xCD, 0x00, 0x79, 0xE1, 0xF9, 0x2A, 0xF1,\n+            0x77, 0xF7, 0xF2, 0x2C, 0xC1, 0xDC, 0xED, 0x05\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk1, pk1, msg1, sig1, 1);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk1, msg1, sig1, 1);\n+    }\n+    {\n+        /* Test vector 2 */\n+        const unsigned char sk2[32] = {\n+            0xB7, 0xE1, 0x51, 0x62, 0x8A, 0xED, 0x2A, 0x6A,\n+            0xBF, 0x71, 0x58, 0x80, 0x9C, 0xF4, 0xF3, 0xC7,\n+            0x62, 0xE7, 0x16, 0x0F, 0x38, 0xB4, 0xDA, 0x56,\n+            0xA7, 0x84, 0xD9, 0x04, 0x51, 0x90, 0xCF, 0xEF\n+        };\n+        const unsigned char pk2[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg2[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig2[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk2, pk2, msg2, sig2, 0);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk2, msg2, sig2, 1);\n+    }\n+    {\n+        /* Test vector 3 */\n+        const unsigned char sk3[32] = {\n+            0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n+            0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n+            0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n+            0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x14, 0xE5, 0xC7\n+        };\n+        const unsigned char pk3[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg3[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig3[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0x00, 0x88, 0x03, 0x71, 0xD0, 0x17, 0x66, 0x93,\n+            0x5B, 0x92, 0xD2, 0xAB, 0x4C, 0xD5, 0xC8, 0xA2,\n+            0xA5, 0x83, 0x7E, 0xC5, 0x7F, 0xED, 0x76, 0x60,\n+            0x77, 0x3A, 0x05, 0xF0, 0xDE, 0x14, 0x23, 0x80\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk3, pk3, msg3, sig3, 0);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk3, msg3, sig3, 1);\n+    }\n+    {\n+        /* Test vector 4 */\n+        const unsigned char pk4[33] = {\n+            0x03, 0xDE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        const unsigned char msg4[32] = {\n+            0x4D, 0xF3, 0xC3, 0xF6, 0x8F, 0xCC, 0x83, 0xB2,\n+            0x7E, 0x9D, 0x42, 0xC9, 0x04, 0x31, 0xA7, 0x24,\n+            0x99, 0xF1, 0x78, 0x75, 0xC8, 0x1A, 0x59, 0x9B,\n+            0x56, 0x6C, 0x98, 0x89, 0xB9, 0x69, 0x67, 0x03\n+        };\n+        const unsigned char sig4[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x3B, 0x78, 0xCE, 0x56, 0x3F,\n+            0x89, 0xA0, 0xED, 0x94, 0x14, 0xF5, 0xAA, 0x28,\n+            0xAD, 0x0D, 0x96, 0xD6, 0x79, 0x5F, 0x9C, 0x63,\n+            0x02, 0xA8, 0xDC, 0x32, 0xE6, 0x4E, 0x86, 0xA3,\n+            0x33, 0xF2, 0x0E, 0xF5, 0x6E, 0xAC, 0x9B, 0xA3,\n+            0x0B, 0x72, 0x46, 0xD6, 0xD2, 0x5E, 0x22, 0xAD,\n+            0xB8, 0xC6, 0xBE, 0x1A, 0xEB, 0x08, 0xD4, 0x9D\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk4, msg4, sig4, 1);\n+    }\n+    {\n+        /* Test vector 4B */\n+        const unsigned char pk4B[33] = {\n+            0x03, 0x1B, 0x84, 0xC5, 0x56, 0x7B, 0x12, 0x64,\n+            0x40, 0x99, 0x5D, 0x3E, 0xD5, 0xAA, 0xBA, 0x05,\n+            0x65, 0xD7, 0x1E, 0x18, 0x34, 0x60, 0x48, 0x19,\n+            0xFF, 0x9C, 0x17, 0xF5, 0xE9, 0xD5, 0xDD, 0x07,\n+            0x8F\n+        };\n+        const unsigned char msg4B[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig4B[64] = {\n+            0x52, 0x81, 0x85, 0x79, 0xAC, 0xA5, 0x97, 0x67,\n+            0xE3, 0x29, 0x1D, 0x91, 0xB7, 0x6B, 0x63, 0x7B,\n+            0xEF, 0x06, 0x20, 0x83, 0x28, 0x49, 0x92, 0xF2,\n+            0xD9, 0x5F, 0x56, 0x4C, 0xA6, 0xCB, 0x4E, 0x35,\n+            0x30, 0xB1, 0xDA, 0x84, 0x9C, 0x8E, 0x83, 0x04,\n+            0xAD, 0xC0, 0xCF, 0xE8, 0x70, 0x66, 0x03, 0x34,\n+            0xB3, 0xCF, 0xC1, 0x8E, 0x82, 0x5E, 0xF1, 0xDB,\n+            0x34, 0xCF, 0xAE, 0x3D, 0xFC, 0x5D, 0x81, 0x87\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk4B, msg4B, sig4B, 1);\n+    }\n+    {\n+        /* Test vector 5 */\n+        const unsigned char pk5[33] = {\n+            0x03, 0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        secp256k1_pubkey pk5_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_ec_pubkey_parse(ctx, &pk5_parsed, pk5, 33));\n+    }\n+    {\n+        /* Test vector 6 */\n+        const unsigned char pk6[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg6[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig6[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFA, 0x16, 0xAE, 0xE0, 0x66, 0x09, 0x28, 0x0A,\n+            0x19, 0xB6, 0x7A, 0x24, 0xE1, 0x97, 0x7E, 0x46,\n+            0x97, 0x71, 0x2B, 0x5F, 0xD2, 0x94, 0x39, 0x14,\n+            0xEC, 0xD5, 0xF7, 0x30, 0x90, 0x1B, 0x4A, 0xB7\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk6, msg6, sig6, 0);\n+    }\n+    {\n+        /* Test vector 7 */\n+        const unsigned char pk7[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg7[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig7[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0xD0, 0x92, 0xF9, 0xD8, 0x60, 0xF1, 0x77, 0x6A,\n+            0x1F, 0x74, 0x12, 0xAD, 0x8A, 0x1E, 0xB5, 0x0D,\n+            0xAC, 0xCC, 0x22, 0x2B, 0xC8, 0xC0, 0xE2, 0x6B,\n+            0x20, 0x56, 0xDF, 0x2F, 0x27, 0x3E, 0xFD, 0xEC\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk7, msg7, sig7, 0);\n+    }\n+    {\n+        /* Test vector 8 */\n+        const unsigned char pk8[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg8[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig8[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x8F, 0xCE, 0x56, 0x77, 0xCE, 0x7A, 0x62, 0x3C,\n+            0xB2, 0x00, 0x11, 0x22, 0x57, 0x97, 0xCE, 0x7A,\n+            0x8D, 0xE1, 0xDC, 0x6C, 0xCD, 0x4F, 0x75, 0x4A,\n+            0x47, 0xDA, 0x6C, 0x60, 0x0E, 0x59, 0x54, 0x3C\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk8, msg8, sig8, 0);\n+    }\n+    {\n+        /* Test vector 9 */\n+        const unsigned char pk9[33] = {\n+            0x03, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg9[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig9[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk9, msg9, sig9, 0);\n+    }\n+    {\n+        /* Test vector 10 */\n+        const unsigned char pk10[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg10[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig10[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x8C, 0x34, 0x28, 0x86, 0x9A, 0x66, 0x3E, 0xD1,\n+            0xE9, 0x54, 0x70, 0x5B, 0x02, 0x0C, 0xBB, 0x3E,\n+            0x7B, 0xB6, 0xAC, 0x31, 0x96, 0x5B, 0x9E, 0xA4,\n+            0xC7, 0x3E, 0x22, 0x7B, 0x17, 0xC5, 0xAF, 0x5A\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk10, msg10, sig10, 0);\n+    }\n+    {\n+        /* Test vector 11 */\n+        const unsigned char pk11[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg11[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig11[64] = {\n+            0x4A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk11, msg11, sig11, 0);\n+    }\n+    {\n+        /* Test vector 12 */\n+        const unsigned char pk12[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg12[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig12[64] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x2F,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk12, msg12, sig12, 0);\n+    }\n+    {\n+        /* Test vector 13 */\n+        const unsigned char pk13[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg13[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig13[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk13, msg13, sig13, 0);\n+    }",
      "path": "src/modules/schnorrsig/tests_impl.h",
      "position": 633,
      "original_position": 553,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "27b9d429f4cedcc805ce4a95bc96b5265666087e",
      "in_reply_to_id": 238079378,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The function uses the test vectors from the BIP as indicated by the name of the function (`test_schnorrsig_bip_vectors`). The BIP has an explanation for the test vectors at https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#test-vectors-and-reference-code. It may be better to add a link to the BIP test vectors but I didn't want to do that while it's not merged into the BIP repo.",
      "created_at": "2018-12-04T09:21:48Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r238581323",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/238581323"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 633,
      "original_line": 633,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/238670432",
      "pull_request_review_id": 181266765,
      "id": 238670432,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODY3MDQzMg==",
      "diff_hunk": "@@ -0,0 +1,669 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+void test_schnorrsig_serialize(void) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char in[64];\n+    unsigned char out[64];\n+\n+    memset(in, 0x12, 64);\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, in));\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, out, &sig));\n+    CHECK(memcmp(in, out, 64) == 0);\n+}\n+\n+void test_schnorrsig_api(secp256k1_scratch_space *scratch) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    unsigned char sig64[64];\n+    secp256k1_pubkey pk[3];\n+    secp256k1_schnorrsig sig;\n+    const secp256k1_schnorrsig *sigptr = &sig;\n+    const unsigned char *msgptr = msg;\n+    const secp256k1_pubkey *pkptr = &pk[0];\n+    int negated_nonce;\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk1) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[1], sk2) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk[2], sk3) == 1);\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, msg, sk1, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, &negated_nonce, msg, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, NULL, msg, sk1, NULL, NULL) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, NULL, sk1, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, &sig, &negated_nonce, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, &sig) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_serialize(none, NULL, &sig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_serialize(none, sig64, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, sig64) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_parse(none, NULL, sig64) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_parse(none, &sig, NULL) == 0);\n+    CHECK(ecount == 4);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify(none, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, &sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, &sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify_batch(none, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify_batch(sign, scratch, &sigptr, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, 1) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, NULL, NULL, 0) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, NULL, &msgptr, &pkptr, 1) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, NULL, &pkptr, 1) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, NULL, 1) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, (size_t)1 << (sizeof(size_t)*8-1)) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_schnorrsig_verify_batch(vrfy, scratch, &sigptr, &msgptr, &pkptr, 1 << 31) == 0);\n+    CHECK(ecount == 7);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Signs the message and checks that it's the same as expected_sig. */\n+void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const unsigned char *pk_serialized, const unsigned char *msg, const unsigned char *expected_sig, const int expected_negated_nonce) {\n+    secp256k1_schnorrsig sig;\n+    unsigned char serialized_sig[64];\n+    secp256k1_pubkey pk;\n+    int negated_nonce;\n+\n+    CHECK(secp256k1_schnorrsig_sign(ctx, &sig, &negated_nonce, msg, sk, NULL, NULL));\n+    CHECK(negated_nonce == expected_negated_nonce);\n+    CHECK(secp256k1_schnorrsig_serialize(ctx, serialized_sig, &sig));\n+    CHECK(memcmp(serialized_sig, expected_sig, 64) == 0);\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_verify(ctx, &sig, msg, &pk));\n+}\n+\n+/* Helper function for schnorrsig_bip_vectors\n+ * Checks that both verify and verify_batch return the same value as expected. */\n+void test_schnorrsig_bip_vectors_check_verify(secp256k1_scratch_space *scratch, const unsigned char *pk_serialized, const unsigned char *msg32, const unsigned char *sig_serialized, int expected) {\n+    const unsigned char *msg_arr[1];\n+    const secp256k1_schnorrsig *sig_arr[1];\n+    const secp256k1_pubkey *pk_arr[1];\n+    secp256k1_pubkey pk;\n+    secp256k1_schnorrsig sig;\n+\n+    CHECK(secp256k1_ec_pubkey_parse(ctx, &pk, pk_serialized, 33));\n+    CHECK(secp256k1_schnorrsig_parse(ctx, &sig, sig_serialized));\n+\n+    sig_arr[0] = &sig;\n+    msg_arr[0] = msg32;\n+    pk_arr[0] = &pk;\n+\n+    CHECK(expected == secp256k1_schnorrsig_verify(ctx, &sig, msg32, &pk));\n+    CHECK(expected == secp256k1_schnorrsig_verify_batch(ctx, scratch, sig_arr, msg_arr, pk_arr, 1));\n+}\n+\n+void test_schnorrsig_bip_vectors(secp256k1_scratch_space *scratch) {\n+    {\n+        /* Test vector 1 */\n+        const unsigned char sk1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+        };\n+        const unsigned char pk1[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg1[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig1[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x70, 0x31, 0xA9, 0x88, 0x31, 0x85, 0x9D, 0xC3,\n+            0x4D, 0xFF, 0xEE, 0xDD, 0xA8, 0x68, 0x31, 0x84,\n+            0x2C, 0xCD, 0x00, 0x79, 0xE1, 0xF9, 0x2A, 0xF1,\n+            0x77, 0xF7, 0xF2, 0x2C, 0xC1, 0xDC, 0xED, 0x05\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk1, pk1, msg1, sig1, 1);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk1, msg1, sig1, 1);\n+    }\n+    {\n+        /* Test vector 2 */\n+        const unsigned char sk2[32] = {\n+            0xB7, 0xE1, 0x51, 0x62, 0x8A, 0xED, 0x2A, 0x6A,\n+            0xBF, 0x71, 0x58, 0x80, 0x9C, 0xF4, 0xF3, 0xC7,\n+            0x62, 0xE7, 0x16, 0x0F, 0x38, 0xB4, 0xDA, 0x56,\n+            0xA7, 0x84, 0xD9, 0x04, 0x51, 0x90, 0xCF, 0xEF\n+        };\n+        const unsigned char pk2[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg2[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig2[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk2, pk2, msg2, sig2, 0);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk2, msg2, sig2, 1);\n+    }\n+    {\n+        /* Test vector 3 */\n+        const unsigned char sk3[32] = {\n+            0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n+            0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n+            0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n+            0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x14, 0xE5, 0xC7\n+        };\n+        const unsigned char pk3[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg3[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig3[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0x00, 0x88, 0x03, 0x71, 0xD0, 0x17, 0x66, 0x93,\n+            0x5B, 0x92, 0xD2, 0xAB, 0x4C, 0xD5, 0xC8, 0xA2,\n+            0xA5, 0x83, 0x7E, 0xC5, 0x7F, 0xED, 0x76, 0x60,\n+            0x77, 0x3A, 0x05, 0xF0, 0xDE, 0x14, 0x23, 0x80\n+        };\n+        test_schnorrsig_bip_vectors_check_signing(sk3, pk3, msg3, sig3, 0);\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk3, msg3, sig3, 1);\n+    }\n+    {\n+        /* Test vector 4 */\n+        const unsigned char pk4[33] = {\n+            0x03, 0xDE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        const unsigned char msg4[32] = {\n+            0x4D, 0xF3, 0xC3, 0xF6, 0x8F, 0xCC, 0x83, 0xB2,\n+            0x7E, 0x9D, 0x42, 0xC9, 0x04, 0x31, 0xA7, 0x24,\n+            0x99, 0xF1, 0x78, 0x75, 0xC8, 0x1A, 0x59, 0x9B,\n+            0x56, 0x6C, 0x98, 0x89, 0xB9, 0x69, 0x67, 0x03\n+        };\n+        const unsigned char sig4[64] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x3B, 0x78, 0xCE, 0x56, 0x3F,\n+            0x89, 0xA0, 0xED, 0x94, 0x14, 0xF5, 0xAA, 0x28,\n+            0xAD, 0x0D, 0x96, 0xD6, 0x79, 0x5F, 0x9C, 0x63,\n+            0x02, 0xA8, 0xDC, 0x32, 0xE6, 0x4E, 0x86, 0xA3,\n+            0x33, 0xF2, 0x0E, 0xF5, 0x6E, 0xAC, 0x9B, 0xA3,\n+            0x0B, 0x72, 0x46, 0xD6, 0xD2, 0x5E, 0x22, 0xAD,\n+            0xB8, 0xC6, 0xBE, 0x1A, 0xEB, 0x08, 0xD4, 0x9D\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk4, msg4, sig4, 1);\n+    }\n+    {\n+        /* Test vector 4B */\n+        const unsigned char pk4B[33] = {\n+            0x03, 0x1B, 0x84, 0xC5, 0x56, 0x7B, 0x12, 0x64,\n+            0x40, 0x99, 0x5D, 0x3E, 0xD5, 0xAA, 0xBA, 0x05,\n+            0x65, 0xD7, 0x1E, 0x18, 0x34, 0x60, 0x48, 0x19,\n+            0xFF, 0x9C, 0x17, 0xF5, 0xE9, 0xD5, 0xDD, 0x07,\n+            0x8F\n+        };\n+        const unsigned char msg4B[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig4B[64] = {\n+            0x52, 0x81, 0x85, 0x79, 0xAC, 0xA5, 0x97, 0x67,\n+            0xE3, 0x29, 0x1D, 0x91, 0xB7, 0x6B, 0x63, 0x7B,\n+            0xEF, 0x06, 0x20, 0x83, 0x28, 0x49, 0x92, 0xF2,\n+            0xD9, 0x5F, 0x56, 0x4C, 0xA6, 0xCB, 0x4E, 0x35,\n+            0x30, 0xB1, 0xDA, 0x84, 0x9C, 0x8E, 0x83, 0x04,\n+            0xAD, 0xC0, 0xCF, 0xE8, 0x70, 0x66, 0x03, 0x34,\n+            0xB3, 0xCF, 0xC1, 0x8E, 0x82, 0x5E, 0xF1, 0xDB,\n+            0x34, 0xCF, 0xAE, 0x3D, 0xFC, 0x5D, 0x81, 0x87\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk4B, msg4B, sig4B, 1);\n+    }\n+    {\n+        /* Test vector 5 */\n+        const unsigned char pk5[33] = {\n+            0x03, 0xEE, 0xFD, 0xEA, 0x4C, 0xDB, 0x67, 0x77,\n+            0x50, 0xA4, 0x20, 0xFE, 0xE8, 0x07, 0xEA, 0xCF,\n+            0x21, 0xEB, 0x98, 0x98, 0xAE, 0x79, 0xB9, 0x76,\n+            0x87, 0x66, 0xE4, 0xFA, 0xA0, 0x4A, 0x2D, 0x4A,\n+            0x34\n+        };\n+        secp256k1_pubkey pk5_parsed;\n+        /* No need to check the signature of the test vector as parsing the pubkey already fails */\n+        CHECK(!secp256k1_ec_pubkey_parse(ctx, &pk5_parsed, pk5, 33));\n+    }\n+    {\n+        /* Test vector 6 */\n+        const unsigned char pk6[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg6[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig6[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFA, 0x16, 0xAE, 0xE0, 0x66, 0x09, 0x28, 0x0A,\n+            0x19, 0xB6, 0x7A, 0x24, 0xE1, 0x97, 0x7E, 0x46,\n+            0x97, 0x71, 0x2B, 0x5F, 0xD2, 0x94, 0x39, 0x14,\n+            0xEC, 0xD5, 0xF7, 0x30, 0x90, 0x1B, 0x4A, 0xB7\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk6, msg6, sig6, 0);\n+    }\n+    {\n+        /* Test vector 7 */\n+        const unsigned char pk7[33] = {\n+            0x03, 0xFA, 0xC2, 0x11, 0x4C, 0x2F, 0xBB, 0x09,\n+            0x15, 0x27, 0xEB, 0x7C, 0x64, 0xEC, 0xB1, 0x1F,\n+            0x80, 0x21, 0xCB, 0x45, 0xE8, 0xE7, 0x80, 0x9D,\n+            0x3C, 0x09, 0x38, 0xE4, 0xB8, 0xC0, 0xE5, 0xF8,\n+            0x4B\n+        };\n+        const unsigned char msg7[32] = {\n+            0x5E, 0x2D, 0x58, 0xD8, 0xB3, 0xBC, 0xDF, 0x1A,\n+            0xBA, 0xDE, 0xC7, 0x82, 0x90, 0x54, 0xF9, 0x0D,\n+            0xDA, 0x98, 0x05, 0xAA, 0xB5, 0x6C, 0x77, 0x33,\n+            0x30, 0x24, 0xB9, 0xD0, 0xA5, 0x08, 0xB7, 0x5C\n+        };\n+        const unsigned char sig7[64] = {\n+            0x00, 0xDA, 0x9B, 0x08, 0x17, 0x2A, 0x9B, 0x6F,\n+            0x04, 0x66, 0xA2, 0xDE, 0xFD, 0x81, 0x7F, 0x2D,\n+            0x7A, 0xB4, 0x37, 0xE0, 0xD2, 0x53, 0xCB, 0x53,\n+            0x95, 0xA9, 0x63, 0x86, 0x6B, 0x35, 0x74, 0xBE,\n+            0xD0, 0x92, 0xF9, 0xD8, 0x60, 0xF1, 0x77, 0x6A,\n+            0x1F, 0x74, 0x12, 0xAD, 0x8A, 0x1E, 0xB5, 0x0D,\n+            0xAC, 0xCC, 0x22, 0x2B, 0xC8, 0xC0, 0xE2, 0x6B,\n+            0x20, 0x56, 0xDF, 0x2F, 0x27, 0x3E, 0xFD, 0xEC\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk7, msg7, sig7, 0);\n+    }\n+    {\n+        /* Test vector 8 */\n+        const unsigned char pk8[33] = {\n+            0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB,\n+            0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,\n+            0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28,\n+            0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17,\n+            0x98\n+        };\n+        const unsigned char msg8[32] = {\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+        };\n+        const unsigned char sig8[64] = {\n+            0x78, 0x7A, 0x84, 0x8E, 0x71, 0x04, 0x3D, 0x28,\n+            0x0C, 0x50, 0x47, 0x0E, 0x8E, 0x15, 0x32, 0xB2,\n+            0xDD, 0x5D, 0x20, 0xEE, 0x91, 0x2A, 0x45, 0xDB,\n+            0xDD, 0x2B, 0xD1, 0xDF, 0xBF, 0x18, 0x7E, 0xF6,\n+            0x8F, 0xCE, 0x56, 0x77, 0xCE, 0x7A, 0x62, 0x3C,\n+            0xB2, 0x00, 0x11, 0x22, 0x57, 0x97, 0xCE, 0x7A,\n+            0x8D, 0xE1, 0xDC, 0x6C, 0xCD, 0x4F, 0x75, 0x4A,\n+            0x47, 0xDA, 0x6C, 0x60, 0x0E, 0x59, 0x54, 0x3C\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk8, msg8, sig8, 0);\n+    }\n+    {\n+        /* Test vector 9 */\n+        const unsigned char pk9[33] = {\n+            0x03, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg9[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig9[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk9, msg9, sig9, 0);\n+    }\n+    {\n+        /* Test vector 10 */\n+        const unsigned char pk10[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg10[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig10[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x8C, 0x34, 0x28, 0x86, 0x9A, 0x66, 0x3E, 0xD1,\n+            0xE9, 0x54, 0x70, 0x5B, 0x02, 0x0C, 0xBB, 0x3E,\n+            0x7B, 0xB6, 0xAC, 0x31, 0x96, 0x5B, 0x9E, 0xA4,\n+            0xC7, 0x3E, 0x22, 0x7B, 0x17, 0xC5, 0xAF, 0x5A\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk10, msg10, sig10, 0);\n+    }\n+    {\n+        /* Test vector 11 */\n+        const unsigned char pk11[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg11[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig11[64] = {\n+            0x4A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk11, msg11, sig11, 0);\n+    }\n+    {\n+        /* Test vector 12 */\n+        const unsigned char pk12[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg12[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig12[64] = {\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x2F,\n+            0x1E, 0x51, 0xA2, 0x2C, 0xCE, 0xC3, 0x55, 0x99,\n+            0xB8, 0xF2, 0x66, 0x91, 0x22, 0x81, 0xF8, 0x36,\n+            0x5F, 0xFC, 0x2D, 0x03, 0x5A, 0x23, 0x04, 0x34,\n+            0xA1, 0xA6, 0x4D, 0xC5, 0x9F, 0x70, 0x13, 0xFD\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk12, msg12, sig12, 0);\n+    }\n+    {\n+        /* Test vector 13 */\n+        const unsigned char pk13[33] = {\n+            0x02, 0xDF, 0xF1, 0xD7, 0x7F, 0x2A, 0x67, 0x1C,\n+            0x5F, 0x36, 0x18, 0x37, 0x26, 0xDB, 0x23, 0x41,\n+            0xBE, 0x58, 0xFE, 0xAE, 0x1D, 0xA2, 0xDE, 0xCE,\n+            0xD8, 0x43, 0x24, 0x0F, 0x7B, 0x50, 0x2B, 0xA6,\n+            0x59\n+        };\n+        const unsigned char msg13[32] = {\n+            0x24, 0x3F, 0x6A, 0x88, 0x85, 0xA3, 0x08, 0xD3,\n+            0x13, 0x19, 0x8A, 0x2E, 0x03, 0x70, 0x73, 0x44,\n+            0xA4, 0x09, 0x38, 0x22, 0x29, 0x9F, 0x31, 0xD0,\n+            0x08, 0x2E, 0xFA, 0x98, 0xEC, 0x4E, 0x6C, 0x89\n+        };\n+        const unsigned char sig13[64] = {\n+            0x2A, 0x29, 0x8D, 0xAC, 0xAE, 0x57, 0x39, 0x5A,\n+            0x15, 0xD0, 0x79, 0x5D, 0xDB, 0xFD, 0x1D, 0xCB,\n+            0x56, 0x4D, 0xA8, 0x2B, 0x0F, 0x26, 0x9B, 0xC7,\n+            0x0A, 0x74, 0xF8, 0x22, 0x04, 0x29, 0xBA, 0x1D,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n+        };\n+        test_schnorrsig_bip_vectors_check_verify(scratch, pk13, msg13, sig13, 0);\n+    }",
      "path": "src/modules/schnorrsig/tests_impl.h",
      "position": 633,
      "original_position": 553,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "27b9d429f4cedcc805ce4a95bc96b5265666087e",
      "in_reply_to_id": 238079378,
      "user": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, I missed the link to the test vectors in the BIP.",
      "created_at": "2018-12-04T13:55:53Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r238670432",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/238670432"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 633,
      "original_line": 633,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/251753183",
      "pull_request_review_id": 197452039,
      "id": 251753183,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTc1MzE4Mw==",
      "diff_hunk": "@@ -961,12 +961,70 @@ void scalar_test(void) {\n \n }\n \n+void scalar_chacha_tests(void) {\n+    unsigned char expected1[64] = {\n+        0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90,\n+        0x40, 0x5d, 0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28,\n+        0xbd, 0xd2, 0x19, 0xb8, 0xa0, 0x8d, 0xed, 0x1a,\n+        0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77, 0x0d, 0xc7,\n+        0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,\n+        0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37,\n+        0x6a, 0x43, 0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c,\n+        0xc3, 0x87, 0xb6, 0x69, 0xb2, 0xee, 0x65, 0x86\n+    };\n+    unsigned char expected2[64] = {\n+        0x45, 0x40, 0xf0, 0x5a, 0x9f, 0x1f, 0xb2, 0x96,\n+        0xd7, 0x73, 0x6e, 0x7b, 0x20, 0x8e, 0x3c, 0x96,\n+        0xeb, 0x4f, 0xe1, 0x83, 0x46, 0x88, 0xd2, 0x60,\n+        0x4f, 0x45, 0x09, 0x52, 0xed, 0x43, 0x2d, 0x41,\n+        0xbb, 0xe2, 0xa0, 0xb6, 0xea, 0x75, 0x66, 0xd2,\n+        0xa5, 0xd1, 0xe7, 0xe2, 0x0d, 0x42, 0xaf, 0x2c,\n+        0x53, 0xd7, 0x92, 0xb1, 0xc4, 0x3f, 0xea, 0x81,\n+        0x7e, 0x9a, 0xd2, 0x75, 0xae, 0x54, 0x69, 0x63\n+    };\n+    unsigned char expected3[64] = {\n+        0x47, 0x4a, 0x4f, 0x35, 0x4f, 0xee, 0x93, 0x59,\n+        0xbb, 0x65, 0x81, 0xe5, 0xd9, 0x15, 0xa6, 0x01,\n+        0xb6, 0x8c, 0x68, 0x03, 0x38, 0xff, 0x65, 0xe6,\n+        0x56, 0x4a, 0x3e, 0x65, 0x59, 0xfc, 0x12, 0x3f,\n+        0xa9, 0xb2, 0xf9, 0x3e, 0x57, 0xc3, 0xa5, 0xcb,\n+        0xe0, 0x72, 0x74, 0x27, 0x88, 0x1c, 0x23, 0xdf,\n+        0xe2, 0xb6, 0xcc, 0xfb, 0x93, 0xed, 0xcb, 0x02,\n+        0xd7, 0x50, 0x52, 0x45, 0x84, 0x88, 0xbb, 0xea\n+    };\n+\n+    secp256k1_scalar exp_r1, exp_r2;\n+    secp256k1_scalar r1, r2;\n+    unsigned char seed1[32] = { 0 };\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed1, 0);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected1[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected1[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    seed1[31] = 1;\n+    secp256k1_scalar_chacha20(&r1, &r2, seed1, 0);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected2[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected2[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed1, 100);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected3[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected3[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));\n+    CHECK(secp256k1_scalar_eq(&exp_r2, &r2));\n+}",
      "path": "src/tests.c",
      "position": null,
      "original_position": 58,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": 230944555,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I added that test (+ other tests from the RFC).",
      "created_at": "2019-01-29T09:33:18Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r251753183",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/251753183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1093,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/251753895",
      "pull_request_review_id": 197452843,
      "id": 251753895,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTc1Mzg5NQ==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = BE32(x0);",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": 230949114,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I switched to `LE`.",
      "created_at": "2019-01-29T09:34:57Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r251753895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/251753895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/251759201",
      "pull_request_review_id": 197459383,
      "id": 251759201,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTc1OTIwMQ==",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 9,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f12dd1a8597e7f9da0176acc4c86371c2c3caa92",
      "in_reply_to_id": 230953311,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> That is unless we expect operations besides sign/verify that operate on signatures, which one is expected to use without intervening serialization step.\r\n\r\nThere are definitely operations besides sign/verify that operate on signatures, for example verifying a sign-to-contract commitment as implemented here https://github.com/bitcoin-core/secp256k1/pull/572/files#diff-b19c5ee427283d4d82bc5beb4e2f4777R202",
      "created_at": "2019-01-29T09:48:54Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r251759201",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/251759201"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/251759737",
      "pull_request_review_id": 197460035,
      "id": 251759737,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTc1OTczNw==",
      "diff_hunk": "@@ -0,0 +1,334 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_eckey_pubkey_serialize(&pk, buf, &buflen, 1);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_sha256_initialize(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk, SECP256K1_EC_COMPRESSED);\n+    secp256k1_sha256_write(&sha, buf, buflen);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Helper function for batch verification.\n+ * One call to the chacha20 returns two random scalars which are returned by this function as r[0]\n+ * and r[1] except for the first randomizer which is set to 1. */\n+static void secp256k1_schnorrsig_batch_randomizer(secp256k1_scalar *r, const unsigned char *seed, uint64_t idx) {\n+    secp256k1_scalar_chacha20(&r[0], &r[1], seed, idx);\n+    if (idx == 0) {\n+        secp256k1_scalar_set_int(&r[0], 1);\n+    }\n+}\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 0) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called on 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_schnorrsig_batch_randomizer(ecmult_context->randomizer_cache, ecmult_context->chacha_seed, idx / 4);\n+    }\n+\n+    /* R */\n+    if (idx % 2 == 0) {\n+        secp256k1_fe rx;\n+        secp256k1_scalar_clear(sc);\n+        secp256k1_scalar_add(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+        if (!secp256k1_fe_set_b32(&rx, &ecmult_context->sig[idx / 2]->data[0])) {\n+            return 0;\n+        }\n+        if (!secp256k1_ge_set_xquad(pt, &rx)) {\n+            return 0;\n+        }\n+    /* eP */\n+    } else {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256 sha;\n+        secp256k1_sha256_initialize(&sha);\n+        secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n+        secp256k1_ec_pubkey_serialize(ecmult_context->ctx, buf, &buflen, ecmult_context->pk[idx / 2], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(&sha, buf, buflen);\n+        secp256k1_sha256_write(&sha, ecmult_context->msg32[idx / 2], 32);\n+        secp256k1_sha256_finalize(&sha, buf);\n+\n+        secp256k1_scalar_set_b32(sc, buf, NULL);\n+        secp256k1_scalar_mul(sc, sc, &ecmult_context->randomizer_cache[(idx / 2) % 2]);\n+\n+        if (!secp256k1_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n+    }\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Hashes signature verification data into the\n+ *  randomization seed and initializes ecmult_context.\n+ *\n+ *  Returns 1 if the randomizer was successfully initialized.\n+ *\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out: ecmult_context: context for batch_ecmult_callback\n+ *  In/Out   sha: an initialized sha256 object which hashes the schnorrsig input in order to get a\n+ *                seed for the randomizer PRNG\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays (must be 0 if they are NULL)\n+ */\n+int secp256k1_schnorrsig_verify_batch_init_randomizer(const secp256k1_context *ctx, secp256k1_schnorrsig_verify_ecmult_context *ecmult_context, secp256k1_sha256 *sha, const secp256k1_schnorrsig *const *sig, const unsigned char *const *msg32, const secp256k1_pubkey *const *pk, size_t n_sigs) {\n+    size_t i;\n+\n+    if (n_sigs > 0) {\n+        ARG_CHECK(sig != NULL);\n+        ARG_CHECK(msg32 != NULL);\n+        ARG_CHECK(pk != NULL);\n+    }\n+\n+    for (i = 0; i < n_sigs; i++) {\n+        unsigned char buf[33];\n+        size_t buflen = sizeof(buf);\n+        secp256k1_sha256_write(sha, sig[i]->data, 64);\n+        secp256k1_sha256_write(sha, msg32[i], 32);\n+        secp256k1_ec_pubkey_serialize(ctx, buf, &buflen, pk[i], SECP256K1_EC_COMPRESSED);\n+        secp256k1_sha256_write(sha, buf, 32);\n+    }\n+    ecmult_context->ctx = ctx;\n+    ecmult_context->sig = sig;\n+    ecmult_context->msg32 = msg32;\n+    ecmult_context->pk = pk;\n+    ecmult_context->n_sigs = n_sigs;\n+\n+    return 1;\n+}\n+\n+/** Helper function for batch verification. Sums the s part of all signatures multiplied by their\n+ *  randomizer.\n+ *\n+ *  Returns 1 if s is successfully summed.",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 276,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ebfd6e90b1f5111b9dea33221f6494928492ea73",
      "in_reply_to_id": 224748197,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Feels like that would be a bit too specific imho.",
      "created_at": "2019-01-29T09:50:10Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r251759737",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/251759737"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/276149024",
      "pull_request_review_id": 227637218,
      "id": 276149024,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjE0OTAyNA==",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 9,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f12dd1a8597e7f9da0176acc4c86371c2c3caa92",
      "in_reply_to_id": 230953311,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We shouldn't speculate on future needs that we're not sure of too much-- if something useful turns up we can change the API.  A guessed API might not be right in any case.",
      "created_at": "2019-04-17T09:14:42Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r276149024",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/276149024"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/281557722",
      "pull_request_review_id": 234420649,
      "id": 281557722,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4MTU1NzcyMg==",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *       nonce_is_negated: a pointer to an integer indicates if signing algorithm negated the\n+ *                nonce (can be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 72,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f532b338b2e4b2d4b0ca9eef2b0337463dd1310c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it should be message, not a message hash (same for verification).\r\nMaybe we should explain that in more detail given that this is different from the ECDSA implementation.",
      "created_at": "2019-05-07T09:55:55Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r281557722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/281557722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287128787",
      "pull_request_review_id": 241443960,
      "id": 287128787,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NzEyODc4Nw==",
      "diff_hunk": "@@ -961,12 +961,122 @@ void scalar_test(void) {\n \n }\n \n+void scalar_chacha_tests(void) {\n+    /* Test vectors 1 to 4 from https://tools.ietf.org/html/rfc8439#appendix-A\n+     * Note that scalar_set_b32 and scalar_get_b32 represent integers\n+     * underlying the scalar in big-endian format. */\n+    unsigned char expected1[64] = {\n+        0xad, 0xe0, 0xb8, 0x76, 0x90, 0x3d, 0xf1, 0xa0,\n+        0xe5, 0x6a, 0x5d, 0x40, 0x28, 0xbd, 0x86, 0x53,\n+        0xb8, 0x19, 0xd2, 0xbd, 0x1a, 0xed, 0x8d, 0xa0,\n+        0xcc, 0xef, 0x36, 0xa8, 0xc7, 0x0d, 0x77, 0x8b,\n+        0x7c, 0x59, 0x41, 0xda, 0x8d, 0x48, 0x57, 0x51,\n+        0x3f, 0xe0, 0x24, 0x77, 0x37, 0x4a, 0xd8, 0xb8,\n+        0xf4, 0xb8, 0x43, 0x6a, 0x1c, 0xa1, 0x18, 0x15,\n+        0x69, 0xb6, 0x87, 0xc3, 0x86, 0x65, 0xee, 0xb2\n+    };\n+    unsigned char expected2[64] = {\n+        0xbe, 0xe7, 0x07, 0x9f, 0x7a, 0x38, 0x51, 0x55,\n+        0x7c, 0x97, 0xba, 0x98, 0x0d, 0x08, 0x2d, 0x73,\n+        0xa0, 0x29, 0x0f, 0xcb, 0x69, 0x65, 0xe3, 0x48,\n+        0x3e, 0x53, 0xc6, 0x12, 0xed, 0x7a, 0xee, 0x32,\n+        0x76, 0x21, 0xb7, 0x29, 0x43, 0x4e, 0xe6, 0x9c,\n+        0xb0, 0x33, 0x71, 0xd5, 0xd5, 0x39, 0xd8, 0x74,\n+        0x28, 0x1f, 0xed, 0x31, 0x45, 0xfb, 0x0a, 0x51,\n+        0x1f, 0x0a, 0xe1, 0xac, 0x6f, 0x4d, 0x79, 0x4b\n+    };\n+    unsigned char seed3[32] = {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01\n+    };\n+    unsigned char expected3[64] = {\n+        0x24, 0x52, 0xeb, 0x3a, 0x92, 0x49, 0xf8, 0xec,\n+        0x8d, 0x82, 0x9d, 0x9b, 0xdd, 0xd4, 0xce, 0xb1,\n+        0xe8, 0x25, 0x20, 0x83, 0x60, 0x81, 0x8b, 0x01,\n+        0xf3, 0x84, 0x22, 0xb8, 0x5a, 0xaa, 0x49, 0xc9,\n+        0xbb, 0x00, 0xca, 0x8e, 0xda, 0x3b, 0xa7, 0xb4,\n+        0xc4, 0xb5, 0x92, 0xd1, 0xfd, 0xf2, 0x73, 0x2f,\n+        0x44, 0x36, 0x27, 0x4e, 0x25, 0x61, 0xb3, 0xc8,\n+        0xeb, 0xdd, 0x4a, 0xa6, 0xa0, 0x13, 0x6c, 0x00\n+    };\n+    unsigned char seed4[32] = {\n+        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+    };\n+    unsigned char expected4[64] = {\n+        0xfb, 0x4d, 0xd5, 0x72, 0x4b, 0xc4, 0x2e, 0xf1,\n+        0xdf, 0x92, 0x26, 0x36, 0x32, 0x7f, 0x13, 0x94,\n+        0xa7, 0x8d, 0xea, 0x8f, 0x5e, 0x26, 0x90, 0x39,\n+        0xa1, 0xbe, 0xbb, 0xc1, 0xca, 0xf0, 0x9a, 0xae,\n+        0xa2, 0x5a, 0xb2, 0x13, 0x48, 0xa6, 0xb4, 0x6c,\n+        0x1b, 0x9d, 0x9b, 0xcb, 0x09, 0x2c, 0x5b, 0xe6,\n+        0x54, 0x6c, 0xa6, 0x24, 0x1b, 0xec, 0x45, 0xd5,\n+        0x87, 0xf4, 0x74, 0x73, 0x96, 0xf0, 0x99, 0x2e\n+    };\n+    unsigned char seed5[32] = {\n+        0x32, 0x56, 0x56, 0xf4, 0x29, 0x02, 0xc2, 0xf8,\n+        0xa3, 0x4b, 0x96, 0xf5, 0xa7, 0xf7, 0xe3, 0x6c,\n+        0x92, 0xad, 0xa5, 0x18, 0x1c, 0xe3, 0x41, 0xae,\n+        0xc3, 0xf3, 0x18, 0xd0, 0xfa, 0x5b, 0x72, 0x53\n+    };\n+    unsigned char expected5[64] = {\n+        0xe7, 0x56, 0xd3, 0x28, 0xe9, 0xc6, 0x19, 0x5c,\n+        0x6f, 0x17, 0x8e, 0x21, 0x8c, 0x1e, 0x72, 0x11,\n+        0xe7, 0xbd, 0x17, 0x0d, 0xac, 0x14, 0xad, 0xe9,\n+        0x3d, 0x9f, 0xb6, 0x92, 0xd6, 0x09, 0x20, 0xfb,\n+        0x43, 0x8e, 0x3b, 0x6d, 0xe3, 0x33, 0xdc, 0xc7,\n+        0x6c, 0x07, 0x6f, 0xbb, 0x1f, 0xb4, 0xc8, 0xb5,\n+        0xe3, 0x6c, 0xe5, 0x12, 0xd9, 0xd7, 0x64, 0x0c,\n+        0xf5, 0xa7, 0x0d, 0xab, 0x79, 0x03, 0xf1, 0x81\n+    };\n+\n+    secp256k1_scalar exp_r1, exp_r2;\n+    secp256k1_scalar r1, r2;\n+    unsigned char seed0[32] = { 0 };\n+\n+    secp256k1_scalar_chacha20(&r1, &r2, seed0, 0);\n+    secp256k1_scalar_set_b32(&exp_r1, &expected1[0], NULL);\n+    secp256k1_scalar_set_b32(&exp_r2, &expected1[32], NULL);\n+    CHECK(secp256k1_scalar_eq(&exp_r1, &r1));",
      "path": "src/tests.c",
      "position": null,
      "original_position": 84,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f532b338b2e4b2d4b0ca9eef2b0337463dd1310c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(here)",
      "created_at": "2019-05-23T20:50:29Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r287128787",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287128787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287565328",
      "pull_request_review_id": 242005379,
      "id": 287565328,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NzU2NTMyOA==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define BE32(p) (p)\n+#else\n+#define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {\n+    size_t n;\n+    size_t over_count = 0;\n+    uint32_t seed32[8];\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    int over1, over2;\n+\n+    memcpy((void *) seed32, (const void *) seed, 32);\n+    do {\n+        x0 = 0x61707865;\n+        x1 = 0x3320646e;\n+        x2 = 0x79622d32;\n+        x3 = 0x6b206574;\n+        x4 = LE32(seed32[0]);\n+        x5 = LE32(seed32[1]);\n+        x6 = LE32(seed32[2]);\n+        x7 = LE32(seed32[3]);\n+        x8 = LE32(seed32[4]);\n+        x9 = LE32(seed32[5]);\n+        x10 = LE32(seed32[6]);\n+        x11 = LE32(seed32[7]);\n+        x12 = idx;\n+        x13 = idx >> 32;\n+        x14 = 0;\n+        x15 = over_count;\n+\n+        n = 10;\n+        while (n--) {\n+            QUARTERROUND(x0, x4, x8,x12)\n+            QUARTERROUND(x1, x5, x9,x13)\n+            QUARTERROUND(x2, x6,x10,x14)\n+            QUARTERROUND(x3, x7,x11,x15)\n+            QUARTERROUND(x0, x5,x10,x15)\n+            QUARTERROUND(x1, x6,x11,x12)\n+            QUARTERROUND(x2, x7, x8,x13)\n+            QUARTERROUND(x3, x4, x9,x14)\n+        }\n+\n+        x0 += 0x61707865;\n+        x1 += 0x3320646e;\n+        x2 += 0x79622d32;\n+        x3 += 0x6b206574;\n+        x4 += LE32(seed32[0]);\n+        x5 += LE32(seed32[1]);\n+        x6 += LE32(seed32[2]);\n+        x7 += LE32(seed32[3]);\n+        x8 += LE32(seed32[4]);\n+        x9 += LE32(seed32[5]);\n+        x10 += LE32(seed32[6]);\n+        x11 += LE32(seed32[7]);\n+        x12 += idx;\n+        x13 += idx >> 32;\n+        x14 += 0;\n+        x15 += over_count;\n+\n+        r1->d[7] = BE32(x0);",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "419d48790d539a0459f63e70f2507fafc9288e87",
      "in_reply_to_id": 230949114,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I *think* this entire discussion is the wrong one. Here we read `uint32_t`s into `uint32_t`s (8x32) or into `uint64_t`s (4x64) (and then of course most natural way is to do this is to copy the integers and not reverse the bytes). Endianness is not relevant here, so the `LE32()` macro is wrong here. I think this is the cause of the failure on s390x, which is 64-bit BE, so the LE32() call  reverses the bytes there.  \r\n\r\n(Maybe I'm on the wrong track. I hate to think about byte order, and probably get it more often wrong than right. :D)",
      "created_at": "2019-05-25T14:50:02Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r287565328",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287565328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287619469",
      "pull_request_review_id": 242061155,
      "id": 287619469,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NzYxOTQ2OQ==",
      "diff_hunk": "@@ -946,4 +949,94 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 6] >> ((shift - 1) & 0x3f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))",
      "path": "src/scalar_4x64_impl.h",
      "position": null,
      "original_position": 14,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f4153a29abab9bf87107846f125c4f6795879cae",
      "in_reply_to_id": null,
      "user": {
        "login": "jb55",
        "id": 45598,
        "node_id": "MDQ6VXNlcjQ1NTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/45598?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jb55",
        "html_url": "https://github.com/jb55",
        "followers_url": "https://api.github.com/users/jb55/followers",
        "following_url": "https://api.github.com/users/jb55/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jb55/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jb55/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jb55/subscriptions",
        "organizations_url": "https://api.github.com/users/jb55/orgs",
        "repos_url": "https://api.github.com/users/jb55/repos",
        "events_url": "https://api.github.com/users/jb55/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jb55/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "the result of this will be invalid if the integer type of x has a storage size larger than 32 bits.\r\n\r\nfor instance `ROTL32((1UL << 31), 1)` will not equal 1. It doesn't look like it's relevant for the current PR as it stands, but this is a common gotcha when using 64 bit literals.\r\n\r\nsuggest: `((uint32_t)(v) << (n)) | ((uint32_t)(v) >> (32 - (n)))`\r\n\r\n",
      "created_at": "2019-05-26T23:52:10Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r287619469",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287619469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 962,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287619861",
      "pull_request_review_id": 242061155,
      "id": 287619861,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NzYxOTg2MQ==",
      "diff_hunk": "@@ -718,4 +720,102 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 13,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f4153a29abab9bf87107846f125c4f6795879cae",
      "in_reply_to_id": null,
      "user": {
        "login": "jb55",
        "id": 45598,
        "node_id": "MDQ6VXNlcjQ1NTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/45598?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jb55",
        "html_url": "https://github.com/jb55",
        "followers_url": "https://api.github.com/users/jb55/followers",
        "following_url": "https://api.github.com/users/jb55/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jb55/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jb55/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jb55/subscriptions",
        "organizations_url": "https://api.github.com/users/jb55/orgs",
        "repos_url": "https://api.github.com/users/jb55/repos",
        "events_url": "https://api.github.com/users/jb55/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jb55/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "same here",
      "created_at": "2019-05-27T00:02:20Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r287619861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287619861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 737,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287881510",
      "pull_request_review_id": 242389124,
      "id": 287881510,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4Nzg4MTUxMA==",
      "diff_hunk": "@@ -946,4 +949,94 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 6] >> ((shift - 1) & 0x3f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))",
      "path": "src/scalar_4x64_impl.h",
      "position": null,
      "original_position": 14,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f4153a29abab9bf87107846f125c4f6795879cae",
      "in_reply_to_id": 287619469,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Integers given to this macro are always 32 bits",
      "created_at": "2019-05-27T21:02:04Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r287881510",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/287881510"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 962,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/289111134",
      "pull_request_review_id": 243950656,
      "id": 289111134,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTExMTEzNA==",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *       nonce_is_negated: a pointer to an integer indicates if signing algorithm negated the\n+ *                nonce (can be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 72,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f532b338b2e4b2d4b0ca9eef2b0337463dd1310c",
      "in_reply_to_id": 281557722,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "this is still open",
      "created_at": "2019-05-30T18:19:57Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r289111134",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/289111134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/289115954",
      "pull_request_review_id": 243956861,
      "id": 289115954,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTExNTk1NA==",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *       nonce_is_negated: a pointer to an integer indicates if signing algorithm negated the\n+ *                nonce (can be NULL)\n+ *  In:    msg32: the 32-byte message hash being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 72,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f532b338b2e4b2d4b0ca9eef2b0337463dd1310c",
      "in_reply_to_id": 281557722,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed mention of hash. It doesn't hurt to use the hash, but not using the hash in ecdsa is broken. So I think this should be stressed in secp256k1.h if it isn't already.",
      "created_at": "2019-05-30T18:31:50Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r289115954",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/289115954"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293615142",
      "pull_request_review_id": 249654149,
      "id": 293615142,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5MzYxNTE0Mg==",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *       nonce_is_negated: a pointer to an integer indicates if signing algorithm negated the\n+ *                nonce (can be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    int *nonce_is_negated,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Using @sipa logic from above\r\n> As the Schnorr signature BIP defines the actual byte representation of signatures, there is no distinction between \"invalid because incorrect values\" and \"invalid because incorrect serialization\"\r\n\r\nShouldn't the deterministic derivation that's described in BIP Schnorr be part of the function itself?\r\n(I guess if you see someone using this directly for Musig or something like that he will want to provide a different source of randomness)\r\n",
      "created_at": "2019-06-13T23:37:28Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r293615142",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293615142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293620091",
      "pull_request_review_id": 249660135,
      "id": 293620091,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5MzYyMDA5MQ==",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *       nonce_is_negated: a pointer to an integer indicates if signing algorithm negated the",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 70,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could you expand on why would a user of the library want to know if the generated nonce was negated or not?",
      "created_at": "2019-06-14T00:03:36Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r293620091",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293620091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293628879",
      "pull_request_review_id": 249670663,
      "id": 293628879,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5MzYyODg3OQ==",
      "diff_hunk": "@@ -718,4 +720,99 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#else\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 26,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A thought about multiple implementations of the same cryptography.\nis this library becoming a general cryptography library?\nshould there be a different general crypto library with sha2/chacha20 etc.?\n\nBecause right now both libsecp and bitcoin implements SHA256 and HMAC, and after this they'll also both implement Chacha20 (https://github.com/bitcoin/bitcoin/blob/master/src/crypto/chacha20.cpp)\n\nAny ideas on the matter? (I myself don't like duplicate implementations especially of sensitive cryptography(and there's also a performance difference too))",
      "created_at": "2019-06-14T01:01:13Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r293628879",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293628879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293630444",
      "pull_request_review_id": 249672635,
      "id": 293630444,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5MzYzMDQ0NA==",
      "diff_hunk": "@@ -718,4 +720,99 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#else\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 26,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": 293628879,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "libsecp256k1 is absolutely not a generic low-level cryptographc primitives library; it's a library implementing high-level cryptographic algorithms efficiently with a safe-to-use interface.\r\n\r\nAs far as duplicate implementations goes, these are included for necessity of exposing fully-functional versions of the high-level functions it implements. I personally don't think code duplication for such low-level primitives is an issue, as this code doesn't \"rot\" (it won't go out of date ever, at worst very rarely needs to be extended, and possibly doesn't need to be touched ever, at all), so it isn't subject to the same priorities most software engineering places.\r\n\r\nThat said, there are some practical reasons why having a built-in implementation may be undesirable:\r\n\r\n* In very low-memory systems which already have versions of SHA256/... somewhere, the additional code size may be undesirable.\r\n* The SHA256/Chacha20 code inside libsecp256k1 isn't very optimized, and probably never will gain high levels of architecture-specific optimization. Generally in these protocols, the performance of these is not very important, but if it is, it'd be great to have libsecp256k1 use more efficient versions.\r\n\r\nBecause of that reason, I think we should see the internal primitives as default, naive, private implementations, and if there is ever a reason to use another one, we should add functionality to make libsecp256k1 use external versions (rather than exposing/improving the internal ones).",
      "created_at": "2019-06-14T01:13:02Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r293630444",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293630444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293631411",
      "pull_request_review_id": 249673797,
      "id": 293631411,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5MzYzMTQxMQ==",
      "diff_hunk": "@@ -718,4 +720,99 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+#define ROTL32(x,n) ((x) << (n) | (x) >> (32-(n)))\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = ROTL32(d ^ a, 16); \\\n+  c += d; b = ROTL32(b ^ c, 12); \\\n+  a += b; d = ROTL32(d ^ a, 8); \\\n+  c += d; b = ROTL32(b ^ c, 7);\n+\n+#ifdef WORDS_BIGENDIAN\n+#define LE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n+#else\n+#define LE32(p) (p)\n+#endif\n+\n+static void secp256k1_scalar_chacha20(secp256k1_scalar *r1, secp256k1_scalar *r2, const unsigned char *seed, uint64_t idx) {",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 26,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": 293628879,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, I didn't consider the first option a real one, just a possibility about how will the library look with more primitives being added.\r\n\r\nI guess your answer is fair, optimized sha256 might already be a nice speedup in a rapid verification scenario(which is already considered in the whole batch verification).\r\n\r\nMaybe making a general low level library that is shared between libsecp and bitcoin is an option? Otherwise your suggestion that if someone really wanted then it's possible to add a feature to support these functions as extern. ",
      "created_at": "2019-06-14T01:19:52Z",
      "updated_at": "2020-09-06T18:59:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r293631411",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/293631411"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294058582",
      "pull_request_review_id": 250205807,
      "id": 294058582,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5NDA1ODU4Mg==",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, int *nonce_is_negated, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (nonce_is_negated != NULL) {\n+        *nonce_is_negated = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 78,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is this constant time?\r\nAs far as I could tell this uses https://github.com/bitcoin-core/secp256k1/blob/master/src/num_gmp_impl.h#L147\r\n\r\nWhich uses GMP.\r\nAm I missing something?",
      "created_at": "2019-06-15T20:24:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r294058582",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294058582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294058927",
      "pull_request_review_id": 250206160,
      "id": 294058927,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5NDA1ODkyNw==",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, int *nonce_is_negated, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (nonce_is_negated != NULL) {\n+        *nonce_is_negated = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 78,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": 294058582,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It isn't (all functions ending with `_var` are variable time).\r\n\r\nThis isn't a problem, as R (including its original Y coordinate) is not secret.",
      "created_at": "2019-06-15T20:37:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r294058927",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294058927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294059425",
      "pull_request_review_id": 250206724,
      "id": 294059425,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5NDA1OTQyNQ==",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, int *nonce_is_negated, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (nonce_is_negated != NULL) {\n+        *nonce_is_negated = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 78,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": 294058582,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, ok. I assumed the whole \"sign\" function is constant time.\r\n`Constant time, constant memory access signing and pubkey generation.`\r\nThanks!",
      "created_at": "2019-06-15T21:01:50Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r294059425",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294059425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294059594",
      "pull_request_review_id": 250206925,
      "id": 294059594,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5NDA1OTU5NA==",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, int *nonce_is_negated, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (nonce_is_negated != NULL) {\n+        *nonce_is_negated = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 78,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": 294058582,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The whole \"constant time\" naming is confusing really, as we can't actually guarantee actual constant time (e.g. the `div` x86 instruction is variable time!).\r\n\r\nReally what we're aiming for is sidechannel resistance, and one of the criteria is that no execution branches are memory access locations are dependent on secret data.",
      "created_at": "2019-06-15T21:09:10Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r294059594",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294059594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294336955",
      "pull_request_review_id": 250545507,
      "id": 294336955,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5NDMzNjk1NQ==",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *       nonce_is_negated: a pointer to an integer indicates if signing algorithm negated the\n+ *                nonce (can be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    int *nonce_is_negated,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": 293615142,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is an optional argument in the same way as in `ecdsa_sign`. In almost all the cases users will provide `NULL`. I don't know a specific case where you would want to provide your own nonce function (outside of testing). ",
      "created_at": "2019-06-17T14:50:09Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r294336955",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294336955"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294345762",
      "pull_request_review_id": 250556772,
      "id": 294345762,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5NDM0NTc2Mg==",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *       nonce_is_negated: a pointer to an integer indicates if signing algorithm negated the",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 70,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": 293620091,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The caller needs to know that if they want to create sign-to-contract commitments because this information is necessary to batch verify these commitments. PR #589 changes this argument to return `nonce_is_negated` as part of the full opening which is better.",
      "created_at": "2019-06-17T15:07:13Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r294345762",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/294345762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/301048354",
      "pull_request_review_id": 258845418,
      "id": 301048354,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwMTA0ODM1NA==",
      "diff_hunk": "@@ -0,0 +1,332 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a228e2f54d64692230ccb2937b12dd746c5157ed",
      "in_reply_to_id": null,
      "user": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Per the documentation for `secp256k1_nonce_function` the algo16 parameter should be written to and non null for schemes besides ECDSA - should the NULL be replaced with an algorithm identifier?",
      "created_at": "2019-07-08T11:36:54Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r301048354",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/301048354"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/317146571",
      "pull_request_review_id": 279018763,
      "id": 317146571,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNzE0NjU3MQ==",
      "diff_hunk": "@@ -0,0 +1,332 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a228e2f54d64692230ccb2937b12dd746c5157ed",
      "in_reply_to_id": 301048354,
      "user": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@jonasnick reason for the request - \r\nhttps://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h#L90 According to here, NULL is passed for ecdsa, others need a 16byte identifier for the signing algorithm. \r\nI maintain language bindings to libsecp256k1, and have an implementation of a secp256k1_nonce_function to allow callers to use their own noncefp. The algo16 is currently the same for ecdsa and schnorr (null) so I can't run this branch in tests: https://github.com/Bit-Wasp/secp256k1-php/blob/ea94d1daba2dcf07a575d294ce2159e73a15d2cc/secp256k1/secp256k1.c#L55\r\n\r\nIf there are any hard coded signature fixtures in tests, they'll likely need tweaking as the bipschnorr noncefp also commits to the algo16: https://github.com/bitcoin-core/secp256k1/pull/558/files#diff-0d77700fa6e05639431c962ffaa5365aR429",
      "created_at": "2019-08-23T14:02:43Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r317146571",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/317146571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/317546314",
      "pull_request_review_id": 279517877,
      "id": 317546314,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNzU0NjMxNA==",
      "diff_hunk": "@@ -0,0 +1,332 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a228e2f54d64692230ccb2937b12dd746c5157ed",
      "in_reply_to_id": 301048354,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks @afk11 , good catch! The simplest fix ist to change nonce_function_bipschnorr to write nothing additional into the hash if algo16 is \"bip-schnorr sign \", 0 if NULL, and 16 bytes of algo16 otherwise.\r\n\r\n@sipa We could easily remove the noncefp parameter from normal schnorrsig signing but then we need to provide another a more specific schnorrsig_sign function that allows providing your nonce function.There are already experimental applications of this where the nonce function returns a static nonce. For example, this is part of the discreet log contracts idea where only one outcome is supposed to be signed and otherwise the secret key leaks.\r\n\r\nPerhaps ideally we should use a tagged hash anyway in bip-schnorr nonce derivation. So in the libsecp bip-schnorr nonce function the tag is either according to bip-schnorr if algo16 is \"bip-schnorr sign \" otherwise it's empty and algo16 is written somewhere into the hash.\r\n\r\nEDIT: opened PR for tagged hash in bip-schnorr (https://github.com/sipa/bips/pull/61)",
      "created_at": "2019-08-26T10:33:05Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r317546314",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/317546314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/321372804",
      "pull_request_review_id": 284401399,
      "id": 321372804,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTM3MjgwNA==",
      "diff_hunk": "@@ -0,0 +1,332 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[33];\n+    size_t buflen = sizeof(buf);\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    if (!noncefp(buf, msg32, seckey, NULL, (void*)ndata, 0)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a228e2f54d64692230ccb2937b12dd746c5157ed",
      "in_reply_to_id": 301048354,
      "user": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@jonasnick sounds like a good solution, thanks!",
      "created_at": "2019-09-05T16:52:08Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r321372804",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/321372804"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/327874467",
      "pull_request_review_id": 292758739,
      "id": 327874467,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyNzg3NDQ2Nw==",
      "diff_hunk": "@@ -785,6 +792,74 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *sign, const secp256k1_pubkey *pubkey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    *xonly_pubkey = *(secp256k1_xonly_pubkey *) pubkey;\n+\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) xonly_pubkey, sign);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_to_pubkey(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_xonly_pubkey *xonly_pubkey, int sign) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+\n+    *pubkey = *(secp256k1_pubkey *) xonly_pubkey;\n+    if (sign) {\n+        return secp256k1_ec_pubkey_negate(ctx, pubkey);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_xonly_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey32, const unsigned char *tweak32) {\n+    secp256k1_ge ge;\n+    secp256k1_pubkey pubkey;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, &pubkey, seckey32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_load(ctx, &ge, &pubkey);\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        if (!secp256k1_ec_privkey_negate(ctx, seckey32)) {\n+            return 0;\n+        }\n+    }\n+\n+    return secp256k1_ec_privkey_tweak_add(ctx, seckey32, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    *output_pubkey = *(secp256k1_pubkey *)internal_pubkey;\n+    return secp256k1_ec_pubkey_tweak_add(ctx, output_pubkey, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_verify(const secp256k1_context* ctx, const secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 101,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "is this function really needed? (i.e. the caller can do exactly the same thing by himself)",
      "created_at": "2019-09-24T23:22:49Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r327874467",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/327874467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 849,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/327874736",
      "pull_request_review_id": 292759068,
      "id": 327874736,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyNzg3NDczNg==",
      "diff_hunk": "@@ -785,6 +792,74 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *sign, const secp256k1_pubkey *pubkey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    *xonly_pubkey = *(secp256k1_xonly_pubkey *) pubkey;\n+\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) xonly_pubkey, sign);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_to_pubkey(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_xonly_pubkey *xonly_pubkey, int sign) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+\n+    *pubkey = *(secp256k1_pubkey *) xonly_pubkey;\n+    if (sign) {\n+        return secp256k1_ec_pubkey_negate(ctx, pubkey);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_xonly_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey32, const unsigned char *tweak32) {\n+    secp256k1_ge ge;\n+    secp256k1_pubkey pubkey;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, &pubkey, seckey32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_load(ctx, &ge, &pubkey);\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        if (!secp256k1_ec_privkey_negate(ctx, seckey32)) {\n+            return 0;\n+        }\n+    }\n+\n+    return secp256k1_ec_privkey_tweak_add(ctx, seckey32, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    *output_pubkey = *(secp256k1_pubkey *)internal_pubkey;\n+    return secp256k1_ec_pubkey_tweak_add(ctx, output_pubkey, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_verify(const secp256k1_context* ctx, const secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 101,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 327874467,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "And I don't remember if there's a promise that two `secp256k1_pubkey` instances can be compared.\r\nremember I had a conversation about that with @sipa on IRC a while ago.",
      "created_at": "2019-09-24T23:23:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r327874736",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/327874736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 849,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/328151415",
      "pull_request_review_id": 293115091,
      "id": 328151415,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyODE1MTQxNQ==",
      "diff_hunk": "@@ -785,6 +792,74 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *sign, const secp256k1_pubkey *pubkey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    *xonly_pubkey = *(secp256k1_xonly_pubkey *) pubkey;\n+\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) xonly_pubkey, sign);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_to_pubkey(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_xonly_pubkey *xonly_pubkey, int sign) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+\n+    *pubkey = *(secp256k1_pubkey *) xonly_pubkey;\n+    if (sign) {\n+        return secp256k1_ec_pubkey_negate(ctx, pubkey);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_xonly_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey32, const unsigned char *tweak32) {\n+    secp256k1_ge ge;\n+    secp256k1_pubkey pubkey;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, &pubkey, seckey32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_load(ctx, &ge, &pubkey);\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        if (!secp256k1_ec_privkey_negate(ctx, seckey32)) {\n+            return 0;\n+        }\n+    }\n+\n+    return secp256k1_ec_privkey_tweak_add(ctx, seckey32, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    *output_pubkey = *(secp256k1_pubkey *)internal_pubkey;\n+    return secp256k1_ec_pubkey_tweak_add(ctx, output_pubkey, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_verify(const secp256k1_context* ctx, const secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 101,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 327874467,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Before the caller can do exactly the same thing they apparently would need to figure out how to compare pubkeys. On the other hand the [taproot branch doesn't use it](https://github.com/sipa/bitcoin/commit/4e71ad676ac0d8276f330882e4d1bb2d2960a710#diff-2c33d0ff0ed53b0902e4af9a745a152fR286) because it doesn't have to parse the serialized output pubkey in the first place and therefore compare the serialized versions.\r\n\r\nComparing via memcmp should be fine as the field elements are normalized when converting from group elements and parsing and it's used in tests all over the codebase. But this is not documented or immediately obvious and therefore not ideal. Perhaps it's time to finally add a group element comparison function.",
      "created_at": "2019-09-25T14:20:31Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r328151415",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/328151415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 849,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/333743984",
      "pull_request_review_id": 300363481,
      "id": 333743984,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzMzc0Mzk4NA==",
      "diff_hunk": "@@ -708,6 +708,74 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 20,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "7eeb3aa49832015a8aa8caf17a008d263f373fc0",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would it make more sense to move this `typedef` up closer to the top of the file with all the other structures that are `typedef`ed?",
      "created_at": "2019-10-10T21:30:04Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r333743984",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/333743984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 711,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 753,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/334173265",
      "pull_request_review_id": 300926221,
      "id": 334173265,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNDE3MzI2NQ==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, (secp256k1_pubkey *) pk)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 131,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "should be `(const secp256k1_pubkey *) pk` to avoid discarding the `const` qualifier.",
      "created_at": "2019-10-11T21:03:15Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r334173265",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/334173265"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/334173357",
      "pull_request_review_id": 300926221,
      "id": 334173357,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNDE3MzM1Nw==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, (secp256k1_pubkey *) pk)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 131,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should be `(const secp256k1_pubkey *) pk` to avoid discarding the `const` qualifier.",
      "created_at": "2019-10-11T21:03:38Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r334173357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/334173357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/334176270",
      "pull_request_review_id": 300930330,
      "id": 334176270,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNDE3NjI3MA==",
      "diff_hunk": "@@ -681,10 +730,144 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+/* Converts the point encoded by a secp256k1_pubkey into its absolute value,\n+ * i.e. keeps it as is if it is positive and otherwise negates it. Sign is set\n+ * to 1 if the input point was negative and set to 0 otherwise. */\n+static void secp256k1_ec_pubkey_absolute(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, int *sign) {\n+   secp256k1_ge ge;\n+    secp256k1_pubkey_load(ctx, &ge, pubkey);\n+    if (sign != NULL) {\n+        *sign = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        secp256k1_ge_neg(&ge, &ge);\n+        if (sign != NULL) {\n+            *sign = 1;\n+        }\n+    }\n+    secp256k1_pubkey_save(pubkey, &ge);\n+}\n+\n+int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *seckey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, (secp256k1_pubkey *) pubkey, seckey)) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n+    /* TODO parse directly from 32 byte buffer */\n+    unsigned char buf[33];\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(input32 != NULL);\n+\n+    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+    memcpy(&buf[1], input32, 32);\n+    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey* pubkey) {\n+    /* TODO serialize directly into 32 byte buffer */\n+    unsigned char buf[33];\n+    size_t outputlen = sizeof(buf);\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(output32 != NULL);\n+\n+    if (!secp256k1_ec_pubkey_serialize(ctx, buf, &outputlen, (secp256k1_pubkey *) pubkey, SECP256K1_EC_COMPRESSED)) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 122,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should be `(const secp256k1_pubkey *) pubkey` to avoid casting away the `const` qualifier.",
      "created_at": "2019-10-11T21:13:40Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r334176270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/334176270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 788,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336249820",
      "pull_request_review_id": 303576278,
      "id": 336249820,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI0OTgyMA==",
      "diff_hunk": "@@ -523,6 +523,13 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 4,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It may be worth pointing out here that it's safe to use this function for ECDSA as well (and perhaps document what tag is used in that case).\r\n\r\nAlternatively, the function could just only support schnorr, and fail in any other context.",
      "created_at": "2019-10-17T22:12:17Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336249820",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336249820"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336250624",
      "pull_request_review_id": 303576278,
      "id": 336250624,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI1MDYyNA==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 20,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We've updated the bip draft to use the term \"square\", maybe do the same here?",
      "created_at": "2019-10-17T22:15:13Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336250624",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336250624"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 713,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336255485",
      "pull_request_review_id": 303576278,
      "id": 336255485,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI1NTQ4NQ==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 21,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This could be misinterpreted as meaning you can cast a pointer from one to another (which is currently true, but not behavior we should commit to).\r\n\r\nIs it really needed to have support for converting xonly_pubkeys to pubkeys? With a few changes (see below), I think it would be easier to describe the behavior simply as  \"`pubkey`s can be converted to `xonly_pubkey`s,  using function `xonly_pubkey_from_pubkey` and will remain consistent with their private keys when doing so.\" I may be overlooking something, though.\r\n",
      "created_at": "2019-10-17T22:33:25Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336255485",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336255485"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 714,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336256844",
      "pull_request_review_id": 303576278,
      "id": 336256844,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI1Njg0NA==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 71,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think we need to describe the correspondence between xonly pubkeys and pubkeys for the same privkey. As far as the schnorr-with-xonly-pubkeys-cryptosystem is concerned, (nearly) every 32-byte array is a valid privkey, and they all have a corresponding pubkey.",
      "created_at": "2019-10-17T22:38:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336256844",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336256844"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 764,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336257250",
      "pull_request_review_id": 303576278,
      "id": 336257250,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI1NzI1MA==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 98,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"sign\" is probably confusing when talking about signatures.\r\n\r\nAlso, is this needed? Ideally the conversion from pubkey to xonly_pubkey was one-way.",
      "created_at": "2019-10-17T22:39:52Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336257250",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336257250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 791,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336258509",
      "pull_request_review_id": 303576278,
      "id": 336258509,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI1ODUwOQ==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a\n+ *                    public key from x-only public key (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *sign,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Convert a secp256k1_xonly_pubkey into a secp256k1_pubkey. If this\n+ *  function is used to invert secp256k1_xonly_pubkey_from_pubkey, the\n+ *  sign bit must be set to the output of that function. If the sign bit\n+ *  is 0 the output pubkey encodes a positive point (has a Y coordinate that is a\n+ *  quadratic residue), otherwise it is negative.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:         pubkey: pointer to a public key object for placing the\n+ *                       converted public key (cannot be NULL)\n+ *  In: xonly_pubkey: pointer to an x-only public key that is converted\n+ *                    (cannot be NULL)\n+ *                 sign: sign bit of the resulting public key (can be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_to_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_xonly_pubkey *xonly_pubkey,\n+    int sign\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a positive point, tweak32 is added to the\n+ *  seckey (modulo the group order). If the public key corresponds to a\n+ *  negative point, tweak32 is added to the negation of the seckey (modulo the\n+ *  group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it. Note that\n+ *  the output is a secp256k1_pubkey and not a secp256k1_xonly_pubkey.\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 172,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this function should input an `xonly_pubkey`, and output an `xonly_pubkey` plus a negation/sign/square/negative/... bit, which is sufficient for verifying it efficiently.\r\n\r\n@real-or-random suggests seeing it as a commitment scheme and having a function that takes as input xonly_pubkey + message (+ tag?), and outputs an xonly_pubkey (the commitment) and a boolean (the opening). And then a verify function that takes the commitment, point, message, opening and returns true or false. The downside would be that the hashing needs to happen inside libsecp256k1, where it's harder to take advantage of efficient hashing functions.\r\n\r\nI think the best approach right now is having tweak_add/tweak_add_verify functions working on xonly_pubkeys/bools, and then seeing if we can e.g. make the caller pass in a SHA256 implementation etc. At that point we could start thinking about having more high-level operations like taproot_commitment/verify and bip32_derive etc instead of the rather low-level \"tweak\" style functions.",
      "created_at": "2019-10-17T22:45:00Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336258509",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336258509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 869,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336262617",
      "pull_request_review_id": 303576278,
      "id": 336262617,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI2MjYxNw==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a\n+ *                    public key from x-only public key (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *sign,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Convert a secp256k1_xonly_pubkey into a secp256k1_pubkey. If this\n+ *  function is used to invert secp256k1_xonly_pubkey_from_pubkey, the\n+ *  sign bit must be set to the output of that function. If the sign bit\n+ *  is 0 the output pubkey encodes a positive point (has a Y coordinate that is a\n+ *  quadratic residue), otherwise it is negative.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:         pubkey: pointer to a public key object for placing the\n+ *                       converted public key (cannot be NULL)\n+ *  In: xonly_pubkey: pointer to an x-only public key that is converted\n+ *                    (cannot be NULL)\n+ *                 sign: sign bit of the resulting public key (can be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_to_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_xonly_pubkey *xonly_pubkey,\n+    int sign\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a positive point, tweak32 is added to the\n+ *  seckey (modulo the group order). If the public key corresponds to a\n+ *  negative point, tweak32 is added to the negation of the seckey (modulo the\n+ *  group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it. Note that\n+ *  the output is a secp256k1_pubkey and not a secp256k1_xonly_pubkey.\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  Returns: 1 if output_pubkey is the result of tweaking the internal_pubkey with\n+ *             tweak32\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In:   output_pubkey: pointer to a public key object (cannot be NULL)\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_verify(",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 193,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm currently using this function in the taproot reference branch (see https://github.com/sipa/bitcoin/commit/9715fa5280404812ab3766de4ee23e1bde5a0fb3#diff-2c33d0ff0ed53b0902e4af9a745a152fR185-R186) which is kind of annoying to roundtrip through `pubkey`. What about instead having it take an input and output `xonly_pubkey` and a boolean?",
      "created_at": "2019-10-17T23:02:18Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336262617",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336262617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 865,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336263594",
      "pull_request_review_id": 303593950,
      "id": 336263594,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI2MzU5NA==",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *       nonce_is_negated: a pointer to an integer indicates if signing algorithm negated the\n+ *                nonce (can be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    int *nonce_is_negated,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a81efa5d01cced6bc9472580f16040a09a0025ff",
      "in_reply_to_id": 293615142,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we should have the ability to pass in an external nonce generation function, as long as the default matches the spec.",
      "created_at": "2019-10-17T23:06:46Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336263594",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336263594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336264111",
      "pull_request_review_id": 303593950,
      "id": 336264111,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI2NDExMQ==",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 87,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What would unparseable mean in this context, as you're passing in an already-parsed signature?",
      "created_at": "2019-10-17T23:08:56Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336264111",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336264111"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336264393",
      "pull_request_review_id": 303593950,
      "id": 336264393,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI2NDM5Mw==",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:      sig: the signature being verified (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const secp256k1_xonly_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies a set of Schnorr signatures.\n+ *\n+ * Returns 1 if all succeeded, 0 otherwise. In particular, returns 1 if n_sigs is 0.\n+ *\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *       scratch: scratch space used for the multiexponentiation\n+ *  In:      sig: array of signatures, or NULL if there are no signatures",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 106,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe clarify that these are pointers to arrays of pointers to signatures (and not pointers to arrays of signatures)? Likewise for the other arguments below.",
      "created_at": "2019-10-17T23:10:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336264393",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336264393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336265385",
      "pull_request_review_id": 303593950,
      "id": 336265385,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI2NTM4NQ==",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:      sig: the signature being verified (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const secp256k1_xonly_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies a set of Schnorr signatures.\n+ *\n+ * Returns 1 if all succeeded, 0 otherwise. In particular, returns 1 if n_sigs is 0.\n+ *\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *       scratch: scratch space used for the multiexponentiation\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of x-only public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays. Must be smaller than\n+ *                2^31 and smaller than half the maximum size_t value. Must be 0",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 110,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe say \"Must be below the minimum of 2^31 and SIZE_MAX/2\"?",
      "created_at": "2019-10-17T23:15:06Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336265385",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336265385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336266339",
      "pull_request_review_id": 303593950,
      "id": 336266339,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI2NjMzOQ==",
      "diff_hunk": "@@ -163,6 +163,20 @@ static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n+/* Initializes a sha256 struct and writes the 64 byte string\n+ * SHA256(tag)||SHA256(tag) into it. The taglen should be less than or equal to",
      "path": "src/hash_impl.h",
      "position": null,
      "original_position": 5,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why should the tag be at most 64 bytes long?",
      "created_at": "2019-10-17T23:19:39Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336266339",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336266339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336268799",
      "pull_request_review_id": 303593950,
      "id": 336268799,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI2ODc5OQ==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 86,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No wiping of sig here?",
      "created_at": "2019-10-17T23:31:48Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336268799",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336268799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336269594",
      "pull_request_review_id": 303593950,
      "id": 336269594,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI2OTU5NA==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 90,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No wiping of sig here?\r\n\r\n(\"this can't happen\" is a good answer)",
      "created_at": "2019-10-17T23:35:39Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336269594",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336269594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336272679",
      "pull_request_review_id": 303593950,
      "id": 336272679,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzNjI3MjY3OQ==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, (secp256k1_pubkey *) pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_xonly_pubkey_serialize(ctx, buf, pk);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. The very first randomizer will be set to 1 and\n+     * the PRNG is called at every odd indexed schnorrsig to fill the cache. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_xonly_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 2) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called with 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_scalar_chacha20(&ecmult_context->randomizer_cache[0], &ecmult_context->randomizer_cache[1], ecmult_context->chacha_seed, idx / 4);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems you're computing the randomization factors twice (once for s, once for R/P). Do you know how much time is spent on that? Perhaps it is worth caching them instead.",
      "created_at": "2019-10-17T23:50:14Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r336272679",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/336272679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338757075",
      "pull_request_review_id": 306818307,
      "id": 338757075,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc1NzA3NQ==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a\n+ *                    public key from x-only public key (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *sign,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Convert a secp256k1_xonly_pubkey into a secp256k1_pubkey. If this\n+ *  function is used to invert secp256k1_xonly_pubkey_from_pubkey, the\n+ *  sign bit must be set to the output of that function. If the sign bit\n+ *  is 0 the output pubkey encodes a positive point (has a Y coordinate that is a\n+ *  quadratic residue), otherwise it is negative.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:         pubkey: pointer to a public key object for placing the\n+ *                       converted public key (cannot be NULL)\n+ *  In: xonly_pubkey: pointer to an x-only public key that is converted\n+ *                    (cannot be NULL)\n+ *                 sign: sign bit of the resulting public key (can be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_to_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_xonly_pubkey *xonly_pubkey,\n+    int sign\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a positive point, tweak32 is added to the\n+ *  seckey (modulo the group order). If the public key corresponds to a\n+ *  negative point, tweak32 is added to the negation of the seckey (modulo the\n+ *  group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it. Note that\n+ *  the output is a secp256k1_pubkey and not a secp256k1_xonly_pubkey.\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 172,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336258509,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm in favor of high level operations which is why my other open pull requests have similar commitment APIs to what real-or-random suggests. For this PR I had a different mindset, because when I brought up high level functions you mentioned \"ec_pubkey_tweak is perfect\" which was a misunderstanding apparently.\r\n\r\nHaving tweak_add/tweak_add_verify functions working on xonly_pubkeys/bools is what I started out with, but then decided against that because 1) the output of tweak_add *is* a secp_pubkey, so returning a pubkey is a better separation of layers, 2) the user otherwise has to deal with two pieces of data of data 3) musig_pubkey_combine takes a tweak as well, and would either have to get an additional out argument with the sign or would work differently than tweak_add and return a pubkey.\r\n\r\nHowever, if we want to add a high level API anyway, I'm happy with changing this again to the more hacky version if it's more straightforward to use in your taproot implementation.",
      "created_at": "2019-10-24T19:41:34Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338757075",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338757075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 869,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338758712",
      "pull_request_review_id": 306820493,
      "id": 338758712,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc1ODcxMg==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 21,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336255485,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> This could be misinterpreted as meaning you can cast a pointer from one to another (which is currently true, but not behavior we should commit to).\r\n\r\nYeah, we do that internally, but shouldn't encourage users to do the same.\r\n\r\n> Is it really needed to have support for converting xonly_pubkeys to pubkeys? With a few changes (see below) [...]\r\n\r\nI think with the few changes it may still make sense to have the conversion. A user may only have an xonly pubkey but wants to use an existing function. But I have no specific use case in mind. We could add this later if necessary.",
      "created_at": "2019-10-24T19:45:37Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338758712",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338758712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 714,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338758891",
      "pull_request_review_id": 306820713,
      "id": 338758891,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc1ODg5MQ==",
      "diff_hunk": "@@ -523,6 +523,13 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 4,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336249820,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's safe indeed to use it with ECDSA, descpite `ecdsa_sign` not providing an `algo16` parameter. But what do you mean by tag?",
      "created_at": "2019-10-24T19:46:03Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338758891",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338758891"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338759181",
      "pull_request_review_id": 306821117,
      "id": 338759181,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc1OTE4MQ==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 71,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336256844,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this was just nice to know. Will remove",
      "created_at": "2019-10-24T19:46:47Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338759181",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338759181"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 764,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338759627",
      "pull_request_review_id": 306821692,
      "id": 338759627,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc1OTYyNw==",
      "diff_hunk": "@@ -785,6 +792,74 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *sign, const secp256k1_pubkey *pubkey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    *xonly_pubkey = *(secp256k1_xonly_pubkey *) pubkey;\n+\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) xonly_pubkey, sign);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_to_pubkey(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_xonly_pubkey *xonly_pubkey, int sign) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+\n+    *pubkey = *(secp256k1_pubkey *) xonly_pubkey;\n+    if (sign) {\n+        return secp256k1_ec_pubkey_negate(ctx, pubkey);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_xonly_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey32, const unsigned char *tweak32) {\n+    secp256k1_ge ge;\n+    secp256k1_pubkey pubkey;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, &pubkey, seckey32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_load(ctx, &ge, &pubkey);\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        if (!secp256k1_ec_privkey_negate(ctx, seckey32)) {\n+            return 0;\n+        }\n+    }\n+\n+    return secp256k1_ec_privkey_tweak_add(ctx, seckey32, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    *output_pubkey = *(secp256k1_pubkey *)internal_pubkey;\n+    return secp256k1_ec_pubkey_tweak_add(ctx, output_pubkey, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_verify(const secp256k1_context* ctx, const secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 101,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 327874467,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@sipa uses it in the taproot implementaion as he mentions below :)",
      "created_at": "2019-10-24T19:47:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338759627",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338759627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 849,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338762445",
      "pull_request_review_id": 306825419,
      "id": 338762445,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc2MjQ0NQ==",
      "diff_hunk": "@@ -523,6 +523,13 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 4,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336249820,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The algo16 parameter isn't observable to users of this function, so it doesn't need to be mentioned.\r\n\r\nFor the current implementation however, I think you need to document:\r\n* When this function is used in schnorr_sign, it produces bip-schnorr compliant signatures.\r\n* When this function is used in ecdsa_sign, it generates a nonce using an analogue of the bip-schnorr nonce generation algorithm, but with tag \"BIPSchnorrNULL\" instead of \"BIPSchnorrDerive\".\r\n\r\nAnd written like that, I think that's a weird choice for the tag, as the fact that ecdsa_sign happens to pass an empty algo16 is an implementation detail that perhaps shouldn't leak into the protocol used - but this is bikeshedding.",
      "created_at": "2019-10-24T19:54:42Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338762445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338762445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338762703",
      "pull_request_review_id": 306825756,
      "id": 338762703,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc2MjcwMw==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 98,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336257250,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If anything should be `is_positive`.",
      "created_at": "2019-10-24T19:55:18Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338762703",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338762703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 791,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338763805",
      "pull_request_review_id": 306827191,
      "id": 338763805,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc2MzgwNQ==",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 87,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336264111,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You should ask that yourself because this was just copied from ecdsa_sign and you're shown as the author of that line ;) Perhaps just incorrect is sufficient.",
      "created_at": "2019-10-24T19:57:52Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338763805",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338763805"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338763879",
      "pull_request_review_id": 306827280,
      "id": 338763879,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc2Mzg3OQ==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a\n+ *                    public key from x-only public key (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *sign,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Convert a secp256k1_xonly_pubkey into a secp256k1_pubkey. If this\n+ *  function is used to invert secp256k1_xonly_pubkey_from_pubkey, the\n+ *  sign bit must be set to the output of that function. If the sign bit\n+ *  is 0 the output pubkey encodes a positive point (has a Y coordinate that is a\n+ *  quadratic residue), otherwise it is negative.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:         pubkey: pointer to a public key object for placing the\n+ *                       converted public key (cannot be NULL)\n+ *  In: xonly_pubkey: pointer to an x-only public key that is converted\n+ *                    (cannot be NULL)\n+ *                 sign: sign bit of the resulting public key (can be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_to_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_xonly_pubkey *xonly_pubkey,\n+    int sign\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a positive point, tweak32 is added to the\n+ *  seckey (modulo the group order). If the public key corresponds to a\n+ *  negative point, tweak32 is added to the negation of the seckey (modulo the\n+ *  group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it. Note that\n+ *  the output is a secp256k1_pubkey and not a secp256k1_xonly_pubkey.\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 172,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336258509,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I see the burden of forcing the user to deal with two pieces of data in some cases, but I think it's justified. The BIPs do not mention any conversion from 32byte-pubkeys to point-pubkeys, only the other way around.",
      "created_at": "2019-10-24T19:58:01Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338763879",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338763879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 869,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338764368",
      "pull_request_review_id": 306827956,
      "id": 338764368,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc2NDM2OA==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a\n+ *                    public key from x-only public key (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *sign,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Convert a secp256k1_xonly_pubkey into a secp256k1_pubkey. If this\n+ *  function is used to invert secp256k1_xonly_pubkey_from_pubkey, the\n+ *  sign bit must be set to the output of that function. If the sign bit\n+ *  is 0 the output pubkey encodes a positive point (has a Y coordinate that is a\n+ *  quadratic residue), otherwise it is negative.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:         pubkey: pointer to a public key object for placing the\n+ *                       converted public key (cannot be NULL)\n+ *  In: xonly_pubkey: pointer to an x-only public key that is converted\n+ *                    (cannot be NULL)\n+ *                 sign: sign bit of the resulting public key (can be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_to_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_xonly_pubkey *xonly_pubkey,\n+    int sign\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a positive point, tweak32 is added to the\n+ *  seckey (modulo the group order). If the public key corresponds to a\n+ *  negative point, tweak32 is added to the negation of the seckey (modulo the\n+ *  group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it. Note that\n+ *  the output is a secp256k1_pubkey and not a secp256k1_xonly_pubkey.\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 172,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336258509,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, I think I changed my mind after seeing the complexity necessary to have both close-to-optimal performance and an intermediate-layer level API.",
      "created_at": "2019-10-24T19:59:12Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338764368",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338764368"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 869,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338765844",
      "pull_request_review_id": 306829850,
      "id": 338765844,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc2NTg0NA==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 98,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336257250,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Even if it's one way you need to know the sign bit for a script spend to provide everything necessary for verification?",
      "created_at": "2019-10-24T20:02:42Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338765844",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338765844"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 791,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338767455",
      "pull_request_review_id": 306832024,
      "id": 338767455,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc2NzQ1NQ==",
      "diff_hunk": "@@ -523,6 +523,13 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 4,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336249820,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, ic what you mean. If you have a better tag in mind let me know (not sure what's wrong with BIPSchnorrNULL).",
      "created_at": "2019-10-24T20:06:52Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338767455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338767455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778123",
      "pull_request_review_id": 306846299,
      "id": 338778123,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODEyMw==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 90,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336269594,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-10-24T20:33:11Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778123",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778123"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778188",
      "pull_request_review_id": 306846375,
      "id": 338778188,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODE4OA==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 90,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336269594,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-10-24T20:33:19Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778188",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778188"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778275",
      "pull_request_review_id": 306846486,
      "id": 338778275,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODI3NQ==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 86,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336268799,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I guess you mean secret key, fixed",
      "created_at": "2019-10-24T20:33:30Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778275",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778275"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778390",
      "pull_request_review_id": 306846648,
      "id": 338778390,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODM5MA==",
      "diff_hunk": "@@ -163,6 +163,20 @@ static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n+/* Initializes a sha256 struct and writes the 64 byte string\n+ * SHA256(tag)||SHA256(tag) into it. The taglen should be less than or equal to",
      "path": "src/hash_impl.h",
      "position": null,
      "original_position": 5,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336266339,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "because brainfart, fixed",
      "created_at": "2019-10-24T20:33:47Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778390",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778390"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778469",
      "pull_request_review_id": 306846748,
      "id": 338778469,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODQ2OQ==",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:      sig: the signature being verified (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const secp256k1_xonly_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies a set of Schnorr signatures.\n+ *\n+ * Returns 1 if all succeeded, 0 otherwise. In particular, returns 1 if n_sigs is 0.\n+ *\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *       scratch: scratch space used for the multiexponentiation\n+ *  In:      sig: array of signatures, or NULL if there are no signatures\n+ *         msg32: array of messages, or NULL if there are no signatures\n+ *            pk: array of x-only public keys, or NULL if there are no signatures\n+ *        n_sigs: number of signatures in above arrays. Must be smaller than\n+ *                2^31 and smaller than half the maximum size_t value. Must be 0",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 110,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336265385,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-10-24T20:33:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778469",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778514",
      "pull_request_review_id": 306846817,
      "id": 338778514,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODUxNA==",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:      sig: the signature being verified (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)\n+ *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorrsig_verify(\n+    const secp256k1_context* ctx,\n+    const secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const secp256k1_xonly_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verifies a set of Schnorr signatures.\n+ *\n+ * Returns 1 if all succeeded, 0 otherwise. In particular, returns 1 if n_sigs is 0.\n+ *\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *       scratch: scratch space used for the multiexponentiation\n+ *  In:      sig: array of signatures, or NULL if there are no signatures",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 106,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336264393,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-10-24T20:34:03Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778607",
      "pull_request_review_id": 306846936,
      "id": 338778607,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODYwNw==",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (x-coordinate only; the y-coordinate is considered to be the unique\n+ * y-coordinate satisfying the curve equation that is a quadratic residue)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect or unparseable signature",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 87,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336264111,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed \"unparseable\"",
      "created_at": "2019-10-24T20:34:15Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778607",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778698",
      "pull_request_review_id": 306847059,
      "id": 338778698,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODY5OA==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 71,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336256844,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed",
      "created_at": "2019-10-24T20:34:28Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778698",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 764,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778756",
      "pull_request_review_id": 306847132,
      "id": 338778756,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3ODc1Ng==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 20,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336250624,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yup",
      "created_at": "2019-10-24T20:34:37Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338778756",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338778756"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 713,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338779041",
      "pull_request_review_id": 306847526,
      "id": 338779041,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc3OTA0MQ==",
      "diff_hunk": "@@ -523,6 +523,13 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 4,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336249820,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added comments",
      "created_at": "2019-10-24T20:35:22Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338779041",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338779041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338780143",
      "pull_request_review_id": 306849000,
      "id": 338780143,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc4MDE0Mw==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 86,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336268799,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh I guess you mean both",
      "created_at": "2019-10-24T20:38:05Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338780143",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338780143"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338782427",
      "pull_request_review_id": 306852059,
      "id": 338782427,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODc4MjQyNw==",
      "diff_hunk": "@@ -708,6 +708,74 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 20,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "7eeb3aa49832015a8aa8caf17a008d263f373fc0",
      "in_reply_to_id": 333743984,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm, seemed to be sensible to me to put this close to the functions related to xonly keys. The rest of the file is irrelevant to xonly. Other than being close to the other typedefs there doesn't seem to be a reason to do it with the clear downside of having to jump more when reading the xonly parts. But *shrugs*",
      "created_at": "2019-10-24T20:43:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338782427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338782427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 711,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 753,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338805409",
      "pull_request_review_id": 306882147,
      "id": 338805409,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODgwNTQwOQ==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, (secp256k1_pubkey *) pk)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 131,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 334173265,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-10-24T21:43:00Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338805409",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338805409"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338805437",
      "pull_request_review_id": 306882194,
      "id": 338805437,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODgwNTQzNw==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, (secp256k1_pubkey *) pk)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 131,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 334173357,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-10-24T21:43:07Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338805437",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338805437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338805484",
      "pull_request_review_id": 306882253,
      "id": 338805484,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzODgwNTQ4NA==",
      "diff_hunk": "@@ -681,10 +730,144 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+/* Converts the point encoded by a secp256k1_pubkey into its absolute value,\n+ * i.e. keeps it as is if it is positive and otherwise negates it. Sign is set\n+ * to 1 if the input point was negative and set to 0 otherwise. */\n+static void secp256k1_ec_pubkey_absolute(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, int *sign) {\n+   secp256k1_ge ge;\n+    secp256k1_pubkey_load(ctx, &ge, pubkey);\n+    if (sign != NULL) {\n+        *sign = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        secp256k1_ge_neg(&ge, &ge);\n+        if (sign != NULL) {\n+            *sign = 1;\n+        }\n+    }\n+    secp256k1_pubkey_save(pubkey, &ge);\n+}\n+\n+int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *seckey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, (secp256k1_pubkey *) pubkey, seckey)) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n+    /* TODO parse directly from 32 byte buffer */\n+    unsigned char buf[33];\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(input32 != NULL);\n+\n+    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+    memcpy(&buf[1], input32, 32);\n+    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey* pubkey) {\n+    /* TODO serialize directly into 32 byte buffer */\n+    unsigned char buf[33];\n+    size_t outputlen = sizeof(buf);\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(output32 != NULL);\n+\n+    if (!secp256k1_ec_pubkey_serialize(ctx, buf, &outputlen, (secp256k1_pubkey *) pubkey, SECP256K1_EC_COMPRESSED)) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 122,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 334176270,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-10-24T21:43:16Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r338805484",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/338805484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 788,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/339872067",
      "pull_request_review_id": 308247685,
      "id": 339872067,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzOTg3MjA2Nw==",
      "diff_hunk": "@@ -681,10 +730,144 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+/* Converts the point encoded by a secp256k1_pubkey into its absolute value,\n+ * i.e. keeps it as is if it is positive and otherwise negates it. Sign is set\n+ * to 1 if the input point was negative and set to 0 otherwise. */\n+static void secp256k1_ec_pubkey_absolute(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, int *sign) {\n+   secp256k1_ge ge;\n+    secp256k1_pubkey_load(ctx, &ge, pubkey);\n+    if (sign != NULL) {\n+        *sign = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        secp256k1_ge_neg(&ge, &ge);\n+        if (sign != NULL) {\n+            *sign = 1;\n+        }\n+    }\n+    secp256k1_pubkey_save(pubkey, &ge);\n+}\n+\n+int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *seckey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, (secp256k1_pubkey *) pubkey, seckey)) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n+    /* TODO parse directly from 32 byte buffer */\n+    unsigned char buf[33];\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(input32 != NULL);\n+\n+    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+    memcpy(&buf[1], input32, 32);\n+    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {\n+        return 0;",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 108,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "e28b61c290f4549dfeb94b421310ff68b661fea0",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As it stands, if `secp256k1_xonly_pubkey_parse` fails, it will leave the `pubkey` value in a invalid state.  If the user of the this API were to ignore the return value of `secp256k1_xonly_pubkey_parse` and proceeded to call `secp256k1_schnorrsig_verify`, the verification could, perhaps, succeed.\r\n\r\nHowever if we were to add a line such as `memset(pubkey, 0, sizeof(secp256k1_xonly_pubkey);` here, then `pubkey` would be initialized to a value that denotes a point with a zero x-coordinate.  The current implementation of `secp256k1_schnorrsig_verify` calls `secp256k1_pubkey_load` which explicitly fails when passed a pubkey point with a zero x-coordinate, which in turn would cause `secp256k1_schnorrsig_verify` to unconditionally fail, even if the result of `secp256k1_xonly_pubkey_parse` were ignored.  (Not only does `secp256k1_pubkey_load` unconditionally fail, but it also calls `ctx->illegal_callback`).",
      "created_at": "2019-10-29T02:37:02Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r339872067",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/339872067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 823,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/339936202",
      "pull_request_review_id": 308329660,
      "id": 339936202,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzOTkzNjIwMg==",
      "diff_hunk": "@@ -681,10 +730,144 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+/* Converts the point encoded by a secp256k1_pubkey into its absolute value,\n+ * i.e. keeps it as is if it is positive and otherwise negates it. Sign is set\n+ * to 1 if the input point was negative and set to 0 otherwise. */\n+static void secp256k1_ec_pubkey_absolute(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, int *sign) {\n+   secp256k1_ge ge;\n+    secp256k1_pubkey_load(ctx, &ge, pubkey);\n+    if (sign != NULL) {\n+        *sign = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        secp256k1_ge_neg(&ge, &ge);\n+        if (sign != NULL) {\n+            *sign = 1;\n+        }\n+    }\n+    secp256k1_pubkey_save(pubkey, &ge);\n+}\n+\n+int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *seckey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, (secp256k1_pubkey *) pubkey, seckey)) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n+    /* TODO parse directly from 32 byte buffer */\n+    unsigned char buf[33];\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(input32 != NULL);\n+\n+    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+    memcpy(&buf[1], input32, 32);\n+    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {\n+        return 0;",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 108,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "e28b61c290f4549dfeb94b421310ff68b661fea0",
      "in_reply_to_id": 339872067,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is a valid concern. But `secp256k1_ec_pubkey_parse` does that already:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/e541a90ef6461007d9c6a74b9f9a7fb8aa34aaa8/src/secp256k1.c#L256",
      "created_at": "2019-10-29T08:14:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r339936202",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/339936202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 823,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/339944676",
      "pull_request_review_id": 308340640,
      "id": 339944676,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMzOTk0NDY3Ng==",
      "diff_hunk": "@@ -681,10 +730,144 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+/* Converts the point encoded by a secp256k1_pubkey into its absolute value,\n+ * i.e. keeps it as is if it is positive and otherwise negates it. Sign is set\n+ * to 1 if the input point was negative and set to 0 otherwise. */\n+static void secp256k1_ec_pubkey_absolute(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, int *sign) {\n+   secp256k1_ge ge;\n+    secp256k1_pubkey_load(ctx, &ge, pubkey);\n+    if (sign != NULL) {\n+        *sign = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        secp256k1_ge_neg(&ge, &ge);\n+        if (sign != NULL) {\n+            *sign = 1;\n+        }\n+    }\n+    secp256k1_pubkey_save(pubkey, &ge);\n+}\n+\n+int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *seckey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, (secp256k1_pubkey *) pubkey, seckey)) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n+    /* TODO parse directly from 32 byte buffer */\n+    unsigned char buf[33];\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(input32 != NULL);\n+\n+    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+    memcpy(&buf[1], input32, 32);\n+    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {\n+        return 0;",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 108,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "e28b61c290f4549dfeb94b421310ff68b661fea0",
      "in_reply_to_id": 339872067,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I added a commit with an explicit test that the pubkey is zeroized.",
      "created_at": "2019-10-29T08:36:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r339944676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/339944676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 823,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/340050667",
      "pull_request_review_id": 308477430,
      "id": 340050667,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MDA1MDY2Nw==",
      "diff_hunk": "@@ -701,6 +708,188 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a positive point. That is a point whose Y\n+ *  coordinate is a quadratic residue. It is serialized using only its X\n+ *  coordinate (32 bytes). A secp256k1_xonly_pubkey is also a secp256k1_pubkey\n+ *  but the inverse is not true. Therefore, a secp256k1_pubkey must never be\n+ *  interpreted as or copied into a secp256k1_xonly_pubkey.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a xonly pubkey object into a byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Just as ec_pubkey_create this\n+ *  function computes the point P by multiplying the seckey (interpreted as a scalar)\n+ *  with the generator. The public key corresponds to P if the Y coordinate of P is a\n+ *  quadratic residue or -P otherwise.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey. This\n+ *  function optionally outputs a sign bit that can be used to convert\n+ *  the secp256k1_xonly_pubkey back into the same secp256k1_pubkey.\n+ *  The sign bit is 0 if the input pubkey encodes a positive point (has a Y\n+ *  coordinate that is a quadratic residue), otherwise it is 1.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *              sign: sign bit of the pubkey. Can be used to reconstruct a\n+ *                    public key from x-only public key (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *sign,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Convert a secp256k1_xonly_pubkey into a secp256k1_pubkey. If this\n+ *  function is used to invert secp256k1_xonly_pubkey_from_pubkey, the\n+ *  sign bit must be set to the output of that function. If the sign bit\n+ *  is 0 the output pubkey encodes a positive point (has a Y coordinate that is a\n+ *  quadratic residue), otherwise it is negative.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object\n+ *  Out:         pubkey: pointer to a public key object for placing the\n+ *                       converted public key (cannot be NULL)\n+ *  In: xonly_pubkey: pointer to an x-only public key that is converted\n+ *                    (cannot be NULL)\n+ *                 sign: sign bit of the resulting public key (can be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_to_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_xonly_pubkey *xonly_pubkey,\n+    int sign\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a positive point, tweak32 is added to the\n+ *  seckey (modulo the group order). If the public key corresponds to a\n+ *  negative point, tweak32 is added to the negation of the seckey (modulo the\n+ *  group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it. Note that\n+ *  the output is a secp256k1_pubkey and not a secp256k1_xonly_pubkey.\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 172,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336258509,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just to clarify, what are the opinions you changed your mind from and to?",
      "created_at": "2019-10-29T12:43:25Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r340050667",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/340050667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 869,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/340057958",
      "pull_request_review_id": 308487126,
      "id": 340057958,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MDA1Nzk1OA==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, (secp256k1_pubkey *) pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_xonly_pubkey_serialize(ctx, buf, pk);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. The very first randomizer will be set to 1 and\n+     * the PRNG is called at every odd indexed schnorrsig to fill the cache. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_xonly_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 2) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called with 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_scalar_chacha20(&ecmult_context->randomizer_cache[0], &ecmult_context->randomizer_cache[1], ecmult_context->chacha_seed, idx / 4);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336272679,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "about 0.42% of time spent in `secp256k1_schnorrsig_verify_batch` is spent in `chacha` during the schnorrsig batch benchmarks.",
      "created_at": "2019-10-29T12:59:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r340057958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/340057958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/340148841",
      "pull_request_review_id": 308606248,
      "id": 340148841,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MDE0ODg0MQ==",
      "diff_hunk": "@@ -681,10 +730,144 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+/* Converts the point encoded by a secp256k1_pubkey into its absolute value,\n+ * i.e. keeps it as is if it is positive and otherwise negates it. Sign is set\n+ * to 1 if the input point was negative and set to 0 otherwise. */\n+static void secp256k1_ec_pubkey_absolute(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, int *sign) {\n+   secp256k1_ge ge;\n+    secp256k1_pubkey_load(ctx, &ge, pubkey);\n+    if (sign != NULL) {\n+        *sign = 0;\n+    }\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        secp256k1_ge_neg(&ge, &ge);\n+        if (sign != NULL) {\n+            *sign = 1;\n+        }\n+    }\n+    secp256k1_pubkey_save(pubkey, &ge);\n+}\n+\n+int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *seckey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, (secp256k1_pubkey *) pubkey, seckey)) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n+    /* TODO parse directly from 32 byte buffer */\n+    unsigned char buf[33];\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(input32 != NULL);\n+\n+    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+    memcpy(&buf[1], input32, 32);\n+    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {\n+        return 0;",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 108,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "e28b61c290f4549dfeb94b421310ff68b661fea0",
      "in_reply_to_id": 339872067,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@real-or-random Thanks.  I missed the indirection in `secp256k1_ec_pubkey_parse` between `Q` and `pubkey`.",
      "created_at": "2019-10-29T15:27:59Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r340148841",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/340148841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 823,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/341790609",
      "pull_request_review_id": 310745688,
      "id": 341790609,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTc5MDYwOQ==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, (secp256k1_pubkey *) pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_xonly_pubkey_serialize(ctx, buf, pk);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. The very first randomizer will be set to 1 and\n+     * the PRNG is called at every odd indexed schnorrsig to fill the cache. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_xonly_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 2) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called with 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_scalar_chacha20(&ecmult_context->randomizer_cache[0], &ecmult_context->randomizer_cache[1], ecmult_context->chacha_seed, idx / 4);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336272679,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": " I think that's fine for this PR. Thoughts? ",
      "created_at": "2019-11-02T00:40:42Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r341790609",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/341790609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/341790783",
      "pull_request_review_id": 310745925,
      "id": 341790783,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0MTc5MDc4Mw==",
      "diff_hunk": "@@ -0,0 +1,357 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key is not\n+     * positive. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    if (!noncefp(buf, msg32, seckey, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        return 0;\n+    }\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+/* Helper function for verification and batch verification.\n+ * Computes R = sG - eP. */\n+static int secp256k1_schnorrsig_real_verify(const secp256k1_context* ctx, secp256k1_gej *rj, const secp256k1_scalar *s, const secp256k1_scalar *e, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar nege;\n+    secp256k1_ge pkp;\n+    secp256k1_gej pkj;\n+\n+    secp256k1_scalar_negate(&nege, e);\n+\n+    if (!secp256k1_pubkey_load(ctx, &pkp, (secp256k1_pubkey *) pk)) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&pkj, &pkp);\n+\n+    /* rj =  s*G + (-e)*pkj */\n+    secp256k1_ecmult(&ctx->ecmult_ctx, rj, &pkj, &nege, s);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pk) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pk != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_xonly_pubkey_serialize(ctx, buf, pk);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    if (!secp256k1_schnorrsig_real_verify(ctx, &rj, &s, &e, pk)\n+        || !secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\n+        || !secp256k1_gej_eq_x_var(&rx, &rj)) {\n+        return 0;\n+    }\n+\n+    return 1;\n+}\n+\n+/* Data that is used by the batch verification ecmult callback */\n+typedef struct {\n+    const secp256k1_context *ctx;\n+    /* Seed for the random number generator */\n+    unsigned char chacha_seed[32];\n+    /* Caches randomizers generated by the PRNG which returns two randomizers per call. Caching\n+     * avoids having to call the PRNG twice as often. The very first randomizer will be set to 1 and\n+     * the PRNG is called at every odd indexed schnorrsig to fill the cache. */\n+    secp256k1_scalar randomizer_cache[2];\n+    /* Signature, message, public key tuples to verify */\n+    const secp256k1_schnorrsig *const *sig;\n+    const unsigned char *const *msg32;\n+    const secp256k1_xonly_pubkey *const *pk;\n+    size_t n_sigs;\n+} secp256k1_schnorrsig_verify_ecmult_context;\n+\n+/* Callback function which is called by ecmult_multi in order to convert the ecmult_context\n+ * consisting of signature, message and public key tuples into scalars and points. */\n+static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n+    secp256k1_schnorrsig_verify_ecmult_context *ecmult_context = (secp256k1_schnorrsig_verify_ecmult_context *) data;\n+\n+    if (idx % 4 == 2) {\n+        /* Every idx corresponds to a (scalar,point)-tuple. So this callback is called with 4\n+         * consecutive tuples before we need to call the RNG for new randomizers:\n+         * (-randomizer_cache[0], R1)\n+         * (-randomizer_cache[0]*e1, P1)\n+         * (-randomizer_cache[1], R2)\n+         * (-randomizer_cache[1]*e2, P2) */\n+        secp256k1_scalar_chacha20(&ecmult_context->randomizer_cache[0], &ecmult_context->randomizer_cache[1], ecmult_context->chacha_seed, idx / 4);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 336272679,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, I think that's fine.",
      "created_at": "2019-11-02T00:43:28Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r341790783",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/341790783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347126158",
      "pull_request_review_id": 318009650,
      "id": 347126158,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzEyNjE1OA==",
      "diff_hunk": "@@ -701,6 +717,164 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence. Use the\n+ *  SECP256K1_LEN_XONLY_PUBKEY macro if your want to avoid the magic number 32.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *      has_square_y: pointer to an integer that will be set to 1 if the pubkey\n+ *                    encodes a point with a square Y coordinate, and set to 0\n+ *                    otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *has_square_y,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to\n+ *  the seckey (modulo the group order). Otherwise, tweak32 is added to the\n+ *  negation of the seckey (modulo the group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *         has_square_y: pointer to an integer that will be set to 1 if the\n+ *                       output_pubkey has a square Y coordinate, and set to 0\n+ *                       otherwise (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *output_pubkey,\n+    int *has_square_y,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Verifies that output_pubkey and has_square_y is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  Returns: 1 if output_pubkey is the result of tweaking the internal_pubkey with\n+ *             tweak32\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In:   output_pubkey: pointer to a public key object (cannot be NULL)\n+ *         has_square_y: 1 if output_pubkey has a square Y coordinate and 0 otherwise.\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_verify(",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 184,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't know about this name, people might think it's actually verifying some commitment which *it is not*.\r\nthe commitment is a valid one iff it is `P + H(P||C)G`. otherwise it's a regular tweak add which there's nothing to \"verify\" about.\r\n\r\nright now that it's only doing `memcmp` maybe it's kinda useless and should be done in core? (I'd agree that if you use gej<->gej comparison than maybe the speed benefit is worth it but that's not what happening here)\r\n\r\nThough I see that I might be overthinking this.",
      "created_at": "2019-11-17T09:28:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347126158",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347126158"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 870,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347126894",
      "pull_request_review_id": 318009650,
      "id": 347126894,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzEyNjg5NA==",
      "diff_hunk": "@@ -0,0 +1,366 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 45,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Tested locally with the following logic:\r\n```\r\nlet mut hash = Sha256::new();\r\nhash.input(b\"BIPSchnorr\");\r\nlet schnorr = hash.finalize();\r\nlet mut hash = Sha256::new();\r\nhash.input(&schnorr);\r\nhash.input(&schnorr);\r\nhash.process_current_block();\r\nfor i in &hash.hash {\r\n    println!(\"0x{:08x}\", i);\r\n}\r\n```\r\n\r\nACK on the resulting midstate\r\n```\r\n0x048d9a59\r\n0xfe39fb05\r\n0x28479648\r\n0xe4a660f9\r\n0x814b9e66\r\n0x0469e801\r\n0x83909280\r\n0xb329e454\r\n```",
      "created_at": "2019-11-17T09:46:15Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347126894",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347126894"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 34,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347127650",
      "pull_request_review_id": 318009650,
      "id": 347127650,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzEyNzY1MA==",
      "diff_hunk": "@@ -0,0 +1,366 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    if (!noncefp(buf, msg32, seckey_tmp, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        memset(sig, 0, sizeof(*sig));\n+        memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+    memset(seckey_tmp, 0, sizeof(seckey_tmp));",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 93,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "would be nicer if this was at the end, together with the rest of the memory cleaning calls",
      "created_at": "2019-11-17T10:05:03Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347127650",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347127650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347127884",
      "pull_request_review_id": 318009650,
      "id": 347127884,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzEyNzg4NA==",
      "diff_hunk": "@@ -0,0 +1,366 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    if (!noncefp(buf, msg32, seckey_tmp, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {\n+        memset(sig, 0, sizeof(*sig));\n+        memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+    memset(seckey_tmp, 0, sizeof(seckey_tmp));",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 93,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "in_reply_to_id": 347127650,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oh I see that if you move it you'll need to also duplicate this into `if (secp256k1_scalar_is_zero(&k)) {`",
      "created_at": "2019-11-17T10:10:14Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347127884",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347127884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347129404",
      "pull_request_review_id": 318009650,
      "id": 347129404,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzEyOTQwNA==",
      "diff_hunk": "@@ -681,10 +730,131 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+/* Converts the point encoded by a secp256k1_pubkey into its \"absolute\" value.\n+ * That means it is kept as is if it has a square Y and otherwise negated.\n+ * has_square_y is set to 1 in the former case and to 0 in the latter case. */\n+static void secp256k1_ec_pubkey_absolute(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, int *has_square_y) {\n+    secp256k1_ge ge;\n+    secp256k1_pubkey_load(ctx, &ge, pubkey);\n+    secp256k1_ge_absolute(&ge, has_square_y);\n+    secp256k1_pubkey_save(pubkey, &ge);\n+}\n+\n+int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *seckey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, (secp256k1_pubkey *) pubkey, seckey)) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n+    /* TODO parse directly from 32 byte buffer */\n+    unsigned char buf[33];\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(input32 != NULL);\n+\n+    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+    memcpy(&buf[1], input32, 32);\n+    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 99,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Isn't it better to use `secp256k1_ge_set_xquad` directly?\r\nthat way there's no need to use `secp256k1_ec_pubkey_absolute` because it is already a square root. (right now there's a bunch of redundant negations and conversations if the quad residue isn't even)\r\n\r\nand you could use the 32 byte buffer directly as your TODO says :)",
      "created_at": "2019-11-17T10:44:40Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347129404",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347129404"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 765,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347573323",
      "pull_request_review_id": 318582410,
      "id": 347573323,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzU3MzMyMw==",
      "diff_hunk": "@@ -701,6 +717,164 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence. Use the\n+ *  SECP256K1_LEN_XONLY_PUBKEY macro if your want to avoid the magic number 32.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the\n+ *                 serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *      has_square_y: pointer to an integer that will be set to 1 if the pubkey\n+ *                    encodes a point with a square Y coordinate, and set to 0\n+ *                    otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *has_square_y,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to\n+ *  the seckey (modulo the group order). Otherwise, tweak32 is added to the\n+ *  negation of the seckey (modulo the group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *         has_square_y: pointer to an integer that will be set to 1 if the\n+ *                       output_pubkey has a square Y coordinate, and set to 0\n+ *                       otherwise (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *output_pubkey,\n+    int *has_square_y,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Verifies that output_pubkey and has_square_y is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  Returns: 1 if output_pubkey is the result of tweaking the internal_pubkey with\n+ *             tweak32\n+ *           0 otherwise\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In:   output_pubkey: pointer to a public key object (cannot be NULL)\n+ *         has_square_y: 1 if output_pubkey has a square Y coordinate and 0 otherwise.\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_verify(",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 184,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "in_reply_to_id": 347126158,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> right now that it's only doing memcmp maybe it's kinda useless and should be done in core?\r\n\r\nAlso comparing `has_square_y`. I think we should keep that function, but you're right about the naming. I renamed it from `verify` to `test` and added a note in the doc.\r\n\r\nI think we should definitely make use of avoiding the conversion to affine but not in this PR because there doesn't seem to be a very concise way to do this.",
      "created_at": "2019-11-18T19:42:23Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347573323",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347573323"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 870,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347573653",
      "pull_request_review_id": 318582860,
      "id": 347573653,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzU3MzY1Mw==",
      "diff_hunk": "@@ -0,0 +1,366 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 45,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "in_reply_to_id": 347126894,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks. Also, otherwise the test vectors would fail.",
      "created_at": "2019-11-18T19:43:06Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347573653",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347573653"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 34,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347574395",
      "pull_request_review_id": 318583820,
      "id": 347574395,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzU3NDM5NQ==",
      "diff_hunk": "@@ -681,10 +730,131 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     return 1;\n }\n \n+/* Converts the point encoded by a secp256k1_pubkey into its \"absolute\" value.\n+ * That means it is kept as is if it has a square Y and otherwise negated.\n+ * has_square_y is set to 1 in the former case and to 0 in the latter case. */\n+static void secp256k1_ec_pubkey_absolute(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, int *has_square_y) {\n+    secp256k1_ge ge;\n+    secp256k1_pubkey_load(ctx, &ge, pubkey);\n+    secp256k1_ge_absolute(&ge, has_square_y);\n+    secp256k1_pubkey_save(pubkey, &ge);\n+}\n+\n+int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *seckey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, (secp256k1_pubkey *) pubkey, seckey)) {\n+        return 0;\n+    }\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n+    /* TODO parse directly from 32 byte buffer */\n+    unsigned char buf[33];\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(input32 != NULL);\n+\n+    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n+    memcpy(&buf[1], input32, 32);\n+    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 99,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "19c144cccac293a1814cef36db198b176d237072",
      "in_reply_to_id": 347129404,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You're right. I wrote that code when the tie breaker was still evenness and forgot that that's the reason why it uses the normal parse function. I fixed this. Much cleaner now.",
      "created_at": "2019-11-18T19:44:47Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347574395",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347574395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 765,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347614465",
      "pull_request_review_id": 318636289,
      "id": 347614465,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzYxNDQ2NQ==",
      "diff_hunk": "@@ -754,33 +754,38 @@ int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_\n }\n \n int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n-    /* TODO parse directly from 32 byte buffer */\n-    unsigned char buf[33];\n+    secp256k1_ge Q;\n+    secp256k1_fe x;\n+\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n     ARG_CHECK(input32 != NULL);\n \n-    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n-    memcpy(&buf[1], input32, 32);\n-    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n         return 0;\n     }\n-    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    if (!secp256k1_ge_set_xquad(&Q, &x)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, &Q);\n+    secp256k1_ge_clear(&Q);",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 25,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, I don't think there's a need to clear it. (isn't worth another force push though so unless you're changing more stuff then it doesn't matter)",
      "created_at": "2019-11-18T21:18:50Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347614465",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347614465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 829,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347616160",
      "pull_request_review_id": 318638552,
      "id": 347616160,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzYxNjE2MA==",
      "diff_hunk": "@@ -754,33 +754,38 @@ int secp256k1_xonly_pubkey_create(const secp256k1_context* ctx, secp256k1_xonly_\n }\n \n int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey* pubkey, const unsigned char *input32) {\n-    /* TODO parse directly from 32 byte buffer */\n-    unsigned char buf[33];\n+    secp256k1_ge Q;\n+    secp256k1_fe x;\n+\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n     ARG_CHECK(input32 != NULL);\n \n-    buf[0] = SECP256K1_TAG_PUBKEY_EVEN;\n-    memcpy(&buf[1], input32, 32);\n-    if (!secp256k1_ec_pubkey_parse(ctx, (secp256k1_pubkey *) pubkey, buf, sizeof(buf))) {\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n         return 0;\n     }\n-    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) pubkey, NULL);\n+    if (!secp256k1_ge_set_xquad(&Q, &x)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, &Q);\n+    secp256k1_ge_clear(&Q);\n     return 1;\n }\n \n int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey* pubkey) {\n-    /* TODO serialize directly into 32 byte buffer */\n-    unsigned char buf[33];\n-    size_t outputlen = sizeof(buf);\n+    secp256k1_ge Q;\n+\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n \n-    if (!secp256k1_ec_pubkey_serialize(ctx, buf, &outputlen, (const secp256k1_pubkey *) pubkey, SECP256K1_EC_COMPRESSED)) {\n+    if (!secp256k1_pubkey_load(ctx, &Q, (secp256k1_pubkey *) pubkey)) {\n         return 0;\n     }\n-    memcpy(output32, &buf[1], 32);\n+    secp256k1_fe_normalize_var(&Q.x);\n+    secp256k1_fe_get_b32(output32, &Q.x);",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 47,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice :)",
      "created_at": "2019-11-18T21:22:54Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347616160",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347616160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 787,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 844,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347674483",
      "pull_request_review_id": 318712698,
      "id": 347674483,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzY3NDQ4Mw==",
      "diff_hunk": "@@ -836,7 +836,7 @@ int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_xon\n     return secp256k1_xonly_pubkey_from_pubkey(ctx, output_pubkey, has_square_y, &pubkey_tmp);\n }\n \n-int secp256k1_xonly_pubkey_tweak_verify(const secp256k1_context* ctx, const secp256k1_xonly_pubkey *output_pubkey, int has_square_y, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+int secp256k1_xonly_pubkey_tweak_test(const secp256k1_context* ctx, const secp256k1_xonly_pubkey *output_pubkey, int has_square_y, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 5,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You should also rename the defintion in secp256k1.h for this function.",
      "created_at": "2019-11-19T00:11:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347674483",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347674483"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 839,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347819819",
      "pull_request_review_id": 318897701,
      "id": 347819819,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0NzgxOTgxOQ==",
      "diff_hunk": "@@ -836,7 +836,7 @@ int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_xon\n     return secp256k1_xonly_pubkey_from_pubkey(ctx, output_pubkey, has_square_y, &pubkey_tmp);\n }\n \n-int secp256k1_xonly_pubkey_tweak_verify(const secp256k1_context* ctx, const secp256k1_xonly_pubkey *output_pubkey, int has_square_y, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+int secp256k1_xonly_pubkey_tweak_test(const secp256k1_context* ctx, const secp256k1_xonly_pubkey *output_pubkey, int has_square_y, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 5,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "in_reply_to_id": 347674483,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oh, fixed",
      "created_at": "2019-11-19T09:42:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347819819",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/347819819"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 839,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/349638716",
      "pull_request_review_id": 321603000,
      "id": 349638716,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM0OTYzODcxNg==",
      "diff_hunk": "@@ -701,6 +717,167 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence. Use the\n+ *  SECP256K1_LEN_XONLY_PUBKEY macro if your want to avoid the magic number 32.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 67,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a5f6b33704cb6a925bc4b3820f810387cfd0626c",
      "in_reply_to_id": null,
      "user": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "-your\r\n+you",
      "created_at": "2019-11-22T15:01:22Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r349638716",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/349638716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 753,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/350288546",
      "pull_request_review_id": 322411490,
      "id": 350288546,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MDI4ODU0Ng==",
      "diff_hunk": "@@ -53,6 +53,11 @@ static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n  *  for Y. Return value indicates whether the result is valid. */\n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd);\n \n+/* Converts group element into its \"absolute\" value. That means it is kept as\n+ * is if it has a square Y and otherwise negated. has_square_y is set to 1 in\n+ * the former case and to 0 in the latter case. */\n+static void secp256k1_ge_absolute(secp256k1_ge *r, int *has_square_y);",
      "path": "src/group.h",
      "position": null,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a87a0576dcc7188f8babc3fc9ec5f2a68522ff6d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`had_square_y`?",
      "created_at": "2019-11-25T16:28:16Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r350288546",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/350288546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 59,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/350295305",
      "pull_request_review_id": 322411490,
      "id": 350295305,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MDI5NTMwNQ==",
      "diff_hunk": "@@ -4361,11 +4365,17 @@ void test_xonly_pubkey_api(void) {\n     CHECK(ecount == 2);\n \n     ecount = 0;\n-    CHECK(secp256k1_xonly_pubkey_parse(none, &pk, buf32) == 1);\n     CHECK(secp256k1_xonly_pubkey_parse(none, NULL, buf32) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_parse(none, &pk, NULL) == 0);\n     CHECK(ecount == 2);\n+    /* Invalid field element */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk, ones32) == 0);\n+    CHECK(ecount == 2);\n+    /* There's no point with x-coordinate 0 on secp256k1 */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk, zeros32) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk, buf32) == 1);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 33,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a8686b9670e5aca53c45a95232d2257ccd922c50",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "CHECK(ecount == 2); too?",
      "created_at": "2019-11-25T16:39:01Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r350295305",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/350295305"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4434,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/350297158",
      "pull_request_review_id": 322411490,
      "id": 350297158,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MDI5NzE1OA==",
      "diff_hunk": "@@ -4356,13 +4356,23 @@ void test_xonly_pubkey_api(void) {\n     CHECK(secp256k1_xonly_pubkey_create(sign, &pk, NULL) == 0);\n     CHECK(ecount == 4);\n \n-    ecount = 0;\n     CHECK(secp256k1_xonly_pubkey_create(sign, &pk, sk) == 1);\n-    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &pk) == 1);\n+    ecount = 0;\n     CHECK(secp256k1_xonly_pubkey_serialize(none, NULL, &pk) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, NULL) == 0);\n+    CHECK(memcmp(buf32, zeros32, 32) == 0);\n     CHECK(ecount == 2);\n+    {\n+        /* A pubkey filled with 0s will fail to serialize due to pubkey_load\n+         * special casing. */\n+        secp256k1_xonly_pubkey pk_tmp;\n+        memset(&pk_tmp, 0, sizeof(pk_tmp));\n+        CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &pk_tmp) == 0);\n+    }\n+    /* pubkey_load called illegal callback */\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &pk) == 1);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 22,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a36d45d59733bc22f0e50bae5e0d7229358c971d",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "CHECK(ecount == 3);",
      "created_at": "2019-11-25T16:42:13Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r350297158",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/350297158"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4421,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/350298493",
      "pull_request_review_id": 322411490,
      "id": 350298493,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MDI5ODQ5Mw==",
      "diff_hunk": "@@ -852,8 +852,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n \n-/** Verifies that output_pubkey and has_square_y is the result of calling\n- *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+/** Tests that output_pubkey and has_square_y is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32. Note\n+ *  that this alone does _not_ verify anything cryptographically. If the tweak",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 8,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't know that \"anything cryptographically\" is. This sentence is hard to understand.\r\n\r\n\"Note that this does not verify that tweak32 is constructed in a specific way, e.g., as the hash of internal_pubkey and some message.\"\r\n\"Note that this does not verify that output_pubkey is a commitment to some message.\"",
      "created_at": "2019-11-25T16:44:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r350298493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/350298493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351012132",
      "pull_request_review_id": 323325542,
      "id": 351012132,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTAxMjEzMg==",
      "diff_hunk": "@@ -53,6 +53,11 @@ static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n  *  for Y. Return value indicates whether the result is valid. */\n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd);\n \n+/* Converts group element into its \"absolute\" value. That means it is kept as\n+ * is if it has a square Y and otherwise negated. has_square_y is set to 1 in\n+ * the former case and to 0 in the latter case. */\n+static void secp256k1_ge_absolute(secp256k1_ge *r, int *has_square_y);",
      "path": "src/group.h",
      "position": null,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a87a0576dcc7188f8babc3fc9ec5f2a68522ff6d",
      "in_reply_to_id": 350288546,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`is_negated`",
      "created_at": "2019-11-26T22:28:13Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351012132",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351012132"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 59,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351012669",
      "pull_request_review_id": 323326193,
      "id": 351012669,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTAxMjY2OQ==",
      "diff_hunk": "@@ -4361,11 +4365,17 @@ void test_xonly_pubkey_api(void) {\n     CHECK(ecount == 2);\n \n     ecount = 0;\n-    CHECK(secp256k1_xonly_pubkey_parse(none, &pk, buf32) == 1);\n     CHECK(secp256k1_xonly_pubkey_parse(none, NULL, buf32) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_parse(none, &pk, NULL) == 0);\n     CHECK(ecount == 2);\n+    /* Invalid field element */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk, ones32) == 0);\n+    CHECK(ecount == 2);\n+    /* There's no point with x-coordinate 0 on secp256k1 */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk, zeros32) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &pk, buf32) == 1);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 33,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a8686b9670e5aca53c45a95232d2257ccd922c50",
      "in_reply_to_id": 350295305,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`ecount` can only be changed through illegal or error callbacks which should always entail return value of 0.",
      "created_at": "2019-11-26T22:29:38Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351012669",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351012669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4434,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351013769",
      "pull_request_review_id": 323327514,
      "id": 351013769,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTAxMzc2OQ==",
      "diff_hunk": "@@ -852,8 +852,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n     const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n \n-/** Verifies that output_pubkey and has_square_y is the result of calling\n- *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+/** Tests that output_pubkey and has_square_y is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32. Note\n+ *  that this alone does _not_ verify anything cryptographically. If the tweak",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 8,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "41b7be1dac1cb60589a457939cc05165e878a4c7",
      "in_reply_to_id": 350298493,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-11-26T22:32:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351013769",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351013769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351013833",
      "pull_request_review_id": 323327598,
      "id": 351013833,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTAxMzgzMw==",
      "diff_hunk": "@@ -701,6 +717,167 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence. Use the\n+ *  SECP256K1_LEN_XONLY_PUBKEY macro if your want to avoid the magic number 32.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 67,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a5f6b33704cb6a925bc4b3820f810387cfd0626c",
      "in_reply_to_id": 349638716,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-11-26T22:32:40Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351013833",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351013833"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 753,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351024607",
      "pull_request_review_id": 323340749,
      "id": 351024607,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTAyNDYwNw==",
      "diff_hunk": "@@ -223,6 +223,10 @@ static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *s\n         secp256k1_sha256 sha;\n \n         if (!secp256k1_xonly_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            /* Logically unreachable because verify_batch_init_randomizer calls\n+             * secp256k1_ec_pubkey_serialize which only works if loading the\n+             * pubkey into a group element succeeds.*/\n+            VERIFY_CHECK(0);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "c1b1bbca759b5394d7198b8eecf83fec41f75c4f",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would be more natural to VERIFY_CHECK the result of the function call without an if.",
      "created_at": "2019-11-26T23:05:24Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351024607",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351024607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351025366",
      "pull_request_review_id": 323340749,
      "id": 351025366,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTAyNTM2Ng==",
      "diff_hunk": "@@ -822,9 +823,10 @@ int secp256k1_xonly_privkey_tweak_add(const secp256k1_context* ctx, unsigned cha\n     }\n     secp256k1_pubkey_load(ctx, &ge, &pubkey);\n     if (!secp256k1_fe_is_quad_var(&ge.y)) {\n-        if (!secp256k1_ec_privkey_negate(ctx, seckey32)) {\n-            return 0;\n-        }\n+        secp256k1_scalar_set_b32(&sec, seckey32, NULL);",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 15,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a8bd8df5f4fc10b8a60925b063e0600629b72f54",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe explain why it's okay to ignore the overflow.",
      "created_at": "2019-11-26T23:08:11Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351025366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351025366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 874,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351027204",
      "pull_request_review_id": 323340749,
      "id": 351027204,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTAyNzIwNA==",
      "diff_hunk": "@@ -859,9 +859,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n \n /** Tests that output_pubkey and is_negated is the result of calling",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 11,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a6f5245060ac496af7ca18164e16300190d96b51",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/is the result/are the results\r\nwell, maybe better say\r\n\r\n\"Tests whether a pair (output_pubkey, is_negated) is the result of calling\" or similar. I think that's more readable even though there are no actual pairs in C.",
      "created_at": "2019-11-26T23:14:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351027204",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351027204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351216255",
      "pull_request_review_id": 323581098,
      "id": 351216255,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTIxNjI1NQ==",
      "diff_hunk": "@@ -223,6 +223,10 @@ static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *s\n         secp256k1_sha256 sha;\n \n         if (!secp256k1_xonly_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            /* Logically unreachable because verify_batch_init_randomizer calls\n+             * secp256k1_ec_pubkey_serialize which only works if loading the\n+             * pubkey into a group element succeeds.*/\n+            VERIFY_CHECK(0);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "c1b1bbca759b5394d7198b8eecf83fec41f75c4f",
      "in_reply_to_id": 351024607,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-11-27T10:46:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351216255",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351216255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351216331",
      "pull_request_review_id": 323581181,
      "id": 351216331,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTIxNjMzMQ==",
      "diff_hunk": "@@ -822,9 +823,10 @@ int secp256k1_xonly_privkey_tweak_add(const secp256k1_context* ctx, unsigned cha\n     }\n     secp256k1_pubkey_load(ctx, &ge, &pubkey);\n     if (!secp256k1_fe_is_quad_var(&ge.y)) {\n-        if (!secp256k1_ec_privkey_negate(ctx, seckey32)) {\n-            return 0;\n-        }\n+        secp256k1_scalar_set_b32(&sec, seckey32, NULL);",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 15,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a8bd8df5f4fc10b8a60925b063e0600629b72f54",
      "in_reply_to_id": 351025366,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-11-27T10:46:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351216331",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351216331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 874,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351216394",
      "pull_request_review_id": 323581249,
      "id": 351216394,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MTIxNjM5NA==",
      "diff_hunk": "@@ -859,9 +859,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n \n /** Tests that output_pubkey and is_negated is the result of calling",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 11,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a6f5245060ac496af7ca18164e16300190d96b51",
      "in_reply_to_id": 351027204,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2019-11-27T10:46:41Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r351216394",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/351216394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/352698125",
      "pull_request_review_id": 325369089,
      "id": 352698125,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MjY5ODEyNQ==",
      "diff_hunk": "@@ -171,21 +154,26 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_sc\n         return 0;\n     }\n \n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n     secp256k1_schnorrsig_sha256_tagged(&sha);\n     secp256k1_sha256_write(&sha, &sig->data[0], 32);\n-    secp256k1_xonly_pubkey_serialize(ctx, buf, pk);\n+    secp256k1_fe_normalize_var(&pk.x);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 53,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a74a0132e416facc2da0972ee1f4e0a8917a3723",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I *think* this normalize isn't needed? (because it was just deserialized, and when serializing you *have* to normalize it to avoid malleabilities.)",
      "created_at": "2019-12-02T16:32:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r352698125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/352698125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/352699232",
      "pull_request_review_id": 325369089,
      "id": 352699232,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MjY5OTIzMg==",
      "diff_hunk": "@@ -233,19 +221,20 @@ static int secp256k1_schnorrsig_verify_batch_ecmult_callback(secp256k1_scalar *s\n     } else {\n         unsigned char buf[32];\n         secp256k1_sha256 sha;\n+\n+        if (!secp256k1_xonly_pubkey_load(ecmult_context->ctx, pt, ecmult_context->pk[idx / 2])) {\n+            return 0;\n+        }\n         secp256k1_schnorrsig_sha256_tagged(&sha);\n         secp256k1_sha256_write(&sha, &ecmult_context->sig[idx / 2]->data[0], 32);\n-        secp256k1_xonly_pubkey_serialize(ecmult_context->ctx, buf, ecmult_context->pk[idx / 2]);\n+        secp256k1_fe_normalize_var(&pt->x);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 87,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a74a0132e416facc2da0972ee1f4e0a8917a3723",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "same?",
      "created_at": "2019-12-02T16:34:38Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r352699232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/352699232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/352913543",
      "pull_request_review_id": 325810736,
      "id": 352913543,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1MjkxMzU0Mw==",
      "diff_hunk": "@@ -171,21 +154,26 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_sc\n         return 0;\n     }\n \n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n     secp256k1_schnorrsig_sha256_tagged(&sha);\n     secp256k1_sha256_write(&sha, &sig->data[0], 32);\n-    secp256k1_xonly_pubkey_serialize(ctx, buf, pk);\n+    secp256k1_fe_normalize_var(&pk.x);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 53,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "a74a0132e416facc2da0972ee1f4e0a8917a3723",
      "in_reply_to_id": 352698125,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed. Pubkeys are always normalized. Fixed.",
      "created_at": "2019-12-02T23:24:44Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r352913543",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/352913543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/356638639",
      "pull_request_review_id": 330591799,
      "id": 356638639,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1NjYzODYzOQ==",
      "diff_hunk": "@@ -701,6 +713,172 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to\n+ *  the seckey (modulo the group order). Otherwise, tweak32 is added to the\n+ *  negation of the seckey (modulo the group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Because the resulting point may have a non-square Y coordinate, it may not\n+ *  be representable by an x-only pubkey. Instead, `output_pubkey` will be set\n+ *  to the negation of that point. Therefore this function outputs `is_negated`\n+ *  which is required for `xonly_pubkey_tweak_test`.\n+ *\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *           is_negated: pointer to an integer that will be set to 1 if\n+ *                       `output_pubkey` is the negation of the point that\n+ *                       resulted from adding the tweak. (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *output_pubkey,\n+    int *is_negated,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 160,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "1901f3bf9c6197f0bd3cc62e9f6c69296566a23a",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How do people feel about promising that it's fine for `output_pubkey` and `internal_pubkey` to point to the same object?\r\nRight now it will work. but a lot of our APIs start by zeroing out the output object. and then this isn't fine anymore.\r\n\r\nOn one hand it's nice to not return uninitialized objects. on the other a lot of times you want to tweak the key in place.",
      "created_at": "2019-12-11T14:45:23Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r356638639",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/356638639"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 848,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 853,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/356841122",
      "pull_request_review_id": 330851605,
      "id": 356841122,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1Njg0MTEyMg==",
      "diff_hunk": "@@ -701,6 +713,172 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to\n+ *  the seckey (modulo the group order). Otherwise, tweak32 is added to the\n+ *  negation of the seckey (modulo the group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Because the resulting point may have a non-square Y coordinate, it may not\n+ *  be representable by an x-only pubkey. Instead, `output_pubkey` will be set\n+ *  to the negation of that point. Therefore this function outputs `is_negated`\n+ *  which is required for `xonly_pubkey_tweak_test`.\n+ *\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *           is_negated: pointer to an integer that will be set to 1 if\n+ *                       `output_pubkey` is the negation of the point that\n+ *                       resulted from adding the tweak. (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *output_pubkey,\n+    int *is_negated,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 160,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "1901f3bf9c6197f0bd3cc62e9f6c69296566a23a",
      "in_reply_to_id": 356638639,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Right now it will work. but a lot of our APIs start by zeroing out the output object. and then this isn't fine anymore.\r\n\r\nI don't see why. `secp256k1_ec_pubkey_tweak_add` zeroes the key and is in place. Actually we should also zeroize the output key in this function.\r\n\r\nAlso, that `xonly_pubkey_tweak_add` does not work in place (and therefore differs from `ec_pubkey_tweak_add`) is just for historical reasons (initially output_pubkey was a different type than internal_pubkey, namely `secp256k1_pubkey`). How do people feel about changing the function to tweak the pubkey in-place? I think I prefer that because otherwise it's inconsistent with pubkey_tweak_add.",
      "created_at": "2019-12-11T21:22:50Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r356841122",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/356841122"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 848,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 853,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/358685652",
      "pull_request_review_id": 333137640,
      "id": 358685652,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1ODY4NTY1Mg==",
      "diff_hunk": "@@ -701,6 +713,172 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to\n+ *  the seckey (modulo the group order). Otherwise, tweak32 is added to the\n+ *  negation of the seckey (modulo the group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Because the resulting point may have a non-square Y coordinate, it may not\n+ *  be representable by an x-only pubkey. Instead, `output_pubkey` will be set\n+ *  to the negation of that point. Therefore this function outputs `is_negated`\n+ *  which is required for `xonly_pubkey_tweak_test`.\n+ *\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *           is_negated: pointer to an integer that will be set to 1 if\n+ *                       `output_pubkey` is the negation of the point that\n+ *                       resulted from adding the tweak. (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *output_pubkey,\n+    int *is_negated,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 160,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "1901f3bf9c6197f0bd3cc62e9f6c69296566a23a",
      "in_reply_to_id": 356638639,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Okay, `tweak_add` changes the pubkey in-place now. And added a test that the pubkey is zeroed on failure.",
      "created_at": "2019-12-17T09:35:05Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r358685652",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/358685652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 848,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 853,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369404968",
      "pull_request_review_id": 346388354,
      "id": 369404968,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNDk2OA==",
      "diff_hunk": "@@ -701,6 +713,172 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the private key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting private key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to\n+ *  the seckey (modulo the group order). Otherwise, tweak32 is added to the\n+ *  negation of the seckey (modulo the group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting private key would be\n+ *             invalid (only when the tweak is the complement of the private key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte private key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_privkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Because the resulting point may have a non-square Y coordinate, it may not\n+ *  be representable by an x-only pubkey. Instead, `output_pubkey` will be set\n+ *  to the negation of that point. Therefore this function outputs `is_negated`\n+ *  which is required for `xonly_pubkey_tweak_test`.\n+ *\n+ *  Returns: 1 if tweak times the generator was successfully added to pubkey\n+ *           0 if the tweak was out of range or the resulting public key would be\n+ *             invalid (only when the tweak is the complement of the corresponding\n+ *             private key).\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key object (cannot be NULL)\n+ *           is_negated: pointer to an integer that will be set to 1 if\n+ *                       `output_pubkey` is the negation of the point that\n+ *                       resulted from adding the tweak. (cannot be NULL)\n+ *  In: internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *output_pubkey,\n+    int *is_negated,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 160,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "1901f3bf9c6197f0bd3cc62e9f6c69296566a23a",
      "in_reply_to_id": 356638639,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The reason for zeroizing the outputs is mostly so that if the caller doesn't know errors need to be handled, that the output is invalid so that hopefully later error handling will do something useful.  This is especially a concern because errors should never be seen without crafted inputs, and it's plausible a caller simply won't know they're possible at all. This isn't incompatible with in-place operation. (though not-in-place operation is arguably riskier to not zero because it might expose the content of random secrets if the caller ignores the error).\r\n\r\nZeroizing also makes programming errors more likely to get detected faster, e.g. if the function is called with an invalid output pointer but also an invalid input,  if it zeroizes it's more likely to cause a valgrind error and/or program crash rather than silently being broken.",
      "created_at": "2020-01-22T07:34:40Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369404968",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369404968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 848,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 853,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369783860",
      "pull_request_review_id": 346877566,
      "id": 369783860,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4Mzg2MA==",
      "diff_hunk": "@@ -523,6 +523,18 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.\n+ *\n+ * If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ * extra entropy. If the data pointer is NULL and this function is used in\n+ * schnorrsig_sign, it produces BIP-schnorr compliant signatures.\n+ * When this function is used in ecdsa_sign, it generates a nonce using an\n+ * analogue of the bip-schnorr nonce generation algorithm, but with tag\n+ * \"BIPSchnorrNULL\" instead of \"BIPSchnorrDerive\".\n+ * The attempt argument must be 0 or the function will fail and return 0.\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_bipschnorr;",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 14,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nSECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_bip340;\r\n```",
      "created_at": "2020-01-22T20:23:23Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369783860",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369783860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 536,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784000",
      "pull_request_review_id": 346877743,
      "id": 369784000,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NDAwMA==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 72,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\r\n```",
      "created_at": "2020-01-22T20:23:41Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369784000",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784099",
      "pull_request_review_id": 346877875,
      "id": 369784099,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NDA5OQ==",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 67,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        noncefp = secp256k1_nonce_function_bip340;\r\n```",
      "created_at": "2020-01-22T20:23:56Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369784099",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784099"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784245",
      "pull_request_review_id": 346878045,
      "id": 369784245,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NDI0NQ==",
      "diff_hunk": "@@ -413,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 6,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nstatic void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\r\n```",
      "created_at": "2020-01-22T20:24:11Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369784245",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784245"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 418,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784370",
      "pull_request_review_id": 346878228,
      "id": 369784370,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NDM3MA==",
      "diff_hunk": "@@ -413,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */\n+static int nonce_function_bipschnorr(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 21,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nstatic int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\r\n```",
      "created_at": "2020-01-22T20:24:31Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369784370",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784370"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 433,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784470",
      "pull_request_review_id": 346878378,
      "id": 369784470,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NDQ3MA==",
      "diff_hunk": "@@ -413,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */\n+static int nonce_function_bipschnorr(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If the this nonce function is used in BIP-schnorr signing as\n+     * defined in the spec, an optimized tagging implementation is used. */\n+    if (algo16 != NULL) {\n+        if (memcmp(algo16, \"BIPSchnorrDerive\", 16) == 0) {\n+            secp256k1_nonce_function_bipschnorr_sha256_tagged(&sha);",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 32,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n            secp256k1_nonce_function_bip340_sha256_tagged(&sha);\r\n```",
      "created_at": "2020-01-22T20:24:46Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369784470",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784470"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 444,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784626",
      "pull_request_review_id": 346878589,
      "id": 369784626,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NDYyNg==",
      "diff_hunk": "@@ -443,6 +491,7 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n    return 1;\n }\n \n+const secp256k1_nonce_function secp256k1_nonce_function_bipschnorr = nonce_function_bipschnorr;",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 59,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nconst secp256k1_nonce_function secp256k1_nonce_function_bip340 = nonce_function_bip340;\r\n```",
      "created_at": "2020-01-22T20:25:08Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369784626",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784626"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 494,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784912",
      "pull_request_review_id": 346878951,
      "id": 369784912,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NDkxMg==",
      "diff_hunk": "@@ -701,6 +713,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See bip-schnorr for more",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 25,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\r\n```",
      "created_at": "2020-01-22T20:25:49Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369784912",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369784912"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 718,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369785047",
      "pull_request_review_id": 346879128,
      "id": 369785047,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NTA0Nw==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 11,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n * BIP-340\r\n```",
      "created_at": "2020-01-22T20:26:11Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369785047",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369785047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369785588",
      "pull_request_review_id": 346879870,
      "id": 369785588,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NTU4OA==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 12,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n * (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\r\n```\r\nThis link is broken until [the PR is merged](https://github.com/bitcoin/bips/pull/876).",
      "created_at": "2020-01-22T20:27:37Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369785588",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369785588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369786223",
      "pull_request_review_id": 346880690,
      "id": 369786223,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NjIyMw==",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 33,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the tagged hashes must not be renamed to `BIP340`, so I will not suggest the edit, but please confirm that `BIPSchnorr` is the proper way.",
      "created_at": "2020-01-22T20:29:04Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369786223",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369786223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369786654",
      "pull_request_review_id": 346881292,
      "id": 369786654,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NjY1NA==",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 33,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": 369786223,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, that's what the spec says.",
      "created_at": "2020-01-22T20:30:06Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369786654",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369786654"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369786736",
      "pull_request_review_id": 346881396,
      "id": 369786736,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NjczNg==",
      "diff_hunk": "@@ -413,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 19,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n/* This nonce function is described in BIP-340\r\n```",
      "created_at": "2020-01-22T20:30:17Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369786736",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369786736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 431,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369787008",
      "pull_request_review_id": 346881783,
      "id": 369787008,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NzAwOA==",
      "diff_hunk": "@@ -413,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 20,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n * (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) */\r\n```",
      "created_at": "2020-01-22T20:30:58Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369787008",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369787008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 432,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369787169",
      "pull_request_review_id": 346881984,
      "id": 369787169,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NzE2OQ==",
      "diff_hunk": "@@ -413,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */\n+static int nonce_function_bipschnorr(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If the this nonce function is used in BIP-schnorr signing as",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 28,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n     * algorithms. If the this nonce function is used in BIP-340 signing as\r\n```",
      "created_at": "2020-01-22T20:31:18Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369787169",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369787169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 440,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369787965",
      "pull_request_review_id": 346883091,
      "id": 369787965,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4Nzk2NQ==",
      "diff_hunk": "@@ -523,6 +523,18 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 4,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n/** An implementation of the nonce generation function as defined in BIP-340.\r\n```",
      "created_at": "2020-01-22T20:33:24Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369787965",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369787965"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 526,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369788174",
      "pull_request_review_id": 346883391,
      "id": 369788174,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4ODE3NA==",
      "diff_hunk": "@@ -523,6 +523,18 @@ SECP256K1_API int secp256k1_ecdsa_signature_normalize(\n  */\n SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;\n \n+/** An implementation of the nonce generation function as defined in BIP-schnorr.\n+ *\n+ * If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ * extra entropy. If the data pointer is NULL and this function is used in\n+ * schnorrsig_sign, it produces BIP-schnorr compliant signatures.",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 8,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": null,
      "user": {
        "login": "MaxHillebrand",
        "id": 30683012,
        "node_id": "MDQ6VXNlcjMwNjgzMDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MaxHillebrand",
        "html_url": "https://github.com/MaxHillebrand",
        "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
        "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
        "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
        "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
        "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n * schnorrsig_sign, it produces BIP-340 compliant signatures.\r\n```",
      "created_at": "2020-01-22T20:33:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r369788174",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/369788174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 530,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/370262387",
      "pull_request_review_id": 347487367,
      "id": 370262387,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2MjM4Nw==",
      "diff_hunk": "@@ -413,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 20,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "df8c698793a51639b6fdb5b908b1ddfaedbe1fd5",
      "in_reply_to_id": 369787008,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "404. I'll probably do the name change once the PR is merged. In some cases I'd rather write `BIP-340 (\"Schnorr Signatures for secp256k1\")`.",
      "created_at": "2020-01-23T17:43:59Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r370262387",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/370262387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 432,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371027220",
      "pull_request_review_id": 348403015,
      "id": 371027220,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyNzIyMA==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": null,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "uh. shouldn't this present an interface that takes the pubkey as an argument, rather than halving the signing speed for data the caller already probably has (and if they don't have it, they can generate it at the same speed with one extra line of code).  Or perhaps accept a null pointer for the case where they don't have it.",
      "created_at": "2020-01-26T20:29:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371027220",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371027220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371027377",
      "pull_request_review_id": 348403184,
      "id": 371027377,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyNzM3Nw==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was thinking about this too. A complication with x-only public keys is that to take advantage of this, you'd also need to pass in whether the Y coordinate of privkey*G is a quadratic residue or not (as that implies negating the private key before signing).",
      "created_at": "2020-01-26T20:32:49Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371027377",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371027377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371027725",
      "pull_request_review_id": 348403446,
      "id": 371027725,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyNzcyNQ==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To solve this, we'll probably want a data structure that stores both the x-only pubkey and a boolean that indicates its negation-needed flag (which is equal to whether the privkey*G has a non-square Y coordinate).\r\n\r\nThat structure starts to look surprisingly much like the old public key type, except it's square/nonsquare Y rather than even/odd.",
      "created_at": "2020-01-26T20:38:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371027725",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371027725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371029200",
      "pull_request_review_id": 348404823,
      "id": 371029200,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyOTIwMA==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes it should be possible to use an interface that's twice as fast if you know the pubkey.\r\n\r\nNote that in that case we'll need to add the pubkey as extradata to the deterministic nonce function, otherwise calling sign with the wrong public key may leak the secret key through an (invalid) signature. This makes the signing function with pubkey argument not pass the signing test vectors.\r\n\r\n> That structure starts to look surprisingly much like the old public key type\r\n\r\nThis is what I did originally for `xonly_pubkey_create`, `xonly_tweak_add` etc. But people found that confusing, and so I changed the functions to output `xonly_pubkey` and `is_negated` (but apparently not for the `xonly_pubkey_create` function). `is_negated` is crucial in avoiding similar recomputation in MuSig and the likes, but apparently I missed the normal Schnorr signing use case.",
      "created_at": "2020-01-26T21:05:02Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371029200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371029200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371030838",
      "pull_request_review_id": 348406164,
      "id": 371030838,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAzMDgzOA==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Any background on why it was confusing?  A single object (which you'd then have a seperate serializer for) seems less confusing to me.",
      "created_at": "2020-01-26T21:32:02Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371030838",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371030838"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371031134",
      "pull_request_review_id": 348406368,
      "id": 371031134,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAzMTEzNA==",
      "diff_hunk": "@@ -413,6 +413,52 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If the this nonce function is used in BIP-340 signing as",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 26,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6603c32a10eb0025ac35adc159bf9c57b8e29334",
      "in_reply_to_id": null,
      "user": {
        "login": "constcast-glitch",
        "id": 60033096,
        "node_id": "MDQ6VXNlcjYwMDMzMDk2",
        "avatar_url": "https://avatars.githubusercontent.com/u/60033096?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/constcast-glitch",
        "html_url": "https://github.com/constcast-glitch",
        "followers_url": "https://api.github.com/users/constcast-glitch/followers",
        "following_url": "https://api.github.com/users/constcast-glitch/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/constcast-glitch/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/constcast-glitch/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/constcast-glitch/subscriptions",
        "organizations_url": "https://api.github.com/users/constcast-glitch/orgs",
        "repos_url": "https://api.github.com/users/constcast-glitch/repos",
        "events_url": "https://api.github.com/users/constcast-glitch/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/constcast-glitch/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe \"If the this nonce function ...\" should be \"If this nonce function ...\".",
      "created_at": "2020-01-26T21:36:36Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371031134",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371031134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371032243",
      "pull_request_review_id": 348407226,
      "id": 371032243,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAzMjI0Mw==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The confusing part was probably my explanation for why this is useful because the interface wasn't as clear at the time. However, I'd be happy to change it back as the `is_negated` flag is a recurring nuisance.",
      "created_at": "2020-01-26T21:54:31Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371032243",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371032243"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371033718",
      "pull_request_review_id": 348408385,
      "id": 371033718,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAzMzcxOA==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I hate to bring this up at this point, but this discussion makes me wonder if we should consider the changing the x-only pubkey tiebreaker from square-y to even-y (but leave the R one at square-y).\r\n\r\nFirst of all, using square-y strictly adds a Jacobi symbol computation to either the keygen or signing process, for no gain except consistency with R. Using square-y for R itself does not have this problem, as it avoids a conversion to affine coordinates, but we always need P in affine coordinates anyway.\r\n\r\nHowever, if we're going to need an application-exposed full pubkey type, using square-y as a tie breaker adds another downside, namely not being able to reuse the existing normal public keys. This matters, because compatibility with existing key generation is a goal, and I believe that interaction between the two may be annoying in some cases.\r\n\r\nThink about the use case of a simple single-user Taproot output, and spending it via PSBT. PSBT already has records that say \"this (full) pubkey was derived this way\" (from which master key, and which key derivation path), which we'll want to reuse in a Taproot world. For key path spending, we'll need a new PSBT record that states \"this (xonly) public key is equal to (reference to full pubkey) with tweak X\". With square-y keys, if we want to avoid forcing the Jacobi symbol computation onto PSBT signers, it also needs flags to indicate whether the private key is to be negated before the tweak and after the tweak. With even-y keys, a generic \"this full public key is this full public key + this tweak\" that isn't even Taproot specific suffices.",
      "created_at": "2020-01-26T22:22:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371033718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371033718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371058386",
      "pull_request_review_id": 348434042,
      "id": 371058386,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA1ODM4Ng==",
      "diff_hunk": "@@ -443,6 +443,60 @@ void run_sha256_tests(void) {\n     }\n }\n \n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(secp256k1_sha256 *sha1, secp256k1_sha256 *sha2) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char buf2[32];\n+\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);\n+\n+    /* Compare the struct excluding the the buffer, because it may be",
      "path": "src/tests.c",
      "position": null,
      "original_position": 14,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6603c32a10eb0025ac35adc159bf9c57b8e29334",
      "in_reply_to_id": null,
      "user": {
        "login": "leishman",
        "id": 3648618,
        "node_id": "MDQ6VXNlcjM2NDg2MTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3648618?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/leishman",
        "html_url": "https://github.com/leishman",
        "followers_url": "https://api.github.com/users/leishman/followers",
        "following_url": "https://api.github.com/users/leishman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/leishman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/leishman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/leishman/subscriptions",
        "organizations_url": "https://api.github.com/users/leishman/orgs",
        "repos_url": "https://api.github.com/users/leishman/repos",
        "events_url": "https://api.github.com/users/leishman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/leishman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`the the`",
      "created_at": "2020-01-27T03:55:22Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371058386",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371058386"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 456,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371072947",
      "pull_request_review_id": 348450766,
      "id": 371072947,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA3Mjk0Nw==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think user in general should be discouraged from reusing keys in different applications, beyond the general precautions that get given for all key reuse in crypto (surprising bad things can happen)-- there is a very specific easily reached route where using keys across different uses will break things:   Use of schnorr+ecdsa on the same message with the same nonce leaks the key.  I'm confident some implementations are going to screw that up, and reuse their existing rfc6979...\r\n\r\nBeing compatible with existing generation routines doesn't mean reusing the keys in other applications.\r\n\r\nIf you take the key reuse off the table I don't think it matters particularly much.  We could, if we wanted, define a new kind of 'compressed pubkey' that instead of 2/3 uses different bits to signal square/non-square.\r\n\r\nI agree that it's weak one way vs another.",
      "created_at": "2020-01-27T06:01:49Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371072947",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371072947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371129014",
      "pull_request_review_id": 348519744,
      "id": 371129014,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyOTAxNA==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "thinking about it, one way would be to use the existing pubkey objects. Add an internal flag for the squareness.  And have serialize flags that know how to serialize either as xonly OR using a non-standard value in the first byte to signal the squareness?",
      "created_at": "2020-01-27T09:18:10Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371129014",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371129014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371309752",
      "pull_request_review_id": 348753948,
      "id": 371309752,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMwOTc1Mg==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Well. I agree, there should be a way to sign without the need to recompute a public key that the user knows already. But this here worries me:\r\n\r\n> Note that in that case we'll need to add the pubkey as extradata to the deterministic nonce function, otherwise calling sign with the wrong public key may leak the secret key through an (invalid) signature. This makes the signing function with pubkey argument not pass the signing test vectors.\r\n\r\nYes, and annoyingly we need to add the extended public key here. Otherwise you can trick people into producing two signatures, one with and one without negated signing key, which leaks your nonce by `s1 + s2 = (r + cx) + (r - cx) = 2r`. Note that this is a different attack than the ordinary nonce reuse attack: here, you reuse the nonce `r` but you actually sign for the same hash `c = H(pk||R||m)`. So this is pretty subtle and I bet people will get this wrong. :/\r\n\r\nThis brings me to a question of provable security: if in practice there is a signing algorithm that takes a public key, then you should also have an equivalent signing oracle in your security model on paper. I don't think it's hard but unfortunately, noone has looked into this.  \r\n\r\nIt was a deliberate choice to make schnorr pubkeys different from ecdsa pubkeys to discourage reuse across different scheme. And now they are so different that they are even recognizable by their size, which I think is a good thing.  \r\n\r\nLet's call this \"extended pubkeys\". I prefer \"extended\" over \"full\" because full suggests that for non-full keys, an essential part is missing. But \"extended\" it's not great either. Maybe there is a better term.\r\n\r\nI would love to propose that extended pubkeys should have a serialization which is different from 2/3. But if we want to be compatible to BIP32, that's just not possible. Or do people think it's a good idea to be compatible to a variant of BIP32 only? That seems somewhat weird to me but one point is that anyway you want different derivation paths for schnorr vs ecdsa...\r\n\r\nI was never too convinced about the advantage of \"consistency of the tie-breaker\". If it's faster, why not use odd/even.\r\n",
      "created_at": "2020-01-27T15:33:11Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371309752",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371309752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371321001",
      "pull_request_review_id": 348768570,
      "id": 371321001,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMyMTAwMQ==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not a big deal, but using the oddness tiebreaker requires adding another line in the BIP's verification algo that negates `y` if odd. We don't need that for the squareness tie breaker because the square root automatically computes the square `y`. This was the original rationale for using squareness (not thinking about signing) in addition to the consistency.",
      "created_at": "2020-01-27T15:50:59Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371321001",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371321001"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371433647",
      "pull_request_review_id": 348913610,
      "id": 371433647,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzMzY0Nw==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, squareness is faster to decode but a negation is about as close to free as you can get while still doing something.",
      "created_at": "2020-01-27T19:22:46Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371433647",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371433647"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371436501",
      "pull_request_review_id": 348917012,
      "id": 371436501,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNjUwMQ==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "or you make a super-extended public key which also includes a tagged cryptographic hash of the private key. :-/",
      "created_at": "2020-01-27T19:28:14Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371436501",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371436501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371451142",
      "pull_request_review_id": 348934660,
      "id": 371451142,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1MTE0Mg==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Splitting discussions out. This one about the performance impact on signing, without precomputed public key data.\r\n\r\n* With squareness tie-breaker, signing needs to compute (`privkey*G`), compute its affine X coordinate (=computing inv(Z), squaring it, and multiplying with X), compute the squaredness of its Y coordinate (=computing Y*Z, and jacobi of it), normalize X, and then conditionally negate the privkey.\r\n\r\n* With oddness tie-breaker, signing needs to compute (`privkey*G`), compute its affine X coordinate (=computing inv(Z), squaring it, and multiplying with X), compute the affine Y coordinate (=computing 1/Z^3, and multiplying with Y), normalize X, normalize Y, and then conditionally negate the privkey.\r\n\r\nThe current PR does one unnecessary multiplication, as it's unnecessarily computing the affine Y coordinate. After fixing that, the speed gain from going from square to even tiebreaker is trading 1 field multiplication and normalization for 1 jacobi computation - which is dominated by the jacobi symbol.\r\n\r\nI don't know if we care about this ~5us speedup at signing time (because when you do care, perhaps you want signing with precomputed public key data, which avoids this cost in both cases), but there seems to be basically no gain apart from consistency with R (which is arguably very different, as handling of R is generally limited in scope to the signing code, while public keys are obviously exposed to applications (and things like the taproot tweak break the perfect blackboxy ness of them).\r\n\r\n",
      "created_at": "2020-01-27T19:56:43Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371451142",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371451142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371533366",
      "pull_request_review_id": 349039009,
      "id": 371533366,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMzM2Ng==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Split out discussion. This one is about avoiding the EC multiplication by using precomputed pubkey data.\r\n\r\nIt seems a question is whether we need to protect against the situation where the public key (or data derived from it), passed to the signing function, is actually computed by the signer itself, or untrusted.\r\n\r\nIn the case of signing devices with a fixed master BIP32 key, the public key is likely going be computed by the device itself anyway at signing time, so it's wasteful to have the signing algorithm redo it.\r\n\r\nOn the other hand, @real-or-random and @jonasnick correctly point out that if the public key data provided to the signing algorithm is untrusted, this public key data must also be an input to the derivation function. I don't think we have a proof that even with this modified derivation function, the resulting signature scheme is secure.\r\n\r\nSo I think that's an unfortunate situation to be in. We shouldn't standardize an (alternative) signing algorithm that takes untrusted pubkey data as input (because we have no proof it is secure), but simultaneously, having an API that takes in trusted pubkey data is scary (because if the API is abused with untrusted pubkey data, we have a known attack).\r\n\r\nFWIW, the ed25519-donna implementation seems to happily take the public key as input to the signer. I wonder if the concern of an untrusted public key has been analysed in that context.\r\n\r\n\r\n\r\n",
      "created_at": "2020-01-27T23:08:42Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371533366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371533366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371647981",
      "pull_request_review_id": 349177531,
      "id": 371647981,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY0Nzk4MQ==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@sipa I took the freedom to \"move\" your two summary posts to https://github.com/sipa/bips/issues/190 and https://github.com/sipa/bips/issues/191 because GitHub's \"comment on code\" feature is not good for extended discussions, and these issues are actually issues, and they relate to the BIP itself, not only the implementation. \r\n\r\nPlease continue there.",
      "created_at": "2020-01-28T07:48:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r371647981",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/371647981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/379895901",
      "pull_request_review_id": 359396943,
      "id": 379895901,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg5NTkwMQ==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "May I come back to the original discussion of should `is_negated` be part of the pubkey part and serialized out or not?\r\nI mean the only need for `is_negated` is to verify that you tweak correctly, can/should this be part of the struct? if so it will mean that `tweak_test(der(ser(add(key, tweak), key, tweak) != tweak_test(add(key,tweak), key, tweak)`",
      "created_at": "2020-02-16T11:32:39Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r379895901",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/379895901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/380160251",
      "pull_request_review_id": 359707215,
      "id": 380160251,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE2MDI1MQ==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@elichai Not exactly sure what your point is but we have a struct that has the `is_negated` part and is serializable - the plain old `secp256k1_pubkey` struct. Sounds like you're arguing for API design option 2 (https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-582152117). I don't think compressed serialization is not enough, because taproot users need a single `is_negated` bit to stuff in the control block and I don't think we want them to extract it themselves from the `0x02/0x03` tags.",
      "created_at": "2020-02-17T12:43:05Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r380160251",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/380160251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/380161982",
      "pull_request_review_id": 359709297,
      "id": 380161982,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE2MTk4Mg==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yeah I guess we must output the oddness byte someone, so we might as well have it as a separate thing instead of compressed because for most sign/verify you don't need it ",
      "created_at": "2020-02-17T12:47:02Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r380161982",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/380161982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/381884290",
      "pull_request_review_id": 361754686,
      "id": 381884290,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4NDI5MA==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function_extended noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    if (!noncefp(buf, msg32, seckey_tmp, pk_buf, (unsigned char *) \"BIP340/nonce0000\", (void*)ndata, 0)) {\n+        memset(sig, 0, sizeof(*sig));\n+        memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+    memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        memset(sig, 0, sizeof(*sig));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 221,
      "original_position": 169,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "23c3b0050e9878379cd3028960a506f59550f87b",
      "in_reply_to_id": null,
      "user": null,
      "body": "should overflow be checked here as well?",
      "created_at": "2020-02-20T09:39:08Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r381884290",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/381884290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 221,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/381893621",
      "pull_request_review_id": 361766706,
      "id": 381893621,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg5MzYyMQ==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function_extended noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    if (!noncefp(buf, msg32, seckey_tmp, pk_buf, (unsigned char *) \"BIP340/nonce0000\", (void*)ndata, 0)) {\n+        memset(sig, 0, sizeof(*sig));\n+        memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+    memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        memset(sig, 0, sizeof(*sig));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 221,
      "original_position": 169,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "23c3b0050e9878379cd3028960a506f59550f87b",
      "in_reply_to_id": 381884290,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, computing e as hash mod n matches BIP-340",
      "created_at": "2020-02-20T09:55:34Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r381893621",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/381893621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 221,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/382077777",
      "pull_request_review_id": 362002686,
      "id": 382077777,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA3Nzc3Nw==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function_extended noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    if (!noncefp(buf, msg32, seckey_tmp, pk_buf, (unsigned char *) \"BIP340/nonce0000\", (void*)ndata, 0)) {\n+        memset(sig, 0, sizeof(*sig));\n+        memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+    memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        memset(sig, 0, sizeof(*sig));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 221,
      "original_position": 169,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "23c3b0050e9878379cd3028960a506f59550f87b",
      "in_reply_to_id": 381884290,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe add a comment as a reminder for the casual reviewer.",
      "created_at": "2020-02-20T15:35:17Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r382077777",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/382077777"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 221,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/383645328",
      "pull_request_review_id": 363855096,
      "id": 383645328,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NTMyOA==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function_extended noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    if (!noncefp(buf, msg32, seckey_tmp, pk_buf, (unsigned char *) \"BIP340/nonce0000\", (void*)ndata, 0)) {\n+        memset(sig, 0, sizeof(*sig));\n+        memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+    memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        memset(sig, 0, sizeof(*sig));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 211,
      "original_position": 159,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "23c3b0050e9878379cd3028960a506f59550f87b",
      "in_reply_to_id": null,
      "user": null,
      "body": "Is `secp256k1_xonly_pubkey_load`  / `secp256k1_pubkey_load` an equivalent of `point(pk)` in BIP-340?\r\nmaybe it'll be good to add a reminder comment of what happens if `pubkey's x > p - 1` (if it fails here, as in BIP-340, what makes it fail /  `secp256k1_fe_from_storage` or `secp256k1_fe_set_b32`...?  -- or if it goes through and fails at the end, why it is fine)",
      "created_at": "2020-02-25T03:50:49Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r383645328",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/383645328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/389257553",
      "pull_request_review_id": 370746140,
      "id": 389257553,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1NzU1Mw==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function_extended noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    if (!noncefp(buf, msg32, seckey_tmp, pk_buf, (unsigned char *) \"BIP340/nonce0000\", (void*)ndata, 0)) {\n+        memset(sig, 0, sizeof(*sig));\n+        memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+    memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        memset(sig, 0, sizeof(*sig));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 211,
      "original_position": 159,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "23c3b0050e9878379cd3028960a506f59550f87b",
      "in_reply_to_id": 383645328,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, the equivalent is `secp256k1_xonly_pubkey_load` (the `pubkey` argument to `secp256k1_schnorrsig_verify` is already an `xonly_pubkey` while the BIP-340 `pk` is a byte array,).",
      "created_at": "2020-03-07T14:14:42Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r389257553",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/389257553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/389257707",
      "pull_request_review_id": 370746257,
      "id": 389257707,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1NzcwNw==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function_extended noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    if (!noncefp(buf, msg32, seckey_tmp, pk_buf, (unsigned char *) \"BIP340/nonce0000\", (void*)ndata, 0)) {\n+        memset(sig, 0, sizeof(*sig));\n+        memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+    memset(seckey_tmp, 0, sizeof(seckey_tmp));\n+\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    if (secp256k1_scalar_is_zero(&k)) {\n+        memset(sig, 0, sizeof(*sig));\n+        secp256k1_scalar_clear(&x);\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig->data[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &x);\n+    secp256k1_scalar_add(&e, &e, &k);\n+\n+    secp256k1_scalar_get_b32(&sig->data[32], &e);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&x);\n+\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const secp256k1_schnorrsig *sig, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig->data[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig->data[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig->data[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 221,
      "original_position": 169,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "23c3b0050e9878379cd3028960a506f59550f87b",
      "in_reply_to_id": 381884290,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2020-03-07T14:17:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r389257707",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/389257707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 221,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/391978540",
      "pull_request_review_id": 373987876,
      "id": 391978540,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3ODU0MA==",
      "diff_hunk": "@@ -413,6 +413,80 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 48,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does this mean that if data  == NULL, we use an unmasked key?",
      "created_at": "2020-03-13T00:57:37Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r391978540",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/391978540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/392866730",
      "pull_request_review_id": 375016223,
      "id": 392866730,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjczMA==",
      "diff_hunk": "@@ -413,6 +413,80 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 48,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 391978540,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes. Alternatively we could mask with some static array, but that's unnecessary.",
      "created_at": "2020-03-16T08:58:56Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r392866730",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/392866730"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393165298",
      "pull_request_review_id": 375399064,
      "id": 393165298,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NTI5OA==",
      "diff_hunk": "@@ -413,6 +413,80 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 48,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 391978540,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I that case we should update the BIP to not do the masking when there is no aux?",
      "created_at": "2020-03-16T16:49:02Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r393165298",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393165298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393172853",
      "pull_request_review_id": 375410843,
      "id": 393172853,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3Mjg1Mw==",
      "diff_hunk": "@@ -413,6 +413,80 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 48,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 391978540,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think either way is fine. Right now, if you don't provide an aux, you're not BIP compliant which should be clearly stated in the documentation. If you want to be BIP compliant but have no aux, you can use all 0s as the BIP mentions:\r\n\r\n> If randomness is not available at all at signing time, a simple counter wide enough to not repeat in practice (e.g., 64 bits or wider) and padded with null bytes to a 32 byte-array can be used, or even the constant array with 32 null bytes.",
      "created_at": "2020-03-16T16:58:24Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r393172853",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393172853"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393870224",
      "pull_request_review_id": 376279435,
      "id": 393870224,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3MDIyNA==",
      "diff_hunk": "@@ -0,0 +1,136 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 52,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/square/even",
      "created_at": "2020-03-17T18:02:05Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r393870224",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393870224"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393870729",
      "pull_request_review_id": 376279435,
      "id": 393870729,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3MDcyOQ==",
      "diff_hunk": "@@ -701,6 +734,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 52,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/square/even",
      "created_at": "2020-03-17T18:02:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r393870729",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393870729"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 738,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393871009",
      "pull_request_review_id": 376279435,
      "id": 393871009,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3MTAwOQ==",
      "diff_hunk": "@@ -701,6 +734,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the secret key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting secret key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 141,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/square/even",
      "created_at": "2020-03-17T18:03:22Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r393871009",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393871009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 827,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393871225",
      "pull_request_review_id": 376279435,
      "id": 393871225,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3MTIyNQ==",
      "diff_hunk": "@@ -701,6 +734,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the secret key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting secret key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to\n+ *  the seckey (modulo the group order). Otherwise, tweak32 is added to the\n+ *  negation of the seckey (modulo the group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting secret key would be\n+ *             invalid (only when the tweak is the complement of the secret key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte secret key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_seckey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key (in place) by adding tweak times the generator to it.\n+ *\n+ *  Because the resulting point may have a non-square Y coordinate, it may not",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 162,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/non-square/odd",
      "created_at": "2020-03-17T18:03:44Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r393871225",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/393871225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 848,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/395886539",
      "pull_request_review_id": 378807592,
      "id": 395886539,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NjUzOQ==",
      "diff_hunk": "@@ -0,0 +1,136 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 52,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 393870224,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "thanks, fixed",
      "created_at": "2020-03-20T20:57:50Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r395886539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/395886539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/395886595",
      "pull_request_review_id": 378807654,
      "id": 395886595,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NjU5NQ==",
      "diff_hunk": "@@ -701,6 +734,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 52,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 393870729,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-03-20T20:57:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r395886595",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/395886595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 738,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/395886637",
      "pull_request_review_id": 378807718,
      "id": 395886637,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NjYzNw==",
      "diff_hunk": "@@ -701,6 +734,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the secret key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting secret key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 141,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 393871009,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-03-20T20:58:04Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r395886637",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/395886637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 827,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/395886666",
      "pull_request_review_id": 378807759,
      "id": 395886666,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NjY2Ng==",
      "diff_hunk": "@@ -701,6 +734,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is square. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the secret key of an x-only pubkey by adding a tweak to it. The public\n+ *  key of the resulting secret key will be the same as the output of\n+ *  secp256k1_xonly_pubkey_tweak_add called with the same tweak and corresponding\n+ *  input public key.\n+ *\n+ *  If the public key corresponds to a point with square Y, tweak32 is added to\n+ *  the seckey (modulo the group order). Otherwise, tweak32 is added to the\n+ *  negation of the seckey (modulo the group order).\n+ *\n+ *  Returns: 1 if the tweak was successfully added to seckey\n+ *           0 if the tweak was out of range or the resulting secret key would be\n+ *             invalid (only when the tweak is the complement of the secret key) or\n+ *             seckey is 0.\n+ *\n+ *  Args:      ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  In/Out: seckey: pointer to a 32-byte secret key\n+ *  In:    tweak32: pointer to a 32-byte tweak\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_seckey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tweak an x-only public key (in place) by adding tweak times the generator to it.\n+ *\n+ *  Because the resulting point may have a non-square Y coordinate, it may not",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 162,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 393871225,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-03-20T20:58:08Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r395886666",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/395886666"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 848,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/396262907",
      "pull_request_review_id": 379194071,
      "id": 396262907,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2MjkwNw==",
      "diff_hunk": "@@ -413,6 +413,80 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 48,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 391978540,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What if we force people to provide an `aux`, i.e., abort if they provide `NULL`?",
      "created_at": "2020-03-23T07:55:07Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r396262907",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/396262907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/396268784",
      "pull_request_review_id": 379201405,
      "id": 396268784,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2ODc4NA==",
      "diff_hunk": "@@ -413,6 +413,80 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 48,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 391978540,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could also get it if the user randomized the context, but I think we'll then need to increase some PRF counter in the context which will make it not thread safe :(",
      "created_at": "2020-03-23T08:08:25Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r396268784",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/396268784"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/396283509",
      "pull_request_review_id": 379219671,
      "id": 396283509,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI4MzUwOQ==",
      "diff_hunk": "@@ -413,6 +413,80 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 48,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 391978540,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm, yes, a counter is a good idea (even if the user hasn't randomized the context). On C11 we could use `<stdatomics.h>` to implement a portable atomic counter but I don't think this is possible on C90.",
      "created_at": "2020-03-23T08:37:59Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r396283509",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/396283509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/396290543",
      "pull_request_review_id": 379228156,
      "id": 396290543,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI5MDU0Mw==",
      "diff_hunk": "@@ -413,6 +413,80 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 48,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "819c3a6c1599ae35a0b6d163393d2030a2162a5b",
      "in_reply_to_id": 391978540,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could use https://gcc.gnu.org/onlinedocs/gcc-4.9.3/gcc/_005f_005fatomic-Builtins.html#g_t_005f_005fatomic-Builtins\r\nand https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-functions?redirectedfrom=MSDN#interlocked-functions\r\n\r\nBut I don't know what affect will it have on embedded systems.",
      "created_at": "2020-03-23T08:50:36Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r396290543",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/396290543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/397849205",
      "pull_request_review_id": 381141406,
      "id": 397849205,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0OTIwNQ==",
      "diff_hunk": "@@ -785,6 +792,74 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *sign, const secp256k1_pubkey *pubkey) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    *xonly_pubkey = *(secp256k1_xonly_pubkey *) pubkey;\n+\n+    secp256k1_ec_pubkey_absolute(ctx, (secp256k1_pubkey *) xonly_pubkey, sign);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_to_pubkey(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_xonly_pubkey *xonly_pubkey, int sign) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+\n+    *pubkey = *(secp256k1_pubkey *) xonly_pubkey;\n+    if (sign) {\n+        return secp256k1_ec_pubkey_negate(ctx, pubkey);\n+    }\n+    return 1;\n+}\n+\n+int secp256k1_xonly_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey32, const unsigned char *tweak32) {\n+    secp256k1_ge ge;\n+    secp256k1_pubkey pubkey;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_ec_pubkey_create(ctx, &pubkey, seckey32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_load(ctx, &ge, &pubkey);\n+    if (!secp256k1_fe_is_quad_var(&ge.y)) {\n+        if (!secp256k1_ec_privkey_negate(ctx, seckey32)) {\n+            return 0;\n+        }\n+    }\n+\n+    return secp256k1_ec_privkey_tweak_add(ctx, seckey32, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    *output_pubkey = *(secp256k1_pubkey *)internal_pubkey;\n+    return secp256k1_ec_pubkey_tweak_add(ctx, output_pubkey, tweak32);\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_verify(const secp256k1_context* ctx, const secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {",
      "path": "src/secp256k1.c",
      "position": null,
      "original_position": 101,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2e4ed392e1fd8cb7c64787bde9b67ddc0b463e3d",
      "in_reply_to_id": 327874467,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "FYI it's documented that you *should* serialize `secp256k1_pubkey` before comparing https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h#L64\r\n\r\nEDIT: Not really related to what you're doing, just a comment on `Comparing via memcmp should be fine`. internally it's obviously fine",
      "created_at": "2020-03-25T13:24:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r397849205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/397849205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 849,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/399693585",
      "pull_request_review_id": 383337167,
      "id": 399693585,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY5MzU4NQ==",
      "diff_hunk": "@@ -703,6 +736,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the secret key of an x-only pubkey by adding a tweak to it. The public",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 136,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "372c4555cac1d2cba747ea691006876818c6adef",
      "in_reply_to_id": null,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "which \"x-only pubkey\"? should it say \"seckey\"?",
      "created_at": "2020-03-28T18:26:08Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r399693585",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/399693585"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 824,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/399694481",
      "pull_request_review_id": 383337872,
      "id": 399694481,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY5NDQ4MQ==",
      "diff_hunk": "@@ -703,6 +736,170 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     size_t n\n ) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object.\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined.\n+ *  In: input32: pointer to a serialized xonly public key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key.\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute the xonly public key for a secret key. Same as ec_pubkey_create, but\n+ *  for xonly public keys.\n+ *\n+ *  Returns: 1 if secret was valid, public key stores\n+ *           0 if secret was invalid, try again\n+ *\n+ *  Args:   ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: pubkey: pointer to the created xonly public key (cannot be NULL)\n+ *  In:  seckey: pointer to a 32-byte private key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *         is_negated: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by `xonly_pubkey` is the negation of `pubkey`\n+ *                     and set to 0 otherwise. (can be NULL)\n+ *  In:       pubkey: pointer to a public key that is converted (cannot be\n+ *                    NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *is_negated,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak the secret key of an x-only pubkey by adding a tweak to it. The public",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 136,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "372c4555cac1d2cba747ea691006876818c6adef",
      "in_reply_to_id": 399693585,
      "user": {
        "login": "ysangkok",
        "id": 284023,
        "node_id": "MDQ6VXNlcjI4NDAyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/284023?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ysangkok",
        "html_url": "https://github.com/ysangkok",
        "followers_url": "https://api.github.com/users/ysangkok/followers",
        "following_url": "https://api.github.com/users/ysangkok/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ysangkok/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ysangkok/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ysangkok/subscriptions",
        "organizations_url": "https://api.github.com/users/ysangkok/orgs",
        "repos_url": "https://api.github.com/users/ysangkok/repos",
        "events_url": "https://api.github.com/users/ysangkok/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ysangkok/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It is weird to reference a pubkey, that the user may not even have generated yet. This function takes no pubkey arguments.",
      "created_at": "2020-03-28T18:34:44Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r399694481",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/399694481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 824,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429384780",
      "pull_request_review_id": 417094764,
      "id": 429384780,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4NDc4MA==",
      "diff_hunk": "@@ -76,6 +76,67 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubke\n     const secp256k1_pubkey *pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n \n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when\n+ *                       converting the output_pubkey of\n+ *                       secp256k1_xonly_pubkey_tweak_add to an xonly_pubkey\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_test(",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 57,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "7a3acdcef9207715b332da9d89e85e2b182a216f",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: add `add` in the name here like the commit name suggests.",
      "created_at": "2020-05-22T18:02:12Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r429384780",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429384780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429405121",
      "pull_request_review_id": 417094764,
      "id": 429405121,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNTEyMQ==",
      "diff_hunk": "@@ -11,6 +11,80 @@\n #include \"include/secp256k1_schnorrsig.h\"\n #include \"hash.h\"\n \n-/* TODO */\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, \"BIP340/nonce0000\", 16) == 0) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 61,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "bb888e4f6328a2936b416f2efb1199772484e5c1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps it's slightly cleaner to pad with \\x00 bytes, and state in `secp256k1_nonce_function_bip340_sha256_tagged`'s documentation that it uses the `algo16` argument (after removing trailing \\x00 bytes) as tag? That would avoid special-casing the behaviour for one specific tag (and only having it be an optimization).",
      "created_at": "2020-05-22T18:52:58Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r429405121",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429405121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429414721",
      "pull_request_review_id": 417094764,
      "id": 429414721,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxNDcyMQ==",
      "diff_hunk": "@@ -1,9 +1,9 @@\n bench_inv\n bench_ecdh\n bench_ecmult\n+bench_schnorrsig\n bench_sign\n bench_verify\n-bench_schnorr_verify",
      "path": ".gitignore",
      "position": 7,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ccb23e329d34e6717528c81c3bed76c7a45c547b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good thing this very dangerous oversight in the existing code is fixed!",
      "created_at": "2020-05-22T19:13:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r429414721",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429414721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 6,
      "original_line": 6,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429416134",
      "pull_request_review_id": 417094764,
      "id": 429416134,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxNjEzNA==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(",
      "path": "include/secp256k1_extrakeys.h",
      "position": 114,
      "original_position": 113,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ccb23e329d34e6717528c81c3bed76c7a45c547b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Any particular reason why this returns a secp256k1_pubkey instead of an xonly_pubkey + parity flag directly?",
      "created_at": "2020-05-22T19:17:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r429416134",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429416134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 114,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429426845",
      "pull_request_review_id": 417094764,
      "id": 429426845,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNjg0NQ==",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig *sig,\n+    const unsigned char *msg32,\n+    const unsigned char *seckey,\n+    secp256k1_nonce_function noncefp,\n+    void *ndata",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 88,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "6a7ee8a86281ef90c28ef65d155eeff2ae665ac9",
      "in_reply_to_id": 371027220,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this is resolved now the function takes a `secp256k1_keypair` as input.",
      "created_at": "2020-05-22T19:45:46Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r429426845",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/429426845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/434068314",
      "pull_request_review_id": 422930203,
      "id": 434068314,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2ODMxNA==",
      "diff_hunk": "@@ -1,9 +1,9 @@\n bench_inv\n bench_ecdh\n bench_ecmult\n+bench_schnorrsig\n bench_sign\n bench_verify\n-bench_schnorr_verify",
      "path": ".gitignore",
      "position": 7,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ccb23e329d34e6717528c81c3bed76c7a45c547b",
      "in_reply_to_id": 429414721,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To the moon!",
      "created_at": "2020-06-02T18:00:01Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r434068314",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/434068314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 6,
      "original_line": 6,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/435781346",
      "pull_request_review_id": 425114948,
      "id": 435781346,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MTM0Ng==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(",
      "path": "include/secp256k1_extrakeys.h",
      "position": 114,
      "original_position": 113,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ccb23e329d34e6717528c81c3bed76c7a45c547b",
      "in_reply_to_id": 429416134,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The idea was to convert to xonly_pubkeys as late as possible because many operations on xonly_pubkeys would need the parity bit as well and it's annoying to keep track of both instead of just using a normal pubkey. Moreover, if someone would want to use the result of tweak_add with a function that takes normal pubkeys, that wouldn't be easy to do because we don't have a conversion function (xonly_pk, parity) -> pubkey.\r\n\r\nBut on the other hand there isn't really an operation at this point that would be more common than just using the only key after tweak_add, so I'm tending towards changing this back to output an xonly key.",
      "created_at": "2020-06-05T08:51:20Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r435781346",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/435781346"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 114,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/435781621",
      "pull_request_review_id": 425115292,
      "id": 435781621,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MTYyMQ==",
      "diff_hunk": "@@ -76,6 +76,67 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubke\n     const secp256k1_pubkey *pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n \n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when\n+ *                       converting the output_pubkey of\n+ *                       secp256k1_xonly_pubkey_tweak_add to an xonly_pubkey\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_test(",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 57,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "7a3acdcef9207715b332da9d89e85e2b182a216f",
      "in_reply_to_id": 429384780,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-06-05T08:51:47Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r435781621",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/435781621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/435781854",
      "pull_request_review_id": 425115617,
      "id": 435781854,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MTg1NA==",
      "diff_hunk": "@@ -11,6 +11,80 @@\n #include \"include/secp256k1_schnorrsig.h\"\n #include \"hash.h\"\n \n-/* TODO */\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, \"BIP340/nonce0000\", 16) == 0) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 61,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "bb888e4f6328a2936b416f2efb1199772484e5c1",
      "in_reply_to_id": 429405121,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "good idea, done",
      "created_at": "2020-06-05T08:52:16Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r435781854",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/435781854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436289819",
      "pull_request_review_id": 425759322,
      "id": 436289819,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4OTgxOQ==",
      "diff_hunk": "@@ -0,0 +1,210 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_test(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+/* Always initializes seckey and ge with some values, even if this function\n+ * returns 0. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret = 1;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    if (sk != NULL) {\n+        secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+        ret &= !secp256k1_scalar_is_zero(sk);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 122,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, I'm not sure if we care, just some weird inconsistency,\r\ncurrently if you use a zeroed out `secp256k1_pubkey` it will call the callback and you'll get an abort: https://github.com/bitcoin-core/secp256k1/blob/a39c2b09de304b8f24716b59219ae37c2538c242/src/secp256k1.c#L254\r\n\r\nBut here if only the seckey part of keypair is zeroed out it will gracefully fail",
      "created_at": "2020-06-06T18:25:38Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436289819",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436289819"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436290667",
      "pull_request_review_id": 425759322,
      "id": 436290667,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MDY2Nw==",
      "diff_hunk": "@@ -0,0 +1,210 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_test(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+/* Always initializes seckey and ge with some values, even if this function\n+ * returns 0. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret = 1;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    if (sk != NULL) {\n+        secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+        ret &= !secp256k1_scalar_is_zero(sk);\n+        secp256k1_scalar_cmov(sk, &secp256k1_scalar_one, !ret);\n+    }\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECK's it. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    if (!secp256k1_pubkey_load(ctx, pk, pubkey)) {\n+        *pk = secp256k1_ge_const_g;\n+        ret = 0;\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_pub_xonly(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pubkey_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    secp256k1_ge_even_y(&pk, pubkey_parity);\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+        secp256k1_ge_neg(&pk, &pk);\n+    }\n+\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n+    secp256k1_scalar_cmov(&sk, &secp256k1_scalar_zero, !ret);\n+    ret &= secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 199,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "On one hand `seckey_tweak` is constant time with regards both to the secret and the tweak.\r\nOn the other hand `pubkey_tweak` is not constant time with regards to the tweak.\r\n\r\nDo we want `keypair_xonly_tweak_add` to be ct with regards to the tweak or not?",
      "created_at": "2020-06-06T18:38:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436290667",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436290667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 197,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 237,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436292191",
      "pull_request_review_id": 425759322,
      "id": 436292191,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MjE5MQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In the current RFC6979 we use the full 16 bytes, why here different?\r\nand if we do use this, why not just call `strnlen(2)`?",
      "created_at": "2020-06-06T18:58:55Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436292191",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436292191"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436293394",
      "pull_request_review_id": 425759322,
      "id": 436293394,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MzM5NA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 142,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You can call `secp256k1_fe_normalize_var` here",
      "created_at": "2020-06-06T19:15:43Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436293394",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436293394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436293407",
      "pull_request_review_id": 425759322,
      "id": 436293407,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MzQwNw==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 148,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "also here",
      "created_at": "2020-06-06T19:15:49Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436293407",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436293407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436293713",
      "pull_request_review_id": 425759322,
      "id": 436293713,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MzcxMw==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 151,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe move this to the end with the rest of the cleanup?",
      "created_at": "2020-06-06T19:18:52Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436293713",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436293713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436293904",
      "pull_request_review_id": 425759322,
      "id": 436293904,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MzkwNA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 145,
      "original_position": 152,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think that's a problem, if `noncefp` failed then `buf` might be uninitialized, either we treat the return value of `noncefp` as public data(like ecdsa_sign) and we skip the signing process, or we need to cmov into it.",
      "created_at": "2020-06-06T19:21:38Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436293904",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436293904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436294150",
      "pull_request_review_id": 425759322,
      "id": 436294150,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NDE1MA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 165,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You can call `secp256k1_fe_normalize_var` here too",
      "created_at": "2020-06-06T19:25:18Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436294150",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436294150"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436295176",
      "pull_request_review_id": 425759322,
      "id": 436295176,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTE3Ng==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The BIP says that these can't be 0 either, (`fail if r ≥ p` and ` fail if s ≥ n`)\r\nhaving `rx = 0` won't help an attacker because you make sure that `rj` isn't infinity when returning.\r\nbut having `s = 0` allows you to get `rj = -e*pkj` but then you have the problem you need to solve `-e*pkj` to get your `r` but you need the `r` to produce `e`, so this relies on the properties of the hash function",
      "created_at": "2020-06-06T19:39:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436295176",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436295176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436295399",
      "pull_request_review_id": 425759322,
      "id": 436295399,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NTM5OQ==",
      "diff_hunk": "@@ -95,6 +108,28 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret);\n \n+    /* Test keypair_create and keypair_xonly_tweak_add. */\n+#if ENABLE_MODULE_EXTRAKEYS\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    /* The tweak is not treated as a secret in keypair_tweak_add */\n+    VALGRIND_MAKE_MEM_DEFINED(msg, 32);\n+    ret &= secp256k1_keypair_xonly_tweak_add(ctx, &keypair, msg);",
      "path": "src/valgrind_ctime_test.c",
      "position": null,
      "original_position": 49,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "why bitwise AND here?",
      "created_at": "2020-06-06T19:42:32Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436295399",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436295399"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436406938",
      "pull_request_review_id": 425857831,
      "id": 436406938,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNjkzOA==",
      "diff_hunk": "@@ -0,0 +1,210 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_test(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+/* Always initializes seckey and ge with some values, even if this function\n+ * returns 0. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret = 1;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    if (sk != NULL) {\n+        secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+        ret &= !secp256k1_scalar_is_zero(sk);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 122,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436289819,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The thinking was that that both parts are always zeroed together. I added a commit to ARG_CHECK both parts. The commit also declassifies the result of `secp256k1_scalar_is_zero(sk)` because that can only happen if a keypair function failed (which zeroes the keypair) and its return value is ignored.",
      "created_at": "2020-06-07T22:16:44Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436406938",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436406938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436406955",
      "pull_request_review_id": 425857843,
      "id": 436406955,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNjk1NQ==",
      "diff_hunk": "@@ -0,0 +1,210 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(output_pubkey != NULL);\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_test(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+/* Always initializes seckey and ge with some values, even if this function\n+ * returns 0. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret = 1;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    if (sk != NULL) {\n+        secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+        ret &= !secp256k1_scalar_is_zero(sk);\n+        secp256k1_scalar_cmov(sk, &secp256k1_scalar_one, !ret);\n+    }\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECK's it. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    if (!secp256k1_pubkey_load(ctx, pk, pubkey)) {\n+        *pk = secp256k1_ge_const_g;\n+        ret = 0;\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_pub_xonly(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pubkey_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    secp256k1_ge_even_y(&pk, pubkey_parity);\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+        secp256k1_ge_neg(&pk, &pk);\n+    }\n+\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n+    secp256k1_scalar_cmov(&sk, &secp256k1_scalar_zero, !ret);\n+    ret &= secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 199,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436290667,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's not ct because we reuse the existing pubkey_tweak_add machinery atm. However, it's easy to imagine scenarios where the tweak is secret. I wonder if it makes sense to do this in a separate PR?",
      "created_at": "2020-06-07T22:16:56Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436406955",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436406955"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 197,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 237,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407019",
      "pull_request_review_id": 425857897,
      "id": 436407019,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzAxOQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 83,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436292191,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "See https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r429405121 and I didn't want to figure out where strnlen is available vs. just a loop.",
      "created_at": "2020-06-07T22:17:45Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436407019",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407029",
      "pull_request_review_id": 425857903,
      "id": 436407029,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzAyOQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 142,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436293394,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed",
      "created_at": "2020-06-07T22:17:50Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436407029",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407035",
      "pull_request_review_id": 425857910,
      "id": 436407035,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzAzNQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 148,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436293407,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed",
      "created_at": "2020-06-07T22:17:56Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436407035",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407039",
      "pull_request_review_id": 425857922,
      "id": 436407039,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzAzOQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 151,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436293713,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Okay",
      "created_at": "2020-06-07T22:18:01Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436407039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407058",
      "pull_request_review_id": 425857938,
      "id": 436407058,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzA1OA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 145,
      "original_position": 152,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436293904,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch. Added commit that initializes `buf` with 0.",
      "created_at": "2020-06-07T22:18:20Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436407058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407063",
      "pull_request_review_id": 425857944,
      "id": 436407063,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzA2Mw==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 165,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436294150,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed",
      "created_at": "2020-06-07T22:18:26Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436407063",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407063"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407080",
      "pull_request_review_id": 425857961,
      "id": 436407080,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzA4MA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295176,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The BIP allows s = 0 and r = 0. Also solving `rj = -e*pkj` isn't easier than `rj - s*G = -e*pkj` without the secret key or am I misunderstanding the attack scenario?",
      "created_at": "2020-06-07T22:18:43Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436407080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407089",
      "pull_request_review_id": 425857972,
      "id": 436407089,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzA4OQ==",
      "diff_hunk": "@@ -95,6 +108,28 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret);\n \n+    /* Test keypair_create and keypair_xonly_tweak_add. */\n+#if ENABLE_MODULE_EXTRAKEYS\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    /* The tweak is not treated as a secret in keypair_tweak_add */\n+    VALGRIND_MAKE_MEM_DEFINED(msg, 32);\n+    ret &= secp256k1_keypair_xonly_tweak_add(ctx, &keypair, msg);",
      "path": "src/valgrind_ctime_test.c",
      "position": null,
      "original_position": 49,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295399,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's unnecessary. Fixed",
      "created_at": "2020-06-07T22:18:52Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436407089",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436407089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436509232",
      "pull_request_review_id": 425981713,
      "id": 436509232,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwOTIzMg==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 145,
      "original_position": 152,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436293904,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's better, now realized that \"cmov into it\" won't help because of #754 😅",
      "created_at": "2020-06-08T07:41:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436509232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436509232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436512840",
      "pull_request_review_id": 425986660,
      "id": 436512840,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUxMjg0MA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295176,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it is, because in `rj - s*G = -e*pkj`, you want to find the *scalar* `s`, which is DLP.\r\nbut in `rj = -e*pkj` you want to find `rj` which is a point. this isn't DLP, it's still \"hard\" though because `rj` should be hashed inside of `e`.\r\n\r\nabout the bip, doesn't this say that zeroes should fail? (if `r=p` or `s=n`)\r\n```\r\nLet r = int(sig[0:32]); fail if r ≥ p.\r\nLet s = int(sig[32:64]); fail if s ≥ n.\r\n```\r\n\r\n(I have deja vu about this discussion but I can't find it in the review history hehe )",
      "created_at": "2020-06-08T07:49:03Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r436512840",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/436512840"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/437483606",
      "pull_request_review_id": 427231938,
      "id": 437483606,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4MzYwNg==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295176,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't see how forging is supposed to be easier for s = 0 than for s != 0. If the hash function is \"broken\", you can forge without solving DLP but you don't need s = 0 for this. Fix any s and solve sG=R+H(P,R,m)P for R. \r\n\r\n\r\n> about the bip, doesn't this say that zeroes should fail? (if `r=p` or `s=n`)\r\n\r\nIt holds that `s = int(0x00...00) = 0 <= n`.",
      "created_at": "2020-06-09T14:49:32Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r437483606",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/437483606"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/437486941",
      "pull_request_review_id": 427236208,
      "id": 437486941,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4Njk0MQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295176,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ha, you're right, I don't know how I missed that.\r\n\r\n>It holds that `s = int(0x00...00) = 0 <= n`.\r\n\r\nso you're saying that `0 <= n`? even though it's a scalar so it's mod n (so `0 mod n == n mod n`)",
      "created_at": "2020-06-09T14:53:41Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r437486941",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/437486941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/437490704",
      "pull_request_review_id": 427243037,
      "id": 437490704,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ5MDcwNA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295176,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`s` is an unsigned integer here in the pseudocode.\r\n\r\n\"The function int(x), where x is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is x.\"",
      "created_at": "2020-06-09T14:58:39Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r437490704",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/437490704"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/437494239",
      "pull_request_review_id": 427251148,
      "id": 437494239,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ5NDIzOQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295176,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I don't see how forging is supposed to be easier for s = 0 than for s != 0. If the hash function is \"broken\", you can forge without solving DLP but you don't need s = 0 for this. Fix any s and solve sG=R+H(P,R,m)P for R.\r\n\r\nOkay strictly speaking, one can think of a failure mode of the hash function where this is easier to solve for s = 0, but then I don't see that this failure mode is more likely than any corresponding failure mode some other fixed s != 0.",
      "created_at": "2020-06-09T15:03:17Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r437494239",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/437494239"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/438760858",
      "pull_request_review_id": 428879106,
      "id": 438760858,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MDg1OA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295176,
      "user": {
        "login": "LLFourn",
        "id": 3734083,
        "node_id": "MDQ6VXNlcjM3MzQwODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3734083?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LLFourn",
        "html_url": "https://github.com/LLFourn",
        "followers_url": "https://api.github.com/users/LLFourn/followers",
        "following_url": "https://api.github.com/users/LLFourn/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LLFourn/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LLFourn/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LLFourn/subscriptions",
        "organizations_url": "https://api.github.com/users/LLFourn/orgs",
        "repos_url": "https://api.github.com/users/LLFourn/repos",
        "events_url": "https://api.github.com/users/LLFourn/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LLFourn/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> > I don't see how forging is supposed to be easier for s = 0 than for s != 0. If the hash function is \"broken\", you can forge without solving DLP but you don't need s = 0 for this. Fix any s and solve sG=R+H(P,R,m)P for R.\r\n> \r\n> Okay strictly speaking, one can think of a failure mode of the hash function where this is easier to solve for s = 0, but then I don't see that this failure mode is more likely than any corresponding failure mode some other fixed s != 0.\r\n\r\nActually, strictly speaking, one can't! As it still has not been garbage collected from when I was looking at Taproot hash function requirements, allow me to recount the formal hash function requirements for *key-only* Schnorr unforgeability from Neven et al[1]: The adversary must be unable to break the *random prefix-preimage* (rpp) security of the hash. This is necessary and sufficient in the generic group model. In the rpp game, the adversary is allowed to chose the image `c` and then is given a random challenge prefix `R`. They win the game if they can output `m` such that `H(R||m) == c`.\r\n\r\nTo see that rpp is necessary and that there is no value for `s` for which the scheme is safer against a hash break, consider that with a rrp solver `A` we can forge a signature with the following algorithm (ignoring key-prefixing for simplicity):\r\n```\r\nForge(X):\r\n1. c <--$ A\r\n2. choose any s you want\r\n3. R <-- sG - cX\r\n4. m <--$ A(R)\r\n5. return (R,s),m\r\n```\r\nThus if the hash function breaks in any way that makes signatures forgeable then rpp must be broken as well (as it is sufficient) therefore an efficient `A`  exists and they will be forgeable for any choice of `s`. They are not necessarily easily forgeable for any value of `c`. Perhaps if finding a pre-image for 0 was easier than other values then banning `c=0` would help (but it would be better to just stop using the hash function in this case).\r\n\r\n [1] http://www.neven.org/papers/schnorr.pdf\r\n",
      "created_at": "2020-06-11T12:56:09Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r438760858",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/438760858"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/443199085",
      "pull_request_review_id": 434483902,
      "id": 443199085,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5OTA4NQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    secp256k1_fe_normalize(&pk.y);\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_normalize(&pk.x);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata, 0);\n+    memset(seckey, 0, sizeof(seckey));\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 209,
      "original_position": 213,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cecda26efe0c17181b5ba327eaabf9ad425e2e79",
      "in_reply_to_id": 436295176,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, that's super interesting.",
      "created_at": "2020-06-21T09:09:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r443199085",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/443199085"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 202,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/443199863",
      "pull_request_review_id": 434484548,
      "id": 443199863,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5OTg2Mw==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when\n+ *                       converting the output_pubkey of\n+ *                       secp256k1_xonly_pubkey_tweak_add to an xonly_pubkey\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_test(",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 143,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe `test` is not a great name because we only use this to refer functional tests so far, and it's somewhat confusing. Suggestions: `check`, `verify`. Maybe `secp256k1_xonly_pubkey_tweak_add_check` or even `secp256k1_xonly_pubkey_check_tweak_add`, which I like slightly more. That's still our `datatype_operation` style because tweak is not really a datatype. This is used in a function `CheckPayToContract` in https://github.com/bitcoin/bitcoin/pull/17977/commits/a9f418aeb0d31acadd0d5114158fb1fcb9094f40#diff-2c33d0ff0ed53b0902e4af9a745a152fR181 by the way.\r\n\r\n\r\nSorry for nitpicking this single thing right now without anything else but I stumbled upon this just now and probably will forget about otherwise. ",
      "created_at": "2020-06-21T09:18:40Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r443199863",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/443199863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/443200206",
      "pull_request_review_id": 434484829,
      "id": 443200206,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzIwMDIwNg==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when\n+ *                       converting the output_pubkey of\n+ *                       secp256k1_xonly_pubkey_tweak_add to an xonly_pubkey\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_test(",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 143,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 443199863,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It was originally `verify` and I didn't like it because it could suggest that it actually verifies the commitment, which it isn't https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r347126158",
      "created_at": "2020-06-21T09:23:26Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r443200206",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/443200206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/443211461",
      "pull_request_review_id": 434494342,
      "id": 443211461,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzIxMTQ2MQ==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when\n+ *                       converting the output_pubkey of\n+ *                       secp256k1_xonly_pubkey_tweak_add to an xonly_pubkey\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_test(",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 143,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 443199863,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh I see. I think `check` is then really the best.",
      "created_at": "2020-06-21T11:47:11Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r443211461",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/443211461"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/453986978",
      "pull_request_review_id": 447659118,
      "id": 453986978,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4Njk3OA==",
      "diff_hunk": "@@ -0,0 +1,8 @@\n+include_HEADERS += include/secp256k1_schnorrsig.h\n+noinst_HEADERS += src/modules/schnorrsig/main_impl.h\n+noinst_HEADERS += src/modules/schnorrsig/tests_impl.h\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_schnorrsig\n+bench_schnorrsig_SOURCES = src/bench_schnorrsig.c\n+bench_schnorrsig_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n+endif",
      "path": "src/modules/schnorrsig/Makefile.am.include",
      "position": null,
      "original_position": 8,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "missing ending newline",
      "created_at": "2020-07-13T22:38:15Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r453986978",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/453986978"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454546272",
      "pull_request_review_id": 448344438,
      "id": 454546272,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0NjI3Mg==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 118,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "missing `SECP256K1_ARG_NONNULL(3)`",
      "created_at": "2020-07-14T18:07:08Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454546272",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454546272"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454547695",
      "pull_request_review_id": 448344438,
      "id": 454547695,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0NzY5NQ==",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument. This can protect signature schemes with\n+ *  key-prefixed challenge hash inputs against reusing the nonce when signing\n+ *  with the wrong precomputed pubkey.\n+ *\n+ *  In:  xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32 (will not be NULL)\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data,\n+    unsigned int attempt\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL and the attempt argument must be 0, otherwise the\n+ *  function will fail and return 0. The hash will be tagged with algo16 after\n+ *  removing all terminating null bytes. Therefore, to create BIP-340 compliant\n+ *  signatures, algo16 must be set to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 78,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't find `(can be Null)` helpful since I quickly scan for `(cannot be NULL)` and these look very close",
      "created_at": "2020-07-14T18:09:41Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454547695",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454547695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454547778",
      "pull_request_review_id": 448344438,
      "id": 454547778,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0Nzc3OA==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when\n+ *                       converting the output_pubkey of\n+ *                       secp256k1_xonly_pubkey_tweak_add to an xonly_pubkey\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_test(\n+    const secp256k1_context* ctx,\n+    const unsigned char *output_pubkey32,\n+    int output_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, its value is undefined. (cannot\n+ *               be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, its value is undefined (cannot be NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).",
      "path": "include/secp256k1_extrakeys.h",
      "position": 195,
      "original_position": 191,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't find `(can be Null)` helpful since I quickly scan for `(cannot be NULL)` and these look very close",
      "created_at": "2020-07-14T18:09:49Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454547778",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454547778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 195,
      "original_line": 195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454547845",
      "pull_request_review_id": 448344438,
      "id": 454547845,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0Nzg0NQ==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 80,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't find `(can be Null)` helpful since I quickly scan for `(cannot be NULL)` and these look very close",
      "created_at": "2020-07-14T18:09:55Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454547845",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454547845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454565878",
      "pull_request_review_id": 448344438,
      "id": 454565878,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2NTg3OA==",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument. This can protect signature schemes with\n+ *  key-prefixed challenge hash inputs against reusing the nonce when signing\n+ *  with the wrong precomputed pubkey.\n+ *\n+ *  In:  xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32 (will not be NULL)\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data,\n+    unsigned int attempt\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 53,
      "original_position": 39,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Internally it always seems to treat it as a 16 byte array, probably should state this since it's not an obvious length naming aside.",
      "created_at": "2020-07-14T18:40:50Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454565878",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454565878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454569444",
      "pull_request_review_id": 448344438,
      "id": 454569444,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTQ0NA==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "just curious if there's a reason for definition on this line instead of above",
      "created_at": "2020-07-14T18:47:08Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454569444",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454569444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454584745",
      "pull_request_review_id": 448391884,
      "id": 454584745,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4NDc0NQ==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 136,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "micro-nitting: Then naming scheme for this arg seems very taproot-specific.",
      "created_at": "2020-07-14T19:14:54Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454584745",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454584745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454591253",
      "pull_request_review_id": 448399577,
      "id": 454591253,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5MTI1Mw==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 118,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454546272,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You mean SECP256K1_ARG_NONNULL(4)",
      "created_at": "2020-07-14T19:26:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454591253",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454591253"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454592378",
      "pull_request_review_id": 448400992,
      "id": 454592378,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5MjM3OA==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 118,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454546272,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "err right",
      "created_at": "2020-07-14T19:28:25Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r454592378",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/454592378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661079",
      "pull_request_review_id": 450940772,
      "id": 456661079,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2MTA3OQ==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when\n+ *                       converting the output_pubkey of\n+ *                       secp256k1_xonly_pubkey_tweak_add to an xonly_pubkey\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_test(",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 143,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 443199863,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Renamed to `secp256k1_xonly_pubkey_tweak_add_check`",
      "created_at": "2020-07-17T20:32:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456661079",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661079"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661188",
      "pull_request_review_id": 450940909,
      "id": 456661188,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2MTE4OA==",
      "diff_hunk": "@@ -0,0 +1,8 @@\n+include_HEADERS += include/secp256k1_schnorrsig.h\n+noinst_HEADERS += src/modules/schnorrsig/main_impl.h\n+noinst_HEADERS += src/modules/schnorrsig/tests_impl.h\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_schnorrsig\n+bench_schnorrsig_SOURCES = src/bench_schnorrsig.c\n+bench_schnorrsig_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n+endif",
      "path": "src/modules/schnorrsig/Makefile.am.include",
      "position": null,
      "original_position": 8,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 453986978,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-07-17T20:33:07Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456661188",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661188"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661237",
      "pull_request_review_id": 450940980,
      "id": 456661237,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2MTIzNw==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 118,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454546272,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-07-17T20:33:16Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456661237",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661237"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661316",
      "pull_request_review_id": 450941082,
      "id": 456661316,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2MTMxNg==",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument. This can protect signature schemes with\n+ *  key-prefixed challenge hash inputs against reusing the nonce when signing\n+ *  with the wrong precomputed pubkey.\n+ *\n+ *  In:  xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32 (will not be NULL)\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data,\n+    unsigned int attempt\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL and the attempt argument must be 0, otherwise the\n+ *  function will fail and return 0. The hash will be tagged with algo16 after\n+ *  removing all terminating null bytes. Therefore, to create BIP-340 compliant\n+ *  signatures, algo16 must be set to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 78,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454547695,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm, do you have a suggestion what to do instead? This is the same as what include/secp256k1.h does.",
      "created_at": "2020-07-17T20:33:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456661316",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661458",
      "pull_request_review_id": 450941258,
      "id": 456661458,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2MTQ1OA==",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument. This can protect signature schemes with\n+ *  key-prefixed challenge hash inputs against reusing the nonce when signing\n+ *  with the wrong precomputed pubkey.\n+ *\n+ *  In:  xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32 (will not be NULL)\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data,\n+    unsigned int attempt\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 53,
      "original_position": 39,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454565878,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We say that this is the \"same as secp256k1_nonce function except [...]\" and the doc of `secp256k1_nonce_function` specifies \"algo16:    pointer to a 16-byte array describing the signature\". However, I noticed that we can drop the unused attempt argument. Then it makes more sense to copy and adapt the doc. Done.",
      "created_at": "2020-07-17T20:33:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456661458",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661458"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661607",
      "pull_request_review_id": 450941410,
      "id": 456661607,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2MTYwNw==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len;\n+        /* Remove terminating null bytes */\n+        algo16_len = 16;",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454569444,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There's none. Fixed.",
      "created_at": "2020-07-17T20:34:12Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456661607",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661868",
      "pull_request_review_id": 450941777,
      "id": 456661868,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2MTg2OA==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 136,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454584745,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't see how the naming is taproot-specific. You could also call it odd_y or something but that's unnecessarily technical. The thing I want to convey is that this belongs to the `output_pk`.",
      "created_at": "2020-07-17T20:34:49Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456661868",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456661868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456666328",
      "pull_request_review_id": 450947341,
      "id": 456666328,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NjMyOA==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 136,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454584745,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh sorry, I meant `output_*` as a whole.",
      "created_at": "2020-07-17T20:45:52Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456666328",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456666328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456666682",
      "pull_request_review_id": 450947774,
      "id": 456666682,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NjY4Mg==",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument. This can protect signature schemes with\n+ *  key-prefixed challenge hash inputs against reusing the nonce when signing\n+ *  with the wrong precomputed pubkey.\n+ *\n+ *  In:  xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32 (will not be NULL)\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data,\n+    unsigned int attempt\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL and the attempt argument must be 0, otherwise the\n+ *  function will fail and return 0. The hash will be tagged with algo16 after\n+ *  removing all terminating null bytes. Therefore, to create BIP-340 compliant\n+ *  signatures, algo16 must be set to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 78,
      "original_position": 64,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454547695,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Well in most places in same files it looks like it's simply not stated at all. Not a big deal.",
      "created_at": "2020-07-17T20:46:41Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456666682",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456666682"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456672072",
      "pull_request_review_id": 450954531,
      "id": 456672072,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MjA3Mg==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 136,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454584745,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh right! Perhaps that holds even more for `internal_pubkey`. But given what `tweak_add` does, I think those names are okay even outside of the taproot context with the benefit that they're more understandable than alternatives *in* the taproot context.",
      "created_at": "2020-07-17T21:00:05Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456672072",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456672072"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456940698",
      "pull_request_review_id": 451153752,
      "id": 456940698,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MDY5OA==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 104,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Will be set to an invalid value if this function returns 0\": I suspect this comment applies to another argument, as I doubt it'll overwrite an input-only argument?",
      "created_at": "2020-07-19T18:38:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456940698",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456940698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456942014",
      "pull_request_review_id": 451153752,
      "id": 456942014,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MjAxNA==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will\n+ *                       be set to an invalid value if this function returns 0\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Tests that output_pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output_pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output_pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output_pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output_pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the pk_parity value that is returned when",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 136,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454584745,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It took me a few reads before I could parse this sentence - the \"that is returned\" made it sound like the return value of _this_ function was affected by this argument.\r\n\r\nAttempt at improving: \"The expected parity of the output public key (whose serialization is passed in `output_pubkey32`). This must match the pk_parity value returned by secp256k1_xonly_pubkey_tweak_add when the output was created, or verification will fail.\"",
      "created_at": "2020-07-19T18:51:44Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456942014",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456942014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456942102",
      "pull_request_review_id": 451153752,
      "id": 456942102,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MjEwMg==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 31,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As this style function pointer isn't compatible with our ECDSA code, is mentioning it relevant?",
      "created_at": "2020-07-19T18:52:37Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456942102",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456942102"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456942579",
      "pull_request_review_id": 451153752,
      "id": 456942579,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MjU3OQ==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and\n+ *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg32,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_nonce_function_hardened noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:    sig64: pointer to the 64-byte signatur to verify (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 95,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Typo: signatur",
      "created_at": "2020-07-19T18:57:06Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456942579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456942579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456944774",
      "pull_request_review_id": 451153752,
      "id": 456944774,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0NDc3NA==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 2,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This seems out of date.",
      "created_at": "2020-07-19T19:19:13Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456944774",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456944774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456946103",
      "pull_request_review_id": 451153752,
      "id": 456946103,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0NjEwMw==",
      "diff_hunk": "@@ -0,0 +1,772 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+/* Checks that a bit flip in the n_flip-th argument (that has n_bytes many\n+ * bytes) changes the hash function\n+ */\n+void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    unsigned char nonces[2][32];\n+    CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    secp256k1_rand_flip(args[n_flip], n_bytes);\n+    CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(memcmp(nonces[0], nonces[1], 32) != 0);\n+}\n+\n+void run_nonce_function_bip340_tests(void) {\n+    unsigned char tag[12] = \"BIP340/nonce\";\n+    unsigned char aux_tag[10] = \"BIP340/aux\";\n+    unsigned char algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256 sha_optimized;\n+    unsigned char nonce[32];\n+    unsigned char msg[32];\n+    unsigned char key[32];\n+    unsigned char pk[32];\n+    unsigned char aux_rand[32];\n+    unsigned char *args[5];\n+    int i;\n+\n+    /* Check that hash initialized by\n+     * secp256k1_nonce_function_bip340_sha256_tagged has the expected\n+     * state. */\n+    secp256k1_sha256_initialize_tagged(&sha, tag, sizeof(tag));\n+    secp256k1_nonce_function_bip340_sha256_tagged(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+\n+   /* Check that hash initialized by\n+    * secp256k1_nonce_function_bip340_sha256_tagged_aux has the expected\n+    * state. */\n+    secp256k1_sha256_initialize_tagged(&sha, aux_tag, sizeof(aux_tag));\n+    secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+\n+    secp256k1_rand256(msg);\n+    secp256k1_rand256(key);\n+    secp256k1_rand256(pk);\n+    secp256k1_rand256(aux_rand);\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = msg;\n+    args[1] = key;\n+    args[2] = pk;\n+    args[3] = algo16;\n+    args[4] = aux_rand;\n+    for (i = 0; i < count; i++) {\n+        nonce_function_bip340_bitflip(args, 0, 32);\n+        nonce_function_bip340_bitflip(args, 1, 32);\n+        nonce_function_bip340_bitflip(args, 2, 32);\n+        /* Flip algo16 special case \"BIP340/nonce\" */\n+        nonce_function_bip340_bitflip(args, 3, 16);\n+        /* Flip algo16 again */\n+        nonce_function_bip340_bitflip(args, 3, 16);\n+        nonce_function_bip340_bitflip(args, 4, 32);\n+    }\n+\n+    /* NULL algo16 is disallowed */\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, NULL, NULL) == 0);\n+    /* Empty algo16 is fine */\n+    memset(algo16, 0x00, 16);\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* algo16 with terminating null bytes is fine */\n+    algo16[1] = 65;\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* Other algo16 is fine */\n+    memset(algo16, 0xFF, 16);\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+\n+    /* NULL aux_rand argument is allowed. */\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+}\n+\n+void test_schnorrsig_api(void) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    secp256k1_keypair keypairs[3];\n+    secp256k1_xonly_pubkey pk[3];\n+    secp256k1_xonly_pubkey zero_pk;\n+    unsigned char sig[64];\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[0], sk1) == 1);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[1], sk2) == 1);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[2], sk3) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[0], NULL, &keypairs[0]) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[1], NULL, &keypairs[1]) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[2], NULL, &keypairs[2]) == 1);\n+    memset(&zero_pk, 0, sizeof(zero_pk));\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &zero_pk) == 0);\n+    CHECK(ecount == 6);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Checks that hash initialized by secp256k1_musig_sha256_tagged has the",
      "path": "src/modules/schnorrsig/tests_impl.h",
      "position": null,
      "original_position": 164,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "musig?",
      "created_at": "2020-07-19T19:31:58Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r456946103",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/456946103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457281893",
      "pull_request_review_id": 451505447,
      "id": 457281893,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI4MTg5Mw==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": null,
      "user": {
        "login": "LLFourn",
        "id": 3734083,
        "node_id": "MDQ6VXNlcjM3MzQwODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3734083?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LLFourn",
        "html_url": "https://github.com/LLFourn",
        "followers_url": "https://api.github.com/users/LLFourn/followers",
        "following_url": "https://api.github.com/users/LLFourn/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LLFourn/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LLFourn/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LLFourn/subscriptions",
        "organizations_url": "https://api.github.com/users/LLFourn/orgs",
        "repos_url": "https://api.github.com/users/LLFourn/repos",
        "events_url": "https://api.github.com/users/LLFourn/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LLFourn/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there a strong reason not to allow signing messages of any length (so I guess passing in pointer + length)?\r\nI have been working on DLCs recently and I noticed that suredbits implemented their PoC price oracle by first hashing and then signing see: https://test.suredbits.com/api/#oracle-specification\r\n\r\n> Oracle signatures will be Schnorr Signatures of the following hash:\r\n> `SHA256(moonOrCrash ++ exchange ++ pair ++ eventTime.getMillis)`\r\n\r\nMy guess is that this design is just a side effect of this API.\r\nThe hash-then-sign scheme depends on collision resistance of the message hash for EUF-CMA i.e. if the adversary can control the set of messages the oracle is signing (which is not out of the question). \r\nSchnorr famously doesn't require collision resistance (BIP340 even mentions this as a motivation).\r\nOf course, practically if CR is broken there may be bigger problems but I think it would be nice to avoid the whole Bitcoin ecosystem unnecessarily hashing stuff when they sign some non-transaction data. \r\nI don't know if non-transaction signing is within the scope of this library though.\r\n\r\ncc @nkohen ",
      "created_at": "2020-07-20T11:02:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457281893",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457281893"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457561300",
      "pull_request_review_id": 451796145,
      "id": 457561300,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2MTMwMA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I vaguely recall having this discussions about it, and I think we just resorted to pre-hashed messages because in the context of Bitcoin transaction signing, the security inherently reduces to that, as the message being signed itself contains many hashes (at least the txids of previous transaction outputs being spent, but also various precomputed hashes to make transaction validation not quadratic in the number of inputs).\r\n\r\nIt seems fairly easy to permit variable-length messages, as they always go at the end of hash input. However, that would require explaining that it's only meaningful if the message itself doesn't contain any hashes itself. I'd also need to check if it doesn't interfere with our side channel resistance analysis.\r\n\r\nRegardless, this PR is following BIP340 as written (which states that messages are 32-byte arrays). We should probably either include a section (perhaps under design) to explain the choice for pre-hashed messages, or modify the document to permit variable-length messages.",
      "created_at": "2020-07-20T17:04:36Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457561300",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457561300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457570837",
      "pull_request_review_id": 451808318,
      "id": 457570837,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3MDgzNw==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Opened an issue: https://github.com/sipa/bips/issues/207",
      "created_at": "2020-07-20T17:21:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457570837",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457570837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457647676",
      "pull_request_review_id": 451904128,
      "id": 457647676,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0NzY3Ng==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result (cannot be\n+ *                       NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. Will",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 104,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 456940698,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it should apply to `output_pubkey` but it didn't apply in all cases so I fixed that too",
      "created_at": "2020-07-20T19:40:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457647676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457647676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457647773",
      "pull_request_review_id": 451904257,
      "id": 457647773,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0Nzc3Mw==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 31,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 456942102,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-07-20T19:40:47Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457647773",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457647773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457647830",
      "pull_request_review_id": 451904332,
      "id": 457647830,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0NzgzMA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and\n+ *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg32,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_nonce_function_hardened noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:    sig64: pointer to the 64-byte signatur to verify (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 95,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 456942579,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-07-20T19:40:55Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457647830",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457647830"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457648356",
      "pull_request_review_id": 451904988,
      "id": 457648356,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0ODM1Ng==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 2,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 456944774,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No idea how this works. How about\r\n```\r\n * Copyright (c) 2020 Andrew Poelstra, Jonas Nick                          \r\n```",
      "created_at": "2020-07-20T19:41:54Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457648356",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457648356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457648413",
      "pull_request_review_id": 451905046,
      "id": 457648413,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0ODQxMw==",
      "diff_hunk": "@@ -0,0 +1,772 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+\n+#include \"secp256k1_schnorrsig.h\"\n+\n+/* Checks that a bit flip in the n_flip-th argument (that has n_bytes many\n+ * bytes) changes the hash function\n+ */\n+void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n+    unsigned char nonces[2][32];\n+    CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    secp256k1_rand_flip(args[n_flip], n_bytes);\n+    CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n+    CHECK(memcmp(nonces[0], nonces[1], 32) != 0);\n+}\n+\n+void run_nonce_function_bip340_tests(void) {\n+    unsigned char tag[12] = \"BIP340/nonce\";\n+    unsigned char aux_tag[10] = \"BIP340/aux\";\n+    unsigned char algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+    secp256k1_sha256 sha;\n+    secp256k1_sha256 sha_optimized;\n+    unsigned char nonce[32];\n+    unsigned char msg[32];\n+    unsigned char key[32];\n+    unsigned char pk[32];\n+    unsigned char aux_rand[32];\n+    unsigned char *args[5];\n+    int i;\n+\n+    /* Check that hash initialized by\n+     * secp256k1_nonce_function_bip340_sha256_tagged has the expected\n+     * state. */\n+    secp256k1_sha256_initialize_tagged(&sha, tag, sizeof(tag));\n+    secp256k1_nonce_function_bip340_sha256_tagged(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+\n+   /* Check that hash initialized by\n+    * secp256k1_nonce_function_bip340_sha256_tagged_aux has the expected\n+    * state. */\n+    secp256k1_sha256_initialize_tagged(&sha, aux_tag, sizeof(aux_tag));\n+    secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha_optimized);\n+    test_sha256_eq(&sha, &sha_optimized);\n+\n+    secp256k1_rand256(msg);\n+    secp256k1_rand256(key);\n+    secp256k1_rand256(pk);\n+    secp256k1_rand256(aux_rand);\n+\n+    /* Check that a bitflip in an argument results in different nonces. */\n+    args[0] = msg;\n+    args[1] = key;\n+    args[2] = pk;\n+    args[3] = algo16;\n+    args[4] = aux_rand;\n+    for (i = 0; i < count; i++) {\n+        nonce_function_bip340_bitflip(args, 0, 32);\n+        nonce_function_bip340_bitflip(args, 1, 32);\n+        nonce_function_bip340_bitflip(args, 2, 32);\n+        /* Flip algo16 special case \"BIP340/nonce\" */\n+        nonce_function_bip340_bitflip(args, 3, 16);\n+        /* Flip algo16 again */\n+        nonce_function_bip340_bitflip(args, 3, 16);\n+        nonce_function_bip340_bitflip(args, 4, 32);\n+    }\n+\n+    /* NULL algo16 is disallowed */\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, NULL, NULL) == 0);\n+    /* Empty algo16 is fine */\n+    memset(algo16, 0x00, 16);\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* algo16 with terminating null bytes is fine */\n+    algo16[1] = 65;\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+    /* Other algo16 is fine */\n+    memset(algo16, 0xFF, 16);\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+\n+    /* NULL aux_rand argument is allowed. */\n+    CHECK(nonce_function_bip340(nonce, msg, key, pk, algo16, NULL) == 1);\n+}\n+\n+void test_schnorrsig_api(void) {\n+    unsigned char sk1[32];\n+    unsigned char sk2[32];\n+    unsigned char sk3[32];\n+    unsigned char msg[32];\n+    secp256k1_keypair keypairs[3];\n+    secp256k1_xonly_pubkey pk[3];\n+    secp256k1_xonly_pubkey zero_pk;\n+    unsigned char sig[64];\n+\n+    /** setup **/\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    int ecount;\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    secp256k1_rand256(sk1);\n+    secp256k1_rand256(sk2);\n+    secp256k1_rand256(sk3);\n+    secp256k1_rand256(msg);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[0], sk1) == 1);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[1], sk2) == 1);\n+    CHECK(secp256k1_keypair_create(ctx, &keypairs[2], sk3) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[0], NULL, &keypairs[0]) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[1], NULL, &keypairs[1]) == 1);\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &pk[2], NULL, &keypairs[2]) == 1);\n+    memset(&zero_pk, 0, sizeof(zero_pk));\n+\n+    /** main test body **/\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_sign(none, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_sign(vrfy, sig, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_sign(sign, NULL, msg, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, NULL, &keypairs[0], NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, &pk[0]) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &pk[0]) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, &pk[0]) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, &pk[0]) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, NULL) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, &zero_pk) == 0);\n+    CHECK(ecount == 6);\n+\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n+/* Checks that hash initialized by secp256k1_musig_sha256_tagged has the",
      "path": "src/modules/schnorrsig/tests_impl.h",
      "position": null,
      "original_position": 164,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 456946103,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-07-20T19:41:59Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457648413",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457648413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457664376",
      "pull_request_review_id": 451924929,
      "id": 457664376,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NDM3Ng==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 2,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 456944774,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, or 2018-2020 even.",
      "created_at": "2020-07-20T20:12:46Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457664376",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457664376"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457921028",
      "pull_request_review_id": 452230553,
      "id": 457921028,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyMTAyOA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I can get on board with this.\r\n\r\nOne of the arguments previously against variable length messages was to keep a similar API as ecdsa, but we've later deviated from that by adding keypairs and changing the nonce function. It seems like a challenge a a challenge to make sure all message lengths work on all supported architectures and not adding hour long tests to our harness for long messages.\r\n\r\nFwiw, I don't think supporting variable length messages strictly necessitates BIP changes. The scheme implemented here is already only bip-schnorr compliant if you pass in random `ndata`. You could say same about msg_len = 32.",
      "created_at": "2020-07-21T08:19:47Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457921028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457921028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457979697",
      "pull_request_review_id": 452306030,
      "id": 457979697,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3OTY5Nw==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "On the other hand, just because the BIP would allow variable-lengths messages, that does not imply that we need to implement them. In particular because variable-length stuff is a hassle in C. (But of course this doesn't solve @LLFourn's problem then.)",
      "created_at": "2020-07-21T09:58:25Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r457979697",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/457979697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458030413",
      "pull_request_review_id": 452369044,
      "id": 458030413,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAzMDQxMw==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> variable-length stuff is a hassle in C. \r\n\r\n... you take a length argument.",
      "created_at": "2020-07-21T11:37:00Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r458030413",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458030413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458102990",
      "pull_request_review_id": 452465438,
      "id": 458102990,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMjk5MA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sure but it's easy for the caller to get it wrong and invalidate memory safety.\r\n\r\nI admit it's not clear if this a great argument because with fixed-length arrays we just push the issue to the caller entirely. At least the caller could be in a safer language. ",
      "created_at": "2020-07-21T13:38:24Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r458102990",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458102990"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458346093",
      "pull_request_review_id": 452776665,
      "id": 458346093,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0NjA5Mw==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "And if it were, it would have a .size().  Besides, this function only reads from the buffer and only turns its reads into hashes, of all possible functions that could mishandle something, that would be the least concerning.  One could also provide a wrapper function that set the length, so the interface could stay the same, there would just be a _with_extended_message() version of sign and verify that took a length.",
      "created_at": "2020-07-21T19:46:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r458346093",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458346093"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458472024",
      "pull_request_review_id": 452924933,
      "id": 458472024,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MjAyNA==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 93,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "8d185a465bc63272caabd547b70cafb9968ffb30",
      "in_reply_to_id": null,
      "user": {
        "login": "benthecarman",
        "id": 15256660,
        "node_id": "MDQ6VXNlcjE1MjU2NjYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/15256660?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benthecarman",
        "html_url": "https://github.com/benthecarman",
        "followers_url": "https://api.github.com/users/benthecarman/followers",
        "following_url": "https://api.github.com/users/benthecarman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benthecarman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benthecarman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benthecarman/subscriptions",
        "organizations_url": "https://api.github.com/users/benthecarman/orgs",
        "repos_url": "https://api.github.com/users/benthecarman/repos",
        "events_url": "https://api.github.com/users/benthecarman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benthecarman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">  may have an odd Y coordinate, it can not be represented by an x-only pubkey\r\n\r\nI think it makes more grammatical sense to say \r\n\r\n> may have an odd Y coordinate, _that_ can not be represented by an x-only pubkey",
      "created_at": "2020-07-22T00:56:43Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r458472024",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458472024"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 92,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458737602",
      "pull_request_review_id": 453246007,
      "id": 458737602,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczNzYwMg==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that because the resulting point may have an odd Y coordinate, it can\n+ *  not be represented by an x-only pubkey. Instead, the output_pubkey is a",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 93,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "8d185a465bc63272caabd547b70cafb9968ffb30",
      "in_reply_to_id": 458472024,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm, this sounds wrong when you take the other part of the sentence into account:\r\n\r\n> Note that because the resulting point may have an odd Y coordinate, that can not be represented by an x-only pubkey.\r\n\r\nChanged it to:\r\n\r\n> Note that the resulting point can not be represented by an x-only pubkey because it may have an odd Y coordinate.\r\n",
      "created_at": "2020-07-22T11:56:41Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r458737602",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458737602"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": 92,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458763404",
      "pull_request_review_id": 453279780,
      "id": 458763404,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2MzQwNA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A very related API discussion is whether we should export the hash module. In particular if we want to tell users \"just use a hash function to obtain a 32 byte value\", then it's kind of strange to tell them to use a different library, even though hashing is implemented here. (And they may not care about performance.) However, this has been discussed before and I mostly agree with what @sipa said in https://github.com/bitcoin-core/secp256k1/pull/447#issuecomment-288160787:\r\n\r\n> libsecp256k1 is a library for elliptic curve crypto, not a generic cryptography library. It has a copy of SHA256 for randomization and a few related algorithms, but it is not optimized in any way. I fear that exposing the function will lead to people demanding that it gets optimized for various purposes and/or platforms, which I don't think should be the library's focus.\r\n\r\n\r\n\r\nNow with Schnorr sigs, SHA256 becomes an integral part of the library, and we're committed to SHA256, it's not an implementation detail anymore. So we could at least think about this again for users who don't care about extraordinary performance. If we also provide a compile-time override https://github.com/bitcoin-core/secp256k1/issues/702 ,  the concern that people demand that it gets optimized is resolved, too.",
      "created_at": "2020-07-22T12:44:44Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r458763404",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/458763404"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/459060056",
      "pull_request_review_id": 453655571,
      "id": 459060056,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2MDA1Ng==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will be NULL for ECDSA for compatibility).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP340/nonce\\0\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 74,
      "original_position": 73,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "63bf929e60d913c6828b60ea08c96f37aa87a8ba",
      "in_reply_to_id": 457281893,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I agree that with sha256 being a normative part of the library it makes more sense to expose it.\r\n\r\nFunny but I think 702 is in some ways less of a reason to expose it:  one reason to expose it is so that users with small flash don't end up with two copies.  With 702 they can get libsecp2561k to use their external copy.",
      "created_at": "2020-07-22T20:22:00Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r459060056",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/459060056"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/460871975",
      "pull_request_review_id": 455756677,
      "id": 460871975,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg3MTk3NQ==",
      "diff_hunk": "@@ -7,6 +7,75 @@\n extern \"C\" {\n #endif\n \n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.",
      "path": "include/secp256k1_extrakeys.h",
      "position": 13,
      "original_position": 7,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "95dd2c73c55ce48518d56f7a0d0fb48e59242ddd",
      "in_reply_to_id": null,
      "user": {
        "login": "chris-belcher",
        "id": 8398185,
        "node_id": "MDQ6VXNlcjgzOTgxODU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8398185?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/chris-belcher",
        "html_url": "https://github.com/chris-belcher",
        "followers_url": "https://api.github.com/users/chris-belcher/followers",
        "following_url": "https://api.github.com/users/chris-belcher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/chris-belcher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/chris-belcher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/chris-belcher/subscriptions",
        "organizations_url": "https://api.github.com/users/chris-belcher/orgs",
        "repos_url": "https://api.github.com/users/chris-belcher/repos",
        "events_url": "https://api.github.com/users/chris-belcher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/chris-belcher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this source code is not consistent with the BIP340 document. The BIP talks about going with the option of implicitly choosing the Y coordinate that is a quadratic residue, not choosing the even Y coordinate.",
      "created_at": "2020-07-27T13:01:03Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r460871975",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/460871975"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": 11,
      "original_start_line": 11,
      "start_side": "RIGHT",
      "line": 13,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/465854239",
      "pull_request_review_id": 461832283,
      "id": 465854239,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1NDIzOQ==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: The casting of `ndata` to `void*` seems unnecessary.",
      "created_at": "2020-08-05T16:31:43Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r465854239",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/465854239"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/465901733",
      "pull_request_review_id": 461893475,
      "id": 465901733,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwMTczMw==",
      "diff_hunk": "@@ -241,6 +241,18 @@ static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int o\n \n }\n \n+static void secp256k1_ge_even_y(secp256k1_ge *r, int *y_parity) {\n+    if (y_parity != NULL) {\n+        *y_parity = 0;\n+    }\n+    if (secp256k1_fe_is_odd(&r->y)) {\n+        secp256k1_ge_neg(r, r);",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 9,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't know if you care, but technically it is faster to call `secp256k1_fe_negate(&r->y, &r->y, 1)` here.  `fe_is_odd` already requires `r->y` to be fully normalized as a prerequisite.",
      "created_at": "2020-08-05T17:52:31Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r465901733",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/465901733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466463544",
      "pull_request_review_id": 462586688,
      "id": 466463544,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ2MzU0NA==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 37,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why clear `pk` (but not `x`)?",
      "created_at": "2020-08-06T14:41:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r466463544",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466463544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466483085",
      "pull_request_review_id": 462612908,
      "id": 466483085,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ4MzA4NQ==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 124,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Mentioned this to jonas already: probably better to `return ret` here.",
      "created_at": "2020-08-06T15:09:25Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r466483085",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466483085"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466576617",
      "pull_request_review_id": 462736441,
      "id": 466576617,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NjYxNw==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 37,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 466463544,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since this only handles public input ISTM the clear is just a copy and paste from some private key handling function",
      "created_at": "2020-08-06T17:35:45Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r466576617",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466576617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466577789",
      "pull_request_review_id": 462737844,
      "id": 466577789,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3Nzc4OQ==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 124,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 466483085,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why was this arg_checking it to begin with?  Argchecks are for testing if the caller has violated the calling conventions. I just checked the entire PR and this appears to be the only case of arg_check misuse.",
      "created_at": "2020-08-06T17:37:41Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r466577789",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466577789"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466591534",
      "pull_request_review_id": 462755313,
      "id": 466591534,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5MTUzNA==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 124,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 466483085,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`pubkey_load` uses `ARG_CHECK` in the same way to fire an illegal callback if a zeroed pubkey is used.\r\n```\r\n/* don't check return value */\r\ndo_something_with_keypair_that_fails(keypair);\r\n/* keypair is zeroed, ARG_CHECK fails */\r\ndo_something_with_secret_part_of_keypair_that_fails(keypair);\r\n```",
      "created_at": "2020-08-06T18:01:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r466591534",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466591534"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466610233",
      "pull_request_review_id": 462779347,
      "id": 466610233,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMDIzMw==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 124,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 466483085,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah. Ignore me: I didn't look at the context and thought this was a deserializer. It's good to argcheck on the validity of a libsecp256k1 constructed object.",
      "created_at": "2020-08-06T18:36:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r466610233",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466610233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466998254",
      "pull_request_review_id": 463258321,
      "id": 466998254,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5ODI1NA==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;\n+}\n+\n+/* Load a keypair into pk and sk (if non-NULL). This function declassifies pk\n+ * and ARG_CHECKs that the keypair is not invalid. It always initializes sk and\n+ * pk with dummy values. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's\n+     * invalid. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    ret = secp256k1_pubkey_load(ctx, pk, pubkey);\n+    if (sk != NULL) {\n+        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);\n+    }\n+    if (!ret) {\n+        *pk = secp256k1_ge_const_g;\n+        if (sk != NULL) {\n+            *sk = secp256k1_scalar_one;\n+        }\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pubkey_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    secp256k1_ge_even_y(&pk, pubkey_parity);\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+        secp256k1_ge_neg(&pk, &pk);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same comment as `secp256k1_ge_even_y` about considering using `secp256k1_fe_negate(&pk.y, &pk.y, 1)`.  Alternatively, could also call `secp256k1_ge_even_y` here and negate `sk` based on the `y_parity` flag value.",
      "created_at": "2020-08-07T12:05:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r466998254",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/466998254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467019152",
      "pull_request_review_id": 463284669,
      "id": 467019152,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAxOTE1Mg==",
      "diff_hunk": "@@ -605,50 +612,58 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+\n+static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak) {\n     secp256k1_scalar term;\n+    int overflow = 0;\n+    int ret = 0;\n+\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    ret = (!overflow) & secp256k1_eckey_privkey_tweak_add(sec, &term);\n+    secp256k1_scalar_clear(&term);\n+    return ret;\n+}\n+\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar sec;\n     int ret = 0;\n-    int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-\n-    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_add(&sec, &term);\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);",
      "path": "src/secp256k1.c",
      "position": 81,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should the `secp256k1_scalar_cmov` be part of `secp256k1_ec_seckey_tweak_add_helper`?",
      "created_at": "2020-08-07T12:49:48Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467019152",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467019152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 637,
      "original_line": 637,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467047841",
      "pull_request_review_id": 463321828,
      "id": 467047841,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0Nzg0MQ==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 37,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 466463544,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a copy and paste from a public key handling function, in particular `ec_pubkey_parse`. Not idea why it's there, but I'd be happy to remove it.",
      "created_at": "2020-08-07T13:41:50Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467047841",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467047841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467051562",
      "pull_request_review_id": 463326713,
      "id": 467051562,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA1MTU2Mg==",
      "diff_hunk": "@@ -605,50 +612,58 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+\n+static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak) {\n     secp256k1_scalar term;\n+    int overflow = 0;\n+    int ret = 0;\n+\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    ret = (!overflow) & secp256k1_eckey_privkey_tweak_add(sec, &term);\n+    secp256k1_scalar_clear(&term);\n+    return ret;\n+}\n+\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar sec;\n     int ret = 0;\n-    int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-\n-    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_add(&sec, &term);\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);",
      "path": "src/secp256k1.c",
      "position": 81,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467019152,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Currently that `cmov` takes into account whether `scalar_set_b32_seckey` failed because it's part of `ret`. If `cmov` was in the helper then the function can fail due to the seckey overflowing the scalar, but the seckey wouldn't be zeroed after the function call.",
      "created_at": "2020-08-07T13:47:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467051562",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467051562"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 637,
      "original_line": 637,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467083343",
      "pull_request_review_id": 463367776,
      "id": 467083343,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4MzM0Mw==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;\n+}\n+\n+/* Load a keypair into pk and sk (if non-NULL). This function declassifies pk\n+ * and ARG_CHECKs that the keypair is not invalid. It always initializes sk and\n+ * pk with dummy values. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's\n+     * invalid. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    ret = secp256k1_pubkey_load(ctx, pk, pubkey);\n+    if (sk != NULL) {\n+        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);\n+    }\n+    if (!ret) {\n+        *pk = secp256k1_ge_const_g;\n+        if (sk != NULL) {\n+            *sk = secp256k1_scalar_one;\n+        }\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pubkey_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    secp256k1_ge_even_y(&pk, pubkey_parity);\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+        secp256k1_ge_neg(&pk, &pk);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 466998254,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "hm yeah better to use `secp256k1_ge_even_y` here",
      "created_at": "2020-08-07T14:39:59Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467083343",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467083343"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467108285",
      "pull_request_review_id": 463400248,
      "id": 467108285,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwODI4NQ==",
      "diff_hunk": "@@ -605,50 +612,58 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+\n+static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak) {\n     secp256k1_scalar term;\n+    int overflow = 0;\n+    int ret = 0;\n+\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    ret = (!overflow) & secp256k1_eckey_privkey_tweak_add(sec, &term);\n+    secp256k1_scalar_clear(&term);\n+    return ret;\n+}\n+\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar sec;\n     int ret = 0;\n-    int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-\n-    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_add(&sec, &term);\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);",
      "path": "src/secp256k1.c",
      "position": 81,
      "original_position": 81,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467019152,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes of course.  You are right.",
      "created_at": "2020-08-07T15:22:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467108285",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467108285"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 637,
      "original_line": 637,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467121140",
      "pull_request_review_id": 463416567,
      "id": 467121140,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTE0MA==",
      "diff_hunk": "@@ -438,6 +438,29 @@ void run_sha256_tests(void) {\n     }\n }\n \n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(secp256k1_sha256 *sha1, secp256k1_sha256 *sha2) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char buf2[32];\n+\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);\n+\n+    /* Compare the struct excluding the buffer, because it may be\n+     * uninitialized or already included in the state. */\n+    CHECK(sha1->bytes == sha2->bytes);\n+    CHECK(memcmp(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n+\n+    /* Compare the output */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 19,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm fairly certain this section is unnecessary.",
      "created_at": "2020-08-07T15:45:23Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467121140",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467121140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 456,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467132593",
      "pull_request_review_id": 463431094,
      "id": 467132593,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzMjU5Mw==",
      "diff_hunk": "@@ -438,6 +438,29 @@ void run_sha256_tests(void) {\n     }\n }\n \n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(secp256k1_sha256 *sha1, secp256k1_sha256 *sha2) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char buf2[32];\n+\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);\n+\n+    /* Compare the struct excluding the buffer, because it may be\n+     * uninitialized or already included in the state. */\n+    CHECK(sha1->bytes == sha2->bytes);\n+    CHECK(memcmp(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n+\n+    /* Compare the output */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 19,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467121140,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's used in `schnorrsig/tests_impl.h` and should be probably moved there. The section is unnecessary indeed. Perhaps this was some kind of sanity check.",
      "created_at": "2020-08-07T16:06:19Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467132593",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467132593"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 456,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467136889",
      "pull_request_review_id": 463436401,
      "id": 467136889,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNjg4OQ==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey\n+ *  because it may have an odd Y coordinate. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that an output pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the parity of the output pubkey (whose serialization is\n+ *                       passed in as output_pubkey32). This must match the\n+ *                       pk_parity value that is returned when calling\n+ *                       secp256k1_xonly_pubkey with the output pubkey, or this\n+ *                       function will fail.\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *output_pubkey32,\n+    int output_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, its value is undefined. (cannot\n+ *               be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, its value is undefined (cannot be NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding tweak times the generator to the x-only public key\n+ *  and secret key parts of the keypair.\n+ *\n+ *  Calling this function and then secp256k1_keypair_pub results in the same\n+ *  public key as calling secp256k1_keypair_xonly_pub and then\n+ *  secp256k1_xonly_pubkey_tweak_add.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting keypair would be\n+ *           invalid (only when the tweak is the negation of the keypair's\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:       ctx: pointer to a context object initialized for validation\n+ *                   (cannot be NULL)\n+ *  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to\n+ *                   an invalid value if this function returns 0 (cannot be\n+ *                   NULL).\n+ *  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according\n+ *                   to secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                   uniformly random 32-byte arrays the chance of being invalid\n+ *                   is negligible (around 1 in 2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *tweak32",
      "path": "include/secp256k1_extrakeys.h",
      "position": 229,
      "original_position": 227,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe that this is the only function that doesn't have an parity flip output value.",
      "created_at": "2020-08-07T16:14:10Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467136889",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467136889"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 229,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467146403",
      "pull_request_review_id": 463448270,
      "id": 467146403,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NjQwMw==",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 80,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "ac5a0a1174b0c16eb59a77df07f74a1b23acf5b9",
      "in_reply_to_id": 454547845,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "how is this resolved?",
      "created_at": "2020-08-07T16:32:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467146403",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467146403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467146886",
      "pull_request_review_id": 463448270,
      "id": 467146886,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0Njg4Ng==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 44,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can we say \"unspecified\"? \"Undefined\" always smells like UB.",
      "created_at": "2020-08-07T16:33:37Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467146886",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467146886"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467147668",
      "pull_request_review_id": 463448270,
      "id": 467147668,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NzY2OA==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 90,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n/** Tweak an x-only public key by adding tweak32 times the generator to it.\r\n```\r\nStill reads a little strange. Maybe add backticks? Or simpler: by \"adding a multiple of the generator\" ",
      "created_at": "2020-08-07T16:35:09Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467147668",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467147668"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467148572",
      "pull_request_review_id": 463448270,
      "id": 467148572,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0ODU3Mg==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 92,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  Note that the resulting point can not in general be represented by an x-only pubkey\r\n```",
      "created_at": "2020-08-07T16:36:52Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467148572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467148572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467149033",
      "pull_request_review_id": 463448270,
      "id": 467149033,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0OTAzMw==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey\n+ *  because it may have an odd Y coordinate. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 100,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  Args:           ctx: pointer to a context object initialized for verification\r\n```",
      "created_at": "2020-08-07T16:37:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467149033",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467149033"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 100,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467149741",
      "pull_request_review_id": 463448270,
      "id": 467149741,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0OTc0MQ==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey\n+ *  because it may have an odd Y coordinate. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that an output pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the parity of the output pubkey (whose serialization is\n+ *                       passed in as output_pubkey32). This must match the\n+ *                       pk_parity value that is returned when calling\n+ *                       secp256k1_xonly_pubkey with the output pubkey, or this\n+ *                       function will fail.\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *output_pubkey32,\n+    int output_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, its value is undefined. (cannot\n+ *               be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, its value is undefined (cannot be NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding tweak times the generator to the x-only public key",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 203,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "tweak32 as above",
      "created_at": "2020-08-07T16:39:20Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467149741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467149741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467150886",
      "pull_request_review_id": 463453888,
      "id": 467150886,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MDg4Ng==",
      "diff_hunk": "@@ -438,6 +438,29 @@ void run_sha256_tests(void) {\n     }\n }\n \n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(secp256k1_sha256 *sha1, secp256k1_sha256 *sha2) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char buf2[32];\n+\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);\n+\n+    /* Compare the struct excluding the buffer, because it may be\n+     * uninitialized or already included in the state. */\n+    CHECK(sha1->bytes == sha2->bytes);\n+    CHECK(memcmp(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n+\n+    /* Compare the output */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 19,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467121140,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If removed the arguments can be made `const`.",
      "created_at": "2020-08-07T16:41:42Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467150886",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467150886"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 456,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467151071",
      "pull_request_review_id": 463448270,
      "id": 467151071,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MTA3MQ==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 24,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to abort.\r\n```\r\nI know it's subtle but I think \"abort\" makes clearer that no signature is produced.",
      "created_at": "2020-08-07T16:42:06Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467151071",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467151071"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467151252",
      "pull_request_review_id": 463448270,
      "id": 467151252,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MTI1Mg==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 35,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  the message, the key, the pubkey, the algorithm description, and data.\r\n```",
      "created_at": "2020-08-07T16:42:30Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467151252",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467151252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467152134",
      "pull_request_review_id": 463448270,
      "id": 467152134,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MjEzNA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 33,
      "original_position": 32,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe we should make it more explicit that this additional entropy?\r\nOr would it be better to have two separate arguments, one for additional entropy (maybe fixed length or with length description?) and one for arbitrary user data?",
      "created_at": "2020-08-07T16:44:09Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467152134",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467152134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467159954",
      "pull_request_review_id": 463465336,
      "id": 467159954,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1OTk1NA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 24,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467151071,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sounds like abort(). Return an error.",
      "created_at": "2020-08-07T16:59:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467159954",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467159954"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467160229",
      "pull_request_review_id": 463465650,
      "id": 467160229,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MDIyOQ==",
      "diff_hunk": "@@ -241,6 +241,18 @@ static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int o\n \n }\n \n+static void secp256k1_ge_even_y(secp256k1_ge *r, int *y_parity) {",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 4,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Add `VERIFY_CHECK(!r->infinity);`",
      "created_at": "2020-08-07T17:00:24Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467160229",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467160229"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467163280",
      "pull_request_review_id": 463469429,
      "id": 467163280,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MzI4MA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 33,
      "original_position": 32,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467152134,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That is up to the nonce function.\r\n\r\nFor example, there is a nonce function that uses the data function to exfiltrate the nonce itself for use in ECDH to generate stealth addresses.  For someone that needed very low latency signing, I once wrote a nonce function that took an argument to a datastructure of precomputed nonces which it managed..\r\n\r\nTwo arguments would address that-- e.g. one always for extra stuff, but OTOH, the singing function might end up with too many arguments that the user is always stuffing NULL into?   Maybe less of an issue if synthetic nonces are strongly encouraged.  But those could also be accomplished another way-- e.g. passing randomness into the context at init time. (requires malleable signing context)",
      "created_at": "2020-08-07T17:06:35Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467163280",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467163280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467171465",
      "pull_request_review_id": 463479609,
      "id": 467171465,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3MTQ2NQ==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 33,
      "original_position": 32,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467152134,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "related: https://github.com/bitcoin-core/secp256k1/issues/757\r\n\r\n> Two arguments would address that-- e.g. one always for extra stuff, but OTOH, the singing function might end up with too many arguments that the user is always stuffing NULL into? \r\n\r\nIf there are too many NULLs, maybe we should just have a wrapper that does not allow specifying the nonce function. Specifying the nonce function is pretty advanced stuff anyway (\"do this only if you know what you're doing\"). \r\n",
      "created_at": "2020-08-07T17:23:25Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467171465",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467171465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467186768",
      "pull_request_review_id": 463498840,
      "id": 467186768,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4Njc2OA==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 63,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You have failed to check the return value of `secp256k1_pubkey_load`.  While it is true that this `load` can never fail as implemented, you seem to do a careful job of checking for `load` failure everywhere else.",
      "created_at": "2020-08-07T17:54:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467186768",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467186768"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467189434",
      "pull_request_review_id": 463502225,
      "id": 467189434,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4OTQzNA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 33,
      "original_position": 32,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467152134,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Maybe we should make it more explicit that this additional entropy?\r\n> Or would it be better to have two separate arguments [...] ?\r\n\r\nI don't think so, as said above this is up to the nonce function. It's easy to put both randomness and your additional data in the data arg of your custom nonce function.\r\nThe doc for nonce data in schnorrsig_sign says `If it is non-NULL and secp256k1_nonce_function_bip340 is used, then ndata must be a pointer to 32-byte auxiliary randomness as per BIP-340.`\r\n\r\nBut I'd be fine with making schnorrsig_sign a function that doesn't take a nonce function argument and the noncedata arg is renamed to randomness (or something).\r\nrelated: #589 which shows that the best way to implement sign-to-contract (and therefore anti-covert-channel mechanisms) is not via the nonce function. Therefore, changing the nonce function is probably rarely used compared to normal signing. Moreover, there's little benefit to keep this similar to the ecdsa_sign API because it already takes a keypair instead of a secret key byte array.\r\n",
      "created_at": "2020-08-07T17:59:59Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467189434",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467189434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467192749",
      "pull_request_review_id": 463506288,
      "id": 467192749,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5Mjc0OQ==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 63,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467186768,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch. The corresponding test is also missing. `pubkey_load` can fail if you give it a zeroed pubkey.",
      "created_at": "2020-08-07T18:07:01Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467192749",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467192749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467197869",
      "pull_request_review_id": 463512636,
      "id": 467197869,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5Nzg2OQ==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 118,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe use `secp256k1_scalar_set_b32_seckey` instead?",
      "created_at": "2020-08-07T18:17:39Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467197869",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467197869"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467198406",
      "pull_request_review_id": 463513357,
      "id": 467198406,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5ODQwNg==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 118,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467197869,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`int ret = secp256k1_scalar_set_b32_seckey(sk, &keypair->data[0]);`",
      "created_at": "2020-08-07T18:18:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467198406",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467198406"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467199731",
      "pull_request_review_id": 463515039,
      "id": 467199731,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5OTczMQ==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 33,
      "original_position": 32,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467152134,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> But I'd be fine with making schnorrsig_sign a function that doesn't take a nonce function argument and the noncedata arg is renamed to randomness (or something).\r\n\r\nYou mean remove the ability to pass custom functions entirely? Or have two sign functions, one with and without the feature? \r\n\r\nYeah, maybe the user just doesn't need this at all. Anyway the nonce function is very fast, and if the user wants randomized signing and has some magic other entropy source for any reason, it's possible to pass entropy. Is there any other reason why the user would want this? \r\n\r\nRemoving it would also leave us with more flexibility for keeping an additional counter in the signing context if we want to do something like `_sign_and_randomize` in the future (https://github.com/bitcoin-core/secp256k1/issues/780#issuecomment-670531851). (Otherwise, where would the counter go for user-defined nonce functions? \"Nowhere\" is a possible answer but maybe not a great one.).\r\n\r\nedit: One could make the point that committing to a fixed API was not great for ECDSA because things like synthetic nonces or hashing in the pubkey came up only later. ",
      "created_at": "2020-08-07T18:21:46Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467199731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467199731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467204219",
      "pull_request_review_id": 463520893,
      "id": 467204219,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwNDIxOQ==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 33,
      "original_position": 32,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467152134,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Two functions. The one without the feature gets to have the simplest `sign()` name.",
      "created_at": "2020-08-07T18:31:24Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467204219",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467204219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467211405",
      "pull_request_review_id": 463530343,
      "id": 467211405,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMTQwNQ==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;\n+}\n+\n+/* Load a keypair into pk and sk (if non-NULL). This function declassifies pk\n+ * and ARG_CHECKs that the keypair is not invalid. It always initializes sk and\n+ * pk with dummy values. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's\n+     * invalid. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    ret = secp256k1_pubkey_load(ctx, pk, pubkey);\n+    if (sk != NULL) {\n+        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);\n+    }\n+    if (!ret) {\n+        *pk = secp256k1_ge_const_g;\n+        if (sk != NULL) {\n+            *sk = secp256k1_scalar_one;\n+        }\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pubkey_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    secp256k1_ge_even_y(&pk, pubkey_parity);\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+        secp256k1_ge_neg(&pk, &pk);\n+    }\n+\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n+    secp256k1_scalar_cmov(&sk, &secp256k1_scalar_zero, !ret);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 214,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does this `cmov` serve a purpose?  It seems to only provide an early clear of `sk`.  But that seems better accomplished by executing `secp256k1_ec_pubkey_tweak_add_helper` before `secp256k1_ec_seckey_tweak_add_helper` instead and eliminating the `cmov`.",
      "created_at": "2020-08-07T18:47:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467211405",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467211405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467213967",
      "pull_request_review_id": 463533501,
      "id": 467213967,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMzk2Nw==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 63,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467186768,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh I didn't realize that `ARG_CHECK` can return 0.",
      "created_at": "2020-08-07T18:53:34Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467213967",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467213967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467235557",
      "pull_request_review_id": 463568735,
      "id": 467235557,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIzNTU1Nw==",
      "diff_hunk": "@@ -241,6 +241,18 @@ static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int o\n \n }\n \n+static void secp256k1_ge_even_y(secp256k1_ge *r, int *y_parity) {\n+    if (y_parity != NULL) {\n+        *y_parity = 0;\n+    }\n+    if (secp256k1_fe_is_odd(&r->y)) {\n+        secp256k1_ge_neg(r, r);",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 9,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 465901733,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't care about the 4 nanoseconds, but I care about removing unnecessary stuff. Better to use fe_negate. Also, this function seems to be out of place in group.h, because no other function there assumes that the coordinates are normalized. Perhaps best to move this function into extrakeys/main_impl.h",
      "created_at": "2020-08-07T19:42:46Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467235557",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467235557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467253138",
      "pull_request_review_id": 463590980,
      "id": 467253138,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1MzEzOA==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 224,
      "original_position": 222,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You probably don't care, but I feel compelled to point out that it is technically faster to load the odd-variant of the xonly public key (which is normally the even variant) rather than negating the scalar `e` here.",
      "created_at": "2020-08-07T20:26:07Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467253138",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467253138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467651908",
      "pull_request_review_id": 463921617,
      "id": 467651908,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY1MTkwOA==",
      "diff_hunk": "@@ -0,0 +1,105 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    int n;\n+\n+    const secp256k1_keypair **keypairs;\n+    const unsigned char **pk;\n+    const unsigned char **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg, int iters) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    int i;\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    unsigned char sig[64];\n+\n+    for (i = 0; i < iters; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, sig, msg, data->keypairs[i], NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg, int iters) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; i++) {\n+        secp256k1_xonly_pubkey pk;\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &pk, data->pk[i]) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+int main(void) {\n+    int i;\n+    bench_schnorrsig_data data;\n+    int iters = get_iters(10000);\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 57,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "c024c80af386e0fd9239db5c6967bdd6fd5b1ebb",
      "in_reply_to_id": null,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A gigabyte is a little absurd, especially since this doesn't currently use scratch space.",
      "created_at": "2020-08-10T01:00:11Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r467651908",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/467651908"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468267313",
      "pull_request_review_id": 464681927,
      "id": 468267313,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2NzMxMw==",
      "diff_hunk": "@@ -9,8 +9,120 @@\n \n #include \"secp256k1_extrakeys.h\"\n \n+static secp256k1_context* api_test_context(int flags, int *ecount) {\n+    secp256k1_context *ctx0 = secp256k1_context_create(flags);\n+    secp256k1_context_set_error_callback(ctx0, counting_illegal_callback_fn, ecount);\n+    secp256k1_context_set_illegal_callback(ctx0, counting_illegal_callback_fn, ecount);\n+    return ctx0;\n+}\n+\n+void test_xonly_pubkey(void) {\n+    secp256k1_pubkey pk;\n+    secp256k1_xonly_pubkey xonly_pk, xonly_pk_tmp;\n+    secp256k1_ge pk1;\n+    secp256k1_ge pk2;\n+    secp256k1_fe y;\n+    unsigned char sk[32];\n+    unsigned char xy_sk[32];\n+    unsigned char buf32[32];\n+    unsigned char ones32[32];\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char tweak[32];\n+    int pk_parity;\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    secp256k1_rand256(sk);\n+    memset(ones32, 0xFF, 32);\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(xy_sk);\n+    CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+\n+    /* Test xonly_pubkey_from_pubkey */\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(sign, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, NULL, &pk_parity, &pk) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, NULL, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, NULL) == 0);\n+    CHECK(ecount == 2);\n+\n+    /* Choose a secret key such that the resulting pubkey and xonly_pubkey match. */\n+    memset(sk, 0, sizeof(sk));\n+    sk[0] = 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(memcmp(&pk, &xonly_pk, sizeof(pk)) == 0);\n+    CHECK(pk_parity == 0);\n+\n+    /* Choose a secret key such that pubkey and xonly_pubkey are each others\n+     * negation. */\n+    sk[0] = 2;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(memcmp(&xonly_pk, &pk, sizeof(xonly_pk)) != 0);\n+    CHECK(pk_parity == 1);\n+    secp256k1_pubkey_load(ctx, &pk1, &pk);\n+    secp256k1_pubkey_load(ctx, &pk2, (secp256k1_pubkey *) &xonly_pk);\n+    CHECK(secp256k1_fe_equal(&pk1.x, &pk2.x) == 1);\n+    secp256k1_fe_negate(&y, &pk2.y, 1);\n+    CHECK(secp256k1_fe_equal(&pk1.y, &y) == 1);\n+\n+    /* Test xonly_pubkey_serialize and xonly_pubkey_parse */\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, NULL, &xonly_pk) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, NULL) == 0);\n+    CHECK(memcmp(buf32, zeros64, 32) == 0);\n+    CHECK(ecount == 2);\n+    {\n+        /* A pubkey filled with 0s will fail to serialize due to pubkey_load\n+         * special casing. */\n+        secp256k1_xonly_pubkey pk_tmp;\n+        memset(&pk_tmp, 0, sizeof(pk_tmp));\n+        CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &pk_tmp) == 0);\n+    }\n+    /* pubkey_load called illegal callback */\n+    CHECK(ecount == 3);\n+\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &xonly_pk) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_parse(none, NULL, buf32) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, NULL) == 0);\n+    CHECK(ecount == 2);\n+    /* Invalid field element */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, ones32) == 0);\n+    CHECK(ecount == 2);\n+    /* There's no point with x-coordinate 0 on secp256k1 */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, zeros64) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, buf32) == 1);\n+\n+    /* Serialization and parse roundtrip */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk_tmp, buf32) == 1);\n+    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(xonly_pk)) == 0);\n+\n+    /* Can't parse a byte string that's not a valid X coordinate */\n+    memset(ones32, 0xFF, sizeof(ones32));\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk_tmp, ones32) == 0);\n+    CHECK(memcmp(&xonly_pk_tmp, zeros64, sizeof(xonly_pk_tmp)) == 0);",
      "path": "src/modules/extrakeys/tests_impl.h",
      "position": null,
      "original_position": 108,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "95dd2c73c55ce48518d56f7a0d0fb48e59242ddd",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you add a final `    CHECK(ecount == 2);` just to confirm that neither of these failures were ARG_CHECK failures?",
      "created_at": "2020-08-11T01:02:14Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r468267313",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468267313"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 116,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468273203",
      "pull_request_review_id": 464688314,
      "id": 468273203,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3MzIwMw==",
      "diff_hunk": "@@ -76,6 +76,69 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubke\n     const secp256k1_pubkey *pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n \n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey\n+ *  because it may have an odd Y coordinate. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that an output pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 49,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "8409443226b314d23e90f84c210fba0bd97beb78",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think these should be called `tweaked_pubkey32` or similar. It's confusing (to me) to have `output` in the name of a variable which is not, in fact, an out-pointer.",
      "created_at": "2020-08-11T01:23:45Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r468273203",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468273203"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468274865",
      "pull_request_review_id": 464690067,
      "id": 468274865,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3NDg2NQ==",
      "diff_hunk": "@@ -120,9 +120,175 @@ void test_xonly_pubkey(void) {\n     secp256k1_context_destroy(verify);\n }\n \n+void test_xonly_pubkey_tweak(void) {\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char overflows[32];\n+    unsigned char sk[32];\n+    secp256k1_pubkey internal_pk;\n+    secp256k1_xonly_pubkey internal_xonly_pk;\n+    secp256k1_pubkey output_pk;\n+    int pk_parity;\n+    unsigned char tweak[32];\n+    int i;\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    memset(overflows, 0xff, sizeof(overflows));\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, NULL, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n+    CHECK(ecount == 4);\n+    /* NULL internal_xonly_pk zeroes the output_pk */\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n+    CHECK(ecount == 5);\n+    /* NULL tweak zeroes the output_pk */\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+\n+    /* Invalid tweak zeroes the output_pk */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, overflows) == 0);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+\n+    /* A zero tweak is fine */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, zeros64) == 1);\n+\n+    /* Fails if the resulting key was infinity */\n+    for (i = 0; i < count; i++) {\n+        secp256k1_scalar scalar_tweak;\n+        /* Because sk may be negated before adding, we need to try with tweak =\n+         * sk as well as tweak = -sk. */\n+        secp256k1_scalar_set_b32(&scalar_tweak, sk, NULL);\n+        secp256k1_scalar_negate(&scalar_tweak, &scalar_tweak);\n+        secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n+        CHECK((secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, sk) == 0)\n+              || (secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0));\n+        CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    }\n+\n+    /* Invalid pk with a valid tweak */\n+    memset(&internal_xonly_pk, 0, sizeof(internal_xonly_pk));\n+    secp256k1_rand256(tweak);\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+}\n+\n+void test_xonly_pubkey_tweak_add(void) {\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char overflows[32];\n+    unsigned char sk[32];\n+    secp256k1_pubkey internal_pk;\n+    secp256k1_xonly_pubkey internal_xonly_pk;\n+    secp256k1_pubkey output_pk;\n+    secp256k1_xonly_pubkey output_xonly_pk;\n+    unsigned char output_pk32[32];\n+    unsigned char buf32[32];\n+    int pk_parity;\n+    unsigned char tweak[32];\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    memset(overflows, 0xff, sizeof(overflows));\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &output_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, NULL, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    /* invalid pk_parity value */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, 2, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, NULL, tweak) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    memset(tweak, 1, sizeof(tweak));\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &internal_xonly_pk, NULL, &internal_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, output_pk32, &output_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+\n+    /* Wrong pk_parity */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, !pk_parity, &internal_xonly_pk, tweak) == 0);\n+    /* Wrong public key */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &internal_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+\n+    /* Overflowing tweak not allowed */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);",
      "path": "src/modules/extrakeys/tests_impl.h",
      "position": 271,
      "original_position": 131,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "8409443226b314d23e90f84c210fba0bd97beb78",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Similar to the other tests, I'd like this function to end with another `CHECK(ecount == 5);` i.e. check that none of the 0-returns were ARG_CHECK failures",
      "created_at": "2020-08-11T01:29:28Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r468274865",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468274865"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 271,
      "original_line": 271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468537609",
      "pull_request_review_id": 465010134,
      "id": 468537609,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzYwOQ==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;\n+}\n+\n+/* Load a keypair into pk and sk (if non-NULL). This function declassifies pk\n+ * and ARG_CHECKs that the keypair is not invalid. It always initializes sk and\n+ * pk with dummy values. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's\n+     * invalid. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    ret = secp256k1_pubkey_load(ctx, pk, pubkey);\n+    if (sk != NULL) {\n+        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);\n+    }\n+    if (!ret) {\n+        *pk = secp256k1_ge_const_g;\n+        if (sk != NULL) {\n+            *sk = secp256k1_scalar_one;\n+        }\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pubkey_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    secp256k1_ge_even_y(&pk, pubkey_parity);\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+        secp256k1_ge_neg(&pk, &pk);\n+    }\n+\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n+    secp256k1_scalar_cmov(&sk, &secp256k1_scalar_zero, !ret);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 214,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467211405,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agreed; the only place `sk` is used below is in `secp256k1_keypair_save` but this is already gated on `if(ret)`.",
      "created_at": "2020-08-11T12:20:46Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r468537609",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468537609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468655894",
      "pull_request_review_id": 465164275,
      "id": 468655894,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NTg5NA==",
      "diff_hunk": "@@ -438,6 +438,29 @@ void run_sha256_tests(void) {\n     }\n }\n \n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(secp256k1_sha256 *sha1, secp256k1_sha256 *sha2) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char buf2[32];\n+\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 12,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "e8a3d6ce063e9c08135130a83b93fd32385ce87b",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we check `sha2` as well? Also should this be a `VERIFY_CHECK`? I guess in tests.c the distinction doesn't really matter.",
      "created_at": "2020-08-11T15:09:51Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r468655894",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468655894"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468710761",
      "pull_request_review_id": 465234654,
      "id": 468710761,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMDc2MQ==",
      "diff_hunk": "@@ -438,6 +438,29 @@ void run_sha256_tests(void) {\n     }\n }\n \n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(secp256k1_sha256 *sha1, secp256k1_sha256 *sha2) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char buf2[32];\n+\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 12,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "e8a3d6ce063e9c08135130a83b93fd32385ce87b",
      "in_reply_to_id": 468655894,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Tests should use CHECK, because its useful to run the tests without -DVERIFY to make sure that the verifys aren't fixing a bug (e.g. with a side effect in a verify macro)-- and you don't want all the tests to go away when you do that. :)  There is currently no VERIFY_CHECK in tests.c",
      "created_at": "2020-08-11T16:29:44Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r468710761",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/468710761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/471331489",
      "pull_request_review_id": 468277449,
      "id": 471331489,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMzMTQ4OQ==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey\n+ *  because it may have an odd Y coordinate. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that an output pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the parity of the output pubkey (whose serialization is\n+ *                       passed in as output_pubkey32). This must match the\n+ *                       pk_parity value that is returned when calling\n+ *                       secp256k1_xonly_pubkey with the output pubkey, or this\n+ *                       function will fail.\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *output_pubkey32,\n+    int output_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, its value is undefined. (cannot\n+ *               be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, its value is undefined (cannot be NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding tweak times the generator to the x-only public key\n+ *  and secret key parts of the keypair.\n+ *\n+ *  Calling this function and then secp256k1_keypair_pub results in the same\n+ *  public key as calling secp256k1_keypair_xonly_pub and then\n+ *  secp256k1_xonly_pubkey_tweak_add.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting keypair would be\n+ *           invalid (only when the tweak is the negation of the keypair's\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:       ctx: pointer to a context object initialized for validation\n+ *                   (cannot be NULL)\n+ *  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to\n+ *                   an invalid value if this function returns 0 (cannot be\n+ *                   NULL).\n+ *  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according\n+ *                   to secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                   uniformly random 32-byte arrays the chance of being invalid\n+ *                   is negligible (around 1 in 2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *tweak32",
      "path": "include/secp256k1_extrakeys.h",
      "position": 229,
      "original_position": 227,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467136889,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`xonly_pubkey_tweak_add` doesn't have that output value either. You get it when extracting the xonly pubkey from the keypair.",
      "created_at": "2020-08-17T08:45:09Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r471331489",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/471331489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 229,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/471360062",
      "pull_request_review_id": 468277449,
      "id": 471360062,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MDA2Mg==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 44,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467146886,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We're already using \"invalid value\" for `tweak_add`. I think that's the clearest phrasing.",
      "created_at": "2020-08-17T09:37:16Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r471360062",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/471360062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/471431030",
      "pull_request_review_id": 468277449,
      "id": 471431030,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQzMTAzMA==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 224,
      "original_position": 222,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467253138,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You mean essentially replacing the `e` negation with `secp256k1_fe_negate(&pk.y, &pk.y, 1);`?",
      "created_at": "2020-08-17T12:01:07Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r471431030",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/471431030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472190325",
      "pull_request_review_id": 468277449,
      "id": 472190325,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE5MDMyNQ==",
      "diff_hunk": "@@ -438,6 +438,29 @@ void run_sha256_tests(void) {\n     }\n }\n \n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(secp256k1_sha256 *sha1, secp256k1_sha256 *sha2) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char buf2[32];\n+\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 12,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "e8a3d6ce063e9c08135130a83b93fd32385ce87b",
      "in_reply_to_id": 468655894,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Should we check sha2 as well?\r\n\r\nwe check in the next line that `sha1->bytes == sha2->bytes`",
      "created_at": "2020-08-18T13:22:40Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472190325",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472190325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472311943",
      "pull_request_review_id": 468277449,
      "id": 472311943,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMTk0Mw==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 90,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467147668,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:07:32Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472311943",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472311943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472311983",
      "pull_request_review_id": 468277449,
      "id": 472311983,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMTk4Mw==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 92,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467148572,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:07:37Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472311983",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472311983"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312035",
      "pull_request_review_id": 468277449,
      "id": 472312035,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMjAzNQ==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey\n+ *  because it may have an odd Y coordinate. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 100,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467149033,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:07:43Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472312035",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 100,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312146",
      "pull_request_review_id": 468277449,
      "id": 472312146,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMjE0Ng==",
      "diff_hunk": "@@ -76,6 +76,69 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubke\n     const secp256k1_pubkey *pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n \n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey\n+ *  because it may have an odd Y coordinate. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that an output pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 49,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "8409443226b314d23e90f84c210fba0bd97beb78",
      "in_reply_to_id": 468273203,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "okay, fixed",
      "created_at": "2020-08-18T16:07:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472312146",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312231",
      "pull_request_review_id": 468277449,
      "id": 472312231,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMjIzMQ==",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, its value is undefined (cannot\n+ *               be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of pubkey and set\n+ *                     to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding tweak times the generator to it.\n+ *\n+ *  Note that the resulting point can not be represented by an x-only pubkey\n+ *  because it may have an odd Y coordinate. Instead, the output_pubkey is a\n+ *  normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that an output pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The output pubkey is represented by its 32-byte x-only serialization and its\n+ *  pk_parity, which can both be obtained by converting the result of tweak_add\n+ *  to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that output pubkey is a commitment.\n+ *  If the tweak is not chosen in a specific way, the output pubkey can easily\n+ *  be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the output pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:           ctx: pointer to a context object initialized for validation\n+ *                       (cannot be NULL)\n+ *  In: output_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     output_pk_parity: the parity of the output pubkey (whose serialization is\n+ *                       passed in as output_pubkey32). This must match the\n+ *                       pk_parity value that is returned when calling\n+ *                       secp256k1_xonly_pubkey with the output pubkey, or this\n+ *                       function will fail.\n+ *      internal_pubkey: pointer to an x-only public key object to apply the\n+ *                       tweak to (cannot be NULL)\n+ *              tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *output_pubkey32,\n+    int output_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, its value is undefined. (cannot\n+ *               be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, its value is undefined (cannot be NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding tweak times the generator to the x-only public key",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 203,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467149741,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:08:01Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472312231",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312308",
      "pull_request_review_id": 468277449,
      "id": 472312308,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMjMwOA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 24,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467151071,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:08:10Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472312308",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312308"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312464",
      "pull_request_review_id": 468277449,
      "id": 472312464,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMjQ2NA==",
      "diff_hunk": "@@ -0,0 +1,110 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey the algorithm and data.",
      "path": "include/secp256k1_schnorrsig.h",
      "position": null,
      "original_position": 35,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467151252,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:08:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472312464",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312464"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312729",
      "pull_request_review_id": 468277449,
      "id": 472312729,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMjcyOQ==",
      "diff_hunk": "@@ -0,0 +1,105 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_scratch_space *scratch;\n+    int n;\n+\n+    const secp256k1_keypair **keypairs;\n+    const unsigned char **pk;\n+    const unsigned char **sigs;\n+    const unsigned char **msgs;\n+} bench_schnorrsig_data;\n+\n+void bench_schnorrsig_sign(void* arg, int iters) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    int i;\n+    unsigned char msg[32] = \"benchmarkexamplemessagetemplate\";\n+    unsigned char sig[64];\n+\n+    for (i = 0; i < iters; i++) {\n+        msg[0] = i;\n+        msg[1] = i >> 8;\n+        CHECK(secp256k1_schnorrsig_sign(data->ctx, sig, msg, data->keypairs[i], NULL, NULL));\n+    }\n+}\n+\n+void bench_schnorrsig_verify(void* arg, int iters) {\n+    bench_schnorrsig_data *data = (bench_schnorrsig_data *)arg;\n+    int i;\n+\n+    for (i = 0; i < iters; i++) {\n+        secp256k1_xonly_pubkey pk;\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &pk, data->pk[i]) == 1);\n+        CHECK(secp256k1_schnorrsig_verify(data->ctx, data->sigs[i], data->msgs[i], &pk));\n+    }\n+}\n+\n+int main(void) {\n+    int i;\n+    bench_schnorrsig_data data;\n+    int iters = get_iters(10000);\n+\n+    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);\n+    data.scratch = secp256k1_scratch_space_create(data.ctx, 1024 * 1024 * 1024);",
      "path": "src/bench_schnorrsig.c",
      "position": null,
      "original_position": 57,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "c024c80af386e0fd9239db5c6967bdd6fd5b1ebb",
      "in_reply_to_id": 467651908,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed the scratch space from the benchmark",
      "created_at": "2020-08-18T16:08:53Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472312729",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312729"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312795",
      "pull_request_review_id": 468277449,
      "id": 472312795,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMjc5NQ==",
      "diff_hunk": "@@ -241,6 +241,18 @@ static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int o\n \n }\n \n+static void secp256k1_ge_even_y(secp256k1_ge *r, int *y_parity) {",
      "path": "src/group_impl.h",
      "position": null,
      "original_position": 4,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467160229,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2020-08-18T16:09:01Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472312795",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472312795"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472313033",
      "pull_request_review_id": 468277449,
      "id": 472313033,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMzAzMw==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 63,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467186768,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:09:22Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472313033",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472313033"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472313537",
      "pull_request_review_id": 468277449,
      "id": 472313537,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMzUzNw==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 118,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467197869,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yup, `set_b32_seckey` didn't exist when I wrote this. Done.",
      "created_at": "2020-08-18T16:10:00Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472313537",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472313537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472313676",
      "pull_request_review_id": 468277449,
      "id": 472313676,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMzY3Ng==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 124,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 466483085,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:10:13Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472313676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472313676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472313848",
      "pull_request_review_id": 468277449,
      "id": 472313848,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMzg0OA==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;\n+}\n+\n+/* Load a keypair into pk and sk (if non-NULL). This function declassifies pk\n+ * and ARG_CHECKs that the keypair is not invalid. It always initializes sk and\n+ * pk with dummy values. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's\n+     * invalid. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    ret = secp256k1_pubkey_load(ctx, pk, pubkey);\n+    if (sk != NULL) {\n+        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);\n+    }\n+    if (!ret) {\n+        *pk = secp256k1_ge_const_g;\n+        if (sk != NULL) {\n+            *sk = secp256k1_scalar_one;\n+        }\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pubkey_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    secp256k1_ge_even_y(&pk, pubkey_parity);\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+        secp256k1_ge_neg(&pk, &pk);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 466998254,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2020-08-18T16:10:28Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472313848",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472313848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472316428",
      "pull_request_review_id": 468277449,
      "id": 472316428,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxNjQyOA==",
      "diff_hunk": "@@ -0,0 +1,226 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    secp256k1_ge_clear(&pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+    secp256k1_fe_get_b32(output32, &pk.x);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context* ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *y_parity, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(xonly_pubkey != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    secp256k1_pubkey_load(ctx, &pk, pubkey);\n+    secp256k1_ge_even_y(&pk, y_parity);\n+    secp256k1_xonly_pubkey_save(xonly_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output_pubkey != NULL);\n+    memset(output_pubkey, 0, sizeof(*output_pubkey));\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_pubkey_save(output_pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const unsigned char *output_pubkey32, int output_pubkey_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    unsigned char pk_expected32[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(internal_pubkey != NULL);\n+    ARG_CHECK(output_pubkey32 != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        return 0;\n+    }\n+    secp256k1_fe_normalize_var(&pk.x);\n+    secp256k1_fe_normalize_var(&pk.y);\n+    secp256k1_fe_get_b32(pk_expected32, &pk.x);\n+\n+    return memcmp(&pk_expected32, output_pubkey32, 32) == 0\n+            && secp256k1_fe_is_odd(&pk.y) == output_pubkey_parity;\n+}\n+\n+static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {\n+    secp256k1_scalar_get_b32(&keypair->data[0], sk);\n+    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);\n+}\n+\n+\n+static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {\n+    int ret;\n+\n+    secp256k1_scalar_set_b32(sk, &keypair->data[0], NULL);\n+    ret = !secp256k1_scalar_is_zero(sk);\n+    /* We can declassify ret here because sk is only zero if a keypair function\n+     * failed (which zeroes the keypair) and its return value is ignored. */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    ARG_CHECK(ret);\n+    return 1;\n+}\n+\n+/* Load a keypair into pk and sk (if non-NULL). This function declassifies pk\n+ * and ARG_CHECKs that the keypair is not invalid. It always initializes sk and\n+ * pk with dummy values. */\n+static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {\n+    int ret;\n+    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];\n+\n+    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's\n+     * invalid. */\n+    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));\n+    ret = secp256k1_pubkey_load(ctx, pk, pubkey);\n+    if (sk != NULL) {\n+        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);\n+    }\n+    if (!ret) {\n+        *pk = secp256k1_ge_const_g;\n+        if (sk != NULL) {\n+            *sk = secp256k1_scalar_one;\n+        }\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {\n+    secp256k1_scalar sk;\n+    secp256k1_ge pk;\n+    int ret = 0;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(keypair != NULL);\n+    memset(keypair, 0, sizeof(*keypair));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(seckey32 != NULL);\n+\n+    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n+    secp256k1_keypair_save(keypair, &sk, &pk);\n+    memczero(keypair, sizeof(*keypair), !ret);\n+\n+    secp256k1_scalar_clear(&sk);\n+    return ret;\n+}\n+\n+int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(pubkey->data, &keypair->data[32], sizeof(*pubkey));\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pubkey_parity, const secp256k1_keypair *keypair) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {\n+        return 0;\n+    }\n+    secp256k1_ge_even_y(&pk, pubkey_parity);\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+\n+    return 1;\n+}\n+\n+int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *tweak32) {\n+    secp256k1_ge pk;\n+    secp256k1_scalar sk;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(keypair != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n+\n+    ret = secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    memset(keypair, 0, sizeof(*keypair));\n+\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+        secp256k1_ge_neg(&pk, &pk);\n+    }\n+\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n+    secp256k1_scalar_cmov(&sk, &secp256k1_scalar_zero, !ret);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 214,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467211405,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmmm no idea why I added this line... I removed it again.",
      "created_at": "2020-08-18T16:14:40Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472316428",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472316428"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472316615",
      "pull_request_review_id": 468277449,
      "id": 472316615,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxNjYxNQ==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 465854239,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:14:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472316615",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472316615"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472316840",
      "pull_request_review_id": 468277449,
      "id": 472316840,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxNjg0MA==",
      "diff_hunk": "@@ -438,6 +438,29 @@ void run_sha256_tests(void) {\n     }\n }\n \n+/* Tests for the equality of two sha256 structs. This function only produces a\n+ * correct result if an integer multiple of 64 many bytes have been written\n+ * into the hash functions. */\n+void test_sha256_eq(secp256k1_sha256 *sha1, secp256k1_sha256 *sha2) {\n+    unsigned char buf[32] = { 0 };\n+    unsigned char buf2[32];\n+\n+    /* Is buffer fully consumed? */\n+    CHECK((sha1->bytes & 0x3F) == 0);\n+\n+    /* Compare the struct excluding the buffer, because it may be\n+     * uninitialized or already included in the state. */\n+    CHECK(sha1->bytes == sha2->bytes);\n+    CHECK(memcmp(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n+\n+    /* Compare the output */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 19,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467121140,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2020-08-18T16:15:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472316840",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472316840"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 456,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472317416",
      "pull_request_review_id": 468277449,
      "id": 472317416,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxNzQxNg==",
      "diff_hunk": "@@ -9,8 +9,120 @@\n \n #include \"secp256k1_extrakeys.h\"\n \n+static secp256k1_context* api_test_context(int flags, int *ecount) {\n+    secp256k1_context *ctx0 = secp256k1_context_create(flags);\n+    secp256k1_context_set_error_callback(ctx0, counting_illegal_callback_fn, ecount);\n+    secp256k1_context_set_illegal_callback(ctx0, counting_illegal_callback_fn, ecount);\n+    return ctx0;\n+}\n+\n+void test_xonly_pubkey(void) {\n+    secp256k1_pubkey pk;\n+    secp256k1_xonly_pubkey xonly_pk, xonly_pk_tmp;\n+    secp256k1_ge pk1;\n+    secp256k1_ge pk2;\n+    secp256k1_fe y;\n+    unsigned char sk[32];\n+    unsigned char xy_sk[32];\n+    unsigned char buf32[32];\n+    unsigned char ones32[32];\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char tweak[32];\n+    int pk_parity;\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    secp256k1_rand256(sk);\n+    memset(ones32, 0xFF, 32);\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(xy_sk);\n+    CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+\n+    /* Test xonly_pubkey_from_pubkey */\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(sign, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, NULL, &pk_parity, &pk) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, NULL, &pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, NULL) == 0);\n+    CHECK(ecount == 2);\n+\n+    /* Choose a secret key such that the resulting pubkey and xonly_pubkey match. */\n+    memset(sk, 0, sizeof(sk));\n+    sk[0] = 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(memcmp(&pk, &xonly_pk, sizeof(pk)) == 0);\n+    CHECK(pk_parity == 0);\n+\n+    /* Choose a secret key such that pubkey and xonly_pubkey are each others\n+     * negation. */\n+    sk[0] = 2;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n+    CHECK(memcmp(&xonly_pk, &pk, sizeof(xonly_pk)) != 0);\n+    CHECK(pk_parity == 1);\n+    secp256k1_pubkey_load(ctx, &pk1, &pk);\n+    secp256k1_pubkey_load(ctx, &pk2, (secp256k1_pubkey *) &xonly_pk);\n+    CHECK(secp256k1_fe_equal(&pk1.x, &pk2.x) == 1);\n+    secp256k1_fe_negate(&y, &pk2.y, 1);\n+    CHECK(secp256k1_fe_equal(&pk1.y, &y) == 1);\n+\n+    /* Test xonly_pubkey_serialize and xonly_pubkey_parse */\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, NULL, &xonly_pk) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, NULL) == 0);\n+    CHECK(memcmp(buf32, zeros64, 32) == 0);\n+    CHECK(ecount == 2);\n+    {\n+        /* A pubkey filled with 0s will fail to serialize due to pubkey_load\n+         * special casing. */\n+        secp256k1_xonly_pubkey pk_tmp;\n+        memset(&pk_tmp, 0, sizeof(pk_tmp));\n+        CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &pk_tmp) == 0);\n+    }\n+    /* pubkey_load called illegal callback */\n+    CHECK(ecount == 3);\n+\n+    CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, &xonly_pk) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_parse(none, NULL, buf32) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, NULL) == 0);\n+    CHECK(ecount == 2);\n+    /* Invalid field element */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, ones32) == 0);\n+    CHECK(ecount == 2);\n+    /* There's no point with x-coordinate 0 on secp256k1 */\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, zeros64) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, buf32) == 1);\n+\n+    /* Serialization and parse roundtrip */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk_tmp, buf32) == 1);\n+    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(xonly_pk)) == 0);\n+\n+    /* Can't parse a byte string that's not a valid X coordinate */\n+    memset(ones32, 0xFF, sizeof(ones32));\n+    CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk_tmp, ones32) == 0);\n+    CHECK(memcmp(&xonly_pk_tmp, zeros64, sizeof(xonly_pk_tmp)) == 0);",
      "path": "src/modules/extrakeys/tests_impl.h",
      "position": null,
      "original_position": 108,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "95dd2c73c55ce48518d56f7a0d0fb48e59242ddd",
      "in_reply_to_id": 468267313,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2020-08-18T16:16:10Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472317416",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472317416"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 116,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472317508",
      "pull_request_review_id": 468277449,
      "id": 472317508,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxNzUwOA==",
      "diff_hunk": "@@ -120,9 +120,175 @@ void test_xonly_pubkey(void) {\n     secp256k1_context_destroy(verify);\n }\n \n+void test_xonly_pubkey_tweak(void) {\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char overflows[32];\n+    unsigned char sk[32];\n+    secp256k1_pubkey internal_pk;\n+    secp256k1_xonly_pubkey internal_xonly_pk;\n+    secp256k1_pubkey output_pk;\n+    int pk_parity;\n+    unsigned char tweak[32];\n+    int i;\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    memset(overflows, 0xff, sizeof(overflows));\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, NULL, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n+    CHECK(ecount == 4);\n+    /* NULL internal_xonly_pk zeroes the output_pk */\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n+    CHECK(ecount == 5);\n+    /* NULL tweak zeroes the output_pk */\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+\n+    /* Invalid tweak zeroes the output_pk */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, overflows) == 0);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+\n+    /* A zero tweak is fine */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, zeros64) == 1);\n+\n+    /* Fails if the resulting key was infinity */\n+    for (i = 0; i < count; i++) {\n+        secp256k1_scalar scalar_tweak;\n+        /* Because sk may be negated before adding, we need to try with tweak =\n+         * sk as well as tweak = -sk. */\n+        secp256k1_scalar_set_b32(&scalar_tweak, sk, NULL);\n+        secp256k1_scalar_negate(&scalar_tweak, &scalar_tweak);\n+        secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n+        CHECK((secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, sk) == 0)\n+              || (secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0));\n+        CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    }\n+\n+    /* Invalid pk with a valid tweak */\n+    memset(&internal_xonly_pk, 0, sizeof(internal_xonly_pk));\n+    secp256k1_rand256(tweak);\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+}\n+\n+void test_xonly_pubkey_tweak_add(void) {\n+    unsigned char zeros64[64] = { 0 };\n+    unsigned char overflows[32];\n+    unsigned char sk[32];\n+    secp256k1_pubkey internal_pk;\n+    secp256k1_xonly_pubkey internal_xonly_pk;\n+    secp256k1_pubkey output_pk;\n+    secp256k1_xonly_pubkey output_xonly_pk;\n+    unsigned char output_pk32[32];\n+    unsigned char buf32[32];\n+    int pk_parity;\n+    unsigned char tweak[32];\n+\n+    int ecount;\n+    secp256k1_context *none = api_test_context(SECP256K1_CONTEXT_NONE, &ecount);\n+    secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n+    secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n+\n+    memset(overflows, 0xff, sizeof(overflows));\n+    secp256k1_rand256(tweak);\n+    secp256k1_rand256(sk);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n+\n+    ecount = 0;\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &output_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, NULL, pk_parity, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    /* invalid pk_parity value */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, 2, &internal_xonly_pk, tweak) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, NULL, tweak) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    memset(tweak, 1, sizeof(tweak));\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &internal_xonly_pk, NULL, &internal_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, output_pk32, &output_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+\n+    /* Wrong pk_parity */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, !pk_parity, &internal_xonly_pk, tweak) == 0);\n+    /* Wrong public key */\n+    CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &internal_xonly_pk) == 1);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n+\n+    /* Overflowing tweak not allowed */\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n+    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);",
      "path": "src/modules/extrakeys/tests_impl.h",
      "position": 271,
      "original_position": 131,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "8409443226b314d23e90f84c210fba0bd97beb78",
      "in_reply_to_id": 468274865,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2020-08-18T16:16:19Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r472317508",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/472317508"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 271,
      "original_line": 271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/475111431",
      "pull_request_review_id": 472939581,
      "id": 475111431,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExMTQzMQ==",
      "diff_hunk": "@@ -53,6 +53,21 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+/** Keeps a group element as is if it has an even Y and otherwise negates it.\n+ *  y_parity is set to 0 in the former case and to 1 in the latter case.\n+ *  Requires that the coordinates of r are normalized. */\n+static void secp256k1_extrakeys_ge_even_y(secp256k1_ge *r, int *y_parity) {\n+    if (y_parity != NULL) {\n+        *y_parity = 0;\n+    }\n+    if (secp256k1_fe_is_odd(&r->y)) {\n+        secp256k1_fe_negate(&r->y, &r->y, 1);\n+        if (y_parity != NULL) {\n+            *y_parity = 1;\n+        }",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 15,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cea1ed2b60b5b4c34a7ec7d95e9cf98b42e7c4fc",
      "in_reply_to_id": null,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there a reason that y_parity is an outpointer instead of just a return value? I think this and the calling code would be cleaner to just return it.",
      "created_at": "2020-08-22T17:19:44Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r475111431",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/475111431"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/475214628",
      "pull_request_review_id": 473007927,
      "id": 475214628,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxNDYyOA==",
      "diff_hunk": "@@ -53,6 +53,21 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+/** Keeps a group element as is if it has an even Y and otherwise negates it.\n+ *  y_parity is set to 0 in the former case and to 1 in the latter case.\n+ *  Requires that the coordinates of r are normalized. */\n+static void secp256k1_extrakeys_ge_even_y(secp256k1_ge *r, int *y_parity) {\n+    if (y_parity != NULL) {\n+        *y_parity = 0;\n+    }\n+    if (secp256k1_fe_is_odd(&r->y)) {\n+        secp256k1_fe_negate(&r->y, &r->y, 1);\n+        if (y_parity != NULL) {\n+            *y_parity = 1;\n+        }",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 15,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cea1ed2b60b5b4c34a7ec7d95e9cf98b42e7c4fc",
      "in_reply_to_id": 475111431,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was hoping someone would notice this so I could fix it :) Done.",
      "created_at": "2020-08-23T12:39:34Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r475214628",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/475214628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/475521730",
      "pull_request_review_id": 473362984,
      "id": 475521730,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTczMA==",
      "diff_hunk": "@@ -53,6 +53,21 @@ int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char\n     return 1;\n }\n \n+/** Keeps a group element as is if it has an even Y and otherwise negates it.\n+ *  y_parity is set to 0 in the former case and to 1 in the latter case.\n+ *  Requires that the coordinates of r are normalized. */\n+static void secp256k1_extrakeys_ge_even_y(secp256k1_ge *r, int *y_parity) {\n+    if (y_parity != NULL) {\n+        *y_parity = 0;\n+    }\n+    if (secp256k1_fe_is_odd(&r->y)) {\n+        secp256k1_fe_negate(&r->y, &r->y, 1);\n+        if (y_parity != NULL) {\n+            *y_parity = 1;\n+        }",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": null,
      "original_position": 15,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "cea1ed2b60b5b4c34a7ec7d95e9cf98b42e7c4fc",
      "in_reply_to_id": 475111431,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Darn. I did notice this, but I just assumed that there was some policy that only error codes are returned by functions in libsecp256k1.  I should have at least asked.",
      "created_at": "2020-08-24T11:03:34Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r475521730",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/475521730"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478711634",
      "pull_request_review_id": 477104078,
      "id": 478711634,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcxMTYzNA==",
      "diff_hunk": "@@ -115,6 +128,28 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret);\n \n+    /* Test keypair_create and keypair_xonly_tweak_add. */\n+#if ENABLE_MODULE_EXTRAKEYS\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    /* The tweak is not treated as a secret in keypair_tweak_add */\n+    VALGRIND_MAKE_MEM_DEFINED(msg, 32);\n+    ret = secp256k1_keypair_xonly_tweak_add(ctx, &keypair, msg);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+#endif\n+\n+#if ENABLE_MODULE_SCHNORRSIG\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL);",
      "path": "src/valgrind_ctime_test.c",
      "position": 59,
      "original_position": 57,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2ebf20f30b733a940e3aacf2e6bf756f1ffc74d9",
      "in_reply_to_id": null,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\r\nCHECK(ret == 1);\r\n\r\nRight after keypair_create,  if you change this file again. Otherwise it can go in an after the fact PR.\r\n",
      "created_at": "2020-08-27T21:41:16Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r478711634",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478711634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 150,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478722260",
      "pull_request_review_id": 477117034,
      "id": 478722260,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyMjI2MA==",
      "diff_hunk": "@@ -223,8 +225,14 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     secp256k1_gej_set_ge(&pkj, &pk);\n     secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n \n-    return secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 22,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "79da28a01d28dd7792ab77cc5d3b16450e60303d",
      "in_reply_to_id": null,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "secp256k1_gej_has_quad_y_var  is unused after this (except for the tests). It was added in #402, presumably for the schnorr support. Should it get removed?  @sipa ?",
      "created_at": "2020-08-27T22:06:20Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r478722260",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478722260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478724738",
      "pull_request_review_id": 477120149,
      "id": 478724738,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNDczOA==",
      "diff_hunk": "@@ -223,8 +225,14 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     secp256k1_gej_set_ge(&pkj, &pk);\n     secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n \n-    return secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 22,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "79da28a01d28dd7792ab77cc5d3b16450e60303d",
      "in_reply_to_id": 478722260,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think we have any immediate use for it in this library anymore really... not just gej_has_quad_y, but also fe_is_quad_var, num_jacobi, and possibly ge_set_xquad?",
      "created_at": "2020-08-27T22:13:02Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r478724738",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478724738"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478819939",
      "pull_request_review_id": 477228058,
      "id": 478819939,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxOTkzOQ==",
      "diff_hunk": "@@ -223,8 +225,14 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     secp256k1_gej_set_ge(&pkj, &pk);\n     secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n \n-    return secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 22,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "79da28a01d28dd7792ab77cc5d3b16450e60303d",
      "in_reply_to_id": 478722260,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ge_set_xquad is just the natural behaviour of using a square root to recover y.",
      "created_at": "2020-08-28T04:10:42Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r478819939",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478819939"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478824522",
      "pull_request_review_id": 477233192,
      "id": 478824522,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgyNDUyMg==",
      "diff_hunk": "@@ -223,8 +225,14 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     secp256k1_gej_set_ge(&pkj, &pk);\n     secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n \n-    return secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": null,
      "original_position": 22,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "79da28a01d28dd7792ab77cc5d3b16450e60303d",
      "in_reply_to_id": 478722260,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, that's why I said maybe. The alternative is merging it into ge_set_xo_var (which would be the only call site left, I believe).",
      "created_at": "2020-08-28T04:31:05Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r478824522",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/478824522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/480354321",
      "pull_request_review_id": 478896753,
      "id": 480354321,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1NDMyMQ==",
      "diff_hunk": "@@ -115,6 +128,28 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret);\n \n+    /* Test keypair_create and keypair_xonly_tweak_add. */\n+#if ENABLE_MODULE_EXTRAKEYS\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    /* The tweak is not treated as a secret in keypair_tweak_add */\n+    VALGRIND_MAKE_MEM_DEFINED(msg, 32);\n+    ret = secp256k1_keypair_xonly_tweak_add(ctx, &keypair, msg);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+#endif\n+\n+#if ENABLE_MODULE_SCHNORRSIG\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &keypair, key);\n+    ret = secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL);",
      "path": "src/valgrind_ctime_test.c",
      "position": 59,
      "original_position": 57,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2ebf20f30b733a940e3aacf2e6bf756f1ffc74d9",
      "in_reply_to_id": 478711634,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed this because it's trivial.",
      "created_at": "2020-08-31T19:34:21Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r480354321",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/480354321"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 150,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481454221",
      "pull_request_review_id": 480144996,
      "id": 481454221,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NDIyMQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 37,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Shouldn't be `a 32-byte array` instead of a `32-byte public key` ?\r\n\r\n* `secp256k1_xonly_pubkey_serialize` mentions serializing to a `32-byte sequence`\r\n*  we can't qualify input as a valid pubkey before to actually parse it\r\n\r\nNote, I don't know how much terminology rigor libsecp256k1 bind to, please discard this comment or any other following of the same type if meaningfulness",
      "created_at": "2020-09-01T21:55:38Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481454221",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481454221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481462001",
      "pull_request_review_id": 480144996,
      "id": 481462001,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MjAwMQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey",
      "path": "include/secp256k1_extrakeys.h",
      "position": 129,
      "original_position": 129,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As this function is part of the exported API, it could be nice to inform user how to effectively pick it up such that `internal_pubkey` and `tweak` argument addition are the only solution for `tweaked_pubkey32`. Or maybe it's documented elsewhere ?",
      "created_at": "2020-09-01T22:14:37Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481462001",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481462001"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481464689",
      "pull_request_review_id": 480144996,
      "id": 481464689,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NDY4OQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 157,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Rather `rotate secret`, it's not expected caller retries with same already-invalid secret ?",
      "created_at": "2020-09-01T22:21:16Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481464689",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481464689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481469111",
      "pull_request_review_id": 480144996,
      "id": 481469111,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2OTExMQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, it's set to an invalid value.\n+ *               (cannot be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n+ *               NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding the generator multiplied with tweak32 to the\n+ *  x-only public key and secret key parts of the keypair.",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 206,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "With regards to the secret key, the `tweak32` is only added, its product with the generator isn't distributed on it ?",
      "created_at": "2020-09-01T22:33:45Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481469111",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481469111"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481475728",
      "pull_request_review_id": 480144996,
      "id": 481475728,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTcyOA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point",
      "path": "include/secp256k1_extrakeys.h",
      "position": 78,
      "original_position": 78,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why this API choice to give liberality to the caller to pass a `null` pk_parity ?",
      "created_at": "2020-09-01T22:53:23Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481475728",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481475728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481480781",
      "pull_request_review_id": 480144996,
      "id": 481480781,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4MDc4MQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.",
      "path": "include/secp256k1_extrakeys.h",
      "position": 170,
      "original_position": 170,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How can `secp256k1_keypair_pub` returns 0 ? It doesn't sound to load pubkey through `secp256k1_keypair_load` as `secp256k1_keypair_xonly_pub` is doing ?\r\n\r\nI don't see a test again a zero'ed keypair among coverage.",
      "created_at": "2020-09-01T23:08:38Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481480781",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481480781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 170,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481490521",
      "pull_request_review_id": 480144996,
      "id": 481490521,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MDUyMQ==",
      "diff_hunk": "@@ -164,6 +164,19 @@ static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n+/* Initializes a sha256 struct and writes the 64 byte string\n+ * SHA256(tag)||SHA256(tag) into it. */\n+static void secp256k1_sha256_initialize_tagged(secp256k1_sha256 *hash, const unsigned char *tag, size_t taglen) {",
      "path": "src/hash_impl.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note, it 's a bit confusing for newcomers that `hash` denotes the cryptographic hash function struct instead of the message digest :) \r\n\r\nI spent a bit of time checking tagged hashes, failing to get back hardcoded values (`secp256k1_nonce_function_bip_340_sha256_tagged`), before realizing it was actually a midstate ",
      "created_at": "2020-09-01T23:39:15Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481490521",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481490521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481493842",
      "pull_request_review_id": 480144996,
      "id": 481493842,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5Mzg0Mg==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 134,
      "original_position": 134,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is a beginner question, but the pattern of bit-wising `ret` instead of returning directly a failure in case of invalid keypair is to lean towards constant-time evaluation and thus hopefully thwart side-channels ? \r\n\r\nIn fact that's a spec deviation as in \"Default signing\" it requires \"Fail if d' = 0 or d' >= n\" ? Or does the spec only mandates a logical order not an algorithm implementation one ?",
      "created_at": "2020-09-01T23:50:09Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481493842",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481493842"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 134,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481498617",
      "pull_request_review_id": 480144996,
      "id": 481498617,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5ODYxNw==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 134,
      "original_position": 134,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481493842,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there a test passing a zero'ed out keypair ? I don't see one  in `test_schnorrsig_api` neither among test vectors.",
      "created_at": "2020-09-02T00:06:52Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481498617",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481498617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 134,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481500486",
      "pull_request_review_id": 480144996,
      "id": 481500486,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwMDQ4Ng==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 147,
      "original_position": 147,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I guess this is also a side-channel protection to set at least a nonce of 1 in case of a failure during nonce generation ? But I don't see how it is masking anything as if we assume an attacker can inject fault and this is a hardcoded backup nonce that's something we assume is known too ?",
      "created_at": "2020-09-02T00:13:23Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481500486",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481500486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481506817",
      "pull_request_review_id": 480144996,
      "id": 481506817,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNjgxNw==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 211,
      "original_position": 211,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How does `secp256k1_xonly_pubkey_load` can ever trigger this failure as `secp256k1_pubkey_load` always returns success ? \r\n\r\nDoes this encode \"The function lift_x(x), where x is an integer in range 0..p-1, returns the point P for which x(P) = x[9] and has_even_y(P), or fails if no such point exists.\" spec requirement ?",
      "created_at": "2020-09-02T00:35:34Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481506817",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481506817"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481511721",
      "pull_request_review_id": 480144996,
      "id": 481511721,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMTcyMQ==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);\n+    secp256k1_gej_set_ge(&pkj, &pk);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+\n+    secp256k1_ge_set_gej_var(&r, &rj);\n+    if (secp256k1_ge_is_infinity(&r)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 229,
      "original_position": 229,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is the check to outlaw point at infinity actually explicitly part of the spec ?",
      "created_at": "2020-09-02T00:48:08Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481511721",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481511721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 229,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481623140",
      "pull_request_review_id": 480461870,
      "id": 481623140,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYyMzE0MA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point",
      "path": "include/secp256k1_extrakeys.h",
      "position": 78,
      "original_position": 78,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481475728,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's an outarg that the caller probably never cares about (perhaps it shouldn't even be exposed).",
      "created_at": "2020-09-02T03:46:17Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481623140",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481623140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481625290",
      "pull_request_review_id": 480462490,
      "id": 481625290,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYyNTI5MA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.",
      "path": "include/secp256k1_extrakeys.h",
      "position": 170,
      "original_position": 170,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481480781,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Bad arguments will make it return zero. There are tests:\r\n\r\nsrc/secp256k1/src/modules/extrakeys/tests_impl.h:    CHECK(secp256k1_keypair_pub(none, NULL, &keypair) == 0);\r\nsrc/secp256k1/src/modules/extrakeys/tests_impl.h:    CHECK(secp256k1_keypair_pub(none, &pk, NULL) == 0);\r\n",
      "created_at": "2020-09-02T03:48:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481625290",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481625290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 170,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481627074",
      "pull_request_review_id": 480462944,
      "id": 481627074,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYyNzA3NA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, it's set to an invalid value.\n+ *               (cannot be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n+ *               NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding the generator multiplied with tweak32 to the\n+ *  x-only public key and secret key parts of the keypair.",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 206,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481469111,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The text is correct, your comment indicates it could be less confusing.  Might I suggest \"Tweak a keypair by adding tweak32 to the secret key and updating the public key accordingly\"?",
      "created_at": "2020-09-02T03:50:23Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481627074",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481627074"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481628613",
      "pull_request_review_id": 480463425,
      "id": 481628613,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYyODYxMw==",
      "diff_hunk": "@@ -164,6 +164,19 @@ static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n+/* Initializes a sha256 struct and writes the 64 byte string\n+ * SHA256(tag)||SHA256(tag) into it. */\n+static void secp256k1_sha256_initialize_tagged(secp256k1_sha256 *hash, const unsigned char *tag, size_t taglen) {",
      "path": "src/hash_impl.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481490521,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How?  The argument is typed?",
      "created_at": "2020-09-02T03:51:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481628613",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481628613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481637645",
      "pull_request_review_id": 480466797,
      "id": 481637645,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYzNzY0NQ==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 134,
      "original_position": 134,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481493842,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The spec specifies only the functional behaviour equivalent to a particular algorithm, otherwise you couldn't implement it in C (whos compilers don't necessarirly perform the specified operations only equivalent ones) or run it on modern computers (e.g. superscalar processors). :)\r\n\r\nAnd yes, there cannot be any kind of branching or early termination which is casually dependant on secret information in constant time code.  Using the AND accomplishes that, and the tests validate that your compiler's result contains no secret dependant branches or memory accesses.  If you go stick a conditional return there the ctime_test will fail.\r\n\r\n> Is there a test passing a zero'ed out keypair ? I don't see one in test_schnorrsig_api \r\n\r\nAgreed, I don't see one. There should be one.",
      "created_at": "2020-09-02T04:01:15Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481637645",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481637645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 134,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481646012",
      "pull_request_review_id": 480469469,
      "id": 481646012,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY0NjAxMg==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 147,
      "original_position": 147,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481500486,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This has nothing to do with injecting a fault. For correctness the algorithm must check that k is not zero, because 0*G is the point at infinity and cannot be serialized.  But the operation of the code must not contain any branches which depend on secret data nor can it otherwise change its execution time conditional on secret data, so it just substitutes in dummy data to keep everything well defined and constant time.\r\n\r\nDown below there is a conditional zero that nukes the output if its invalid:\r\n\r\nmemczero(sig64, 64, !ret);\r\n",
      "created_at": "2020-09-02T04:10:16Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481646012",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481646012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481651685",
      "pull_request_review_id": 480471094,
      "id": 481651685,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY1MTY4NQ==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 211,
      "original_position": 211,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481506817,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "secp256k1_xonly_pubkey_load calls secp256k1_pubkey_load, which returns 0 based on secp256k1_fe_is_zero(&ge->x).\r\n\r\nIt is also an API violation to call this function on an input where the parse which created the secp256k1_xonly_pubkey failed.",
      "created_at": "2020-09-02T04:16:11Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481651685",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481651685"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481658725",
      "pull_request_review_id": 480473310,
      "id": 481658725,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY1ODcyNQ==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);\n+    secp256k1_gej_set_ge(&pkj, &pk);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+\n+    secp256k1_ge_set_gej_var(&r, &rj);\n+    if (secp256k1_ge_is_infinity(&r)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 229,
      "original_position": 229,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481511721,
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Fail if not has_even_y(R) or x(R) ≠ r.\"  cannot be true if R is infinity.  However, the BIP was more clear on this point until August 18th and should be fixed. @sipa 968096c451158b9d48446703dafe7cb96b97800c made the BIP unclear in this respect.\r\n\r\nGood catch.",
      "created_at": "2020-09-02T04:23:32Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r481658725",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/481658725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 229,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482047504",
      "pull_request_review_id": 480791168,
      "id": 482047504,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzUwNA==",
      "diff_hunk": "@@ -0,0 +1,248 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": 45,
      "original_position": 45,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": null,
      "user": {
        "login": "jrawsthorne",
        "id": 777143,
        "node_id": "MDQ6VXNlcjc3NzE0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/777143?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jrawsthorne",
        "html_url": "https://github.com/jrawsthorne",
        "followers_url": "https://api.github.com/users/jrawsthorne/followers",
        "following_url": "https://api.github.com/users/jrawsthorne/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jrawsthorne/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jrawsthorne/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jrawsthorne/subscriptions",
        "organizations_url": "https://api.github.com/users/jrawsthorne/orgs",
        "repos_url": "https://api.github.com/users/jrawsthorne/repos",
        "events_url": "https://api.github.com/users/jrawsthorne/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jrawsthorne/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What's the reason for the memset here",
      "created_at": "2020-09-02T12:57:48Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r482047504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482047504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 45,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482051822",
      "pull_request_review_id": 480796982,
      "id": 482051822,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MTgyMg==",
      "diff_hunk": "@@ -0,0 +1,248 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": 45,
      "original_position": 45,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 482047504,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It can fail at https://github.com/bitcoin-core/secp256k1/pull/558/files/fb442254ef88d6bfcfe76cf25236ebda02bad795#diff-4b25274d7806d13aa4c1e7d4ce22340cR48 and I'm guessing you don't want anyone to try to use results if they forgot to check.",
      "created_at": "2020-09-02T13:04:20Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r482051822",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482051822"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 45,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482056168",
      "pull_request_review_id": 480802818,
      "id": 482056168,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjE2OA==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, it's set to an invalid value.\n+ *               (cannot be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n+ *               NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding the generator multiplied with tweak32 to the\n+ *  x-only public key and secret key parts of the keypair.",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 206,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481469111,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I also am reading this the \"wrong way\". I like @gmaxwell suggestion.",
      "created_at": "2020-09-02T13:10:57Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r482056168",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482056168"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482104495",
      "pull_request_review_id": 480866400,
      "id": 482104495,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwNDQ5NQ==",
      "diff_hunk": "@@ -0,0 +1,248 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {\n+    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);\n+}\n+\n+static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {\n+    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);\n+}\n+\n+int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {\n+    secp256k1_ge pk;\n+    secp256k1_fe x;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    ARG_CHECK(input32 != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&x, input32)) {\n+        return 0;\n+    }\n+    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(pubkey, &pk);\n+    return 1;\n+}\n+\n+int secp256k1_xonly_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output32 != NULL);\n+    memset(output32, 0, 32);",
      "path": "src/modules/extrakeys/main_impl.h",
      "position": 45,
      "original_position": 45,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 482047504,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "the policy in libsecp is to zero out the outputs in case of failure\r\nand by putting it on top it will happen even if we'll add more failure cases in the future.",
      "created_at": "2020-09-02T14:17:02Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r482104495",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482104495"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 45,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482487895",
      "pull_request_review_id": 481312071,
      "id": 482487895,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ4Nzg5NQ==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);\n+    secp256k1_gej_set_ge(&pkj, &pk);\n+    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+\n+    secp256k1_ge_set_gej_var(&r, &rj);\n+    if (secp256k1_ge_is_infinity(&r)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 229,
      "original_position": 229,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481511721,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fix is here: https://github.com/sipa/bips/pull/214",
      "created_at": "2020-09-02T21:25:28Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r482487895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/482487895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 229,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483242845",
      "pull_request_review_id": 482188501,
      "id": 483242845,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI0Mjg0NQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point",
      "path": "include/secp256k1_extrakeys.h",
      "position": 78,
      "original_position": 78,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481475728,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@ariard you don't need pk_parity if you don't need anyone to call `secp256k1_xonly_pubkey_tweak_add_check` on your pubkey.",
      "created_at": "2020-09-03T20:42:30Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483242845",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483242845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483271951",
      "pull_request_review_id": 482188501,
      "id": 483271951,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3MTk1MQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey",
      "path": "include/secp256k1_extrakeys.h",
      "position": 129,
      "original_position": 129,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481462001,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's better we don't do that because it will either be underspecified or quite long. This is a comparably low-level function and it is not the job its API documentation to provide instructions for how to use it in (various) cryptographic schemes. BIP 341 includes a binding commitment construction that makes use of `secp256k1_xonly_pubkey_tweak_add_check`. In the longer term we should have a functions that creates BIP 341 commitments instead of the low-level tweak_add functions (see also https://github.com/bitcoin-core/secp256k1/issues/702).",
      "created_at": "2020-09-03T21:48:02Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483271951",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483271951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483561086",
      "pull_request_review_id": 482578914,
      "id": 483561086,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2MTA4Ng==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 37,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481454221,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In BIP 340 public keys are simply 32 byte arrays. But agree that in libsecp that's confusing because public keys already refer to the parsed objects. Pushed fix that replaces \"32-byte pubkey\" with \"32-byte sequence\".",
      "created_at": "2020-09-04T11:36:17Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483561086",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483561086"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483561379",
      "pull_request_review_id": 482579309,
      "id": 483561379,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2MTM3OQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 157,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481464689,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed ",
      "created_at": "2020-09-04T11:36:59Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483561379",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483561379"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483561492",
      "pull_request_review_id": 482579465,
      "id": 483561492,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2MTQ5Mg==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point\n+ *                     encoded by xonly_pubkey is the negation of the pubkey and\n+ *                     set to 0 otherwise. (can be NULL)\n+ *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *xonly_pubkey,\n+    int *pk_parity,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak an x-only public key by adding the generator multiplied with tweak32\n+ *  to it.\n+ *\n+ *  Note that the resulting point can not in general be represented by an x-only\n+ *  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey\n+ *  is a normal secp256k1_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *\n+ *  Args:           ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n+ *                       to an invalid value if this function returns 0 (cannot\n+ *                       be NULL)\n+ *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n+ *                       (cannot be NULL).\n+ *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n+ *                       according to secp256k1_ec_seckey_verify, this function\n+ *                       returns 0. For uniformly random 32-byte arrays the\n+ *                       chance of being invalid is negligible (around 1 in\n+ *                       2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *output_pubkey,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Checks that a tweaked pubkey is the result of calling\n+ *  secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.\n+ *\n+ *  The tweaked pubkey is represented by its 32-byte x-only serialization and\n+ *  its pk_parity, which can both be obtained by converting the result of\n+ *  tweak_add to a secp256k1_xonly_pubkey.\n+ *\n+ *  Note that this alone does _not_ verify that the tweaked pubkey is a\n+ *  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey\n+ *  can easily be the result of a different internal_pubkey and tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n+ *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n+ *  Args:            ctx: pointer to a context object initialized for verification\n+ *                       (cannot be NULL)\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n+ *                        is passed in as tweaked_pubkey32). This must match the\n+ *                        pk_parity value that is returned when calling\n+ *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n+ *                        this function will fail.\n+ *       internal_pubkey: pointer to an x-only public key object to apply the\n+ *                        tweak to (cannot be NULL)\n+ *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n+    const secp256k1_context* ctx,\n+    const unsigned char *tweaked_pubkey32,\n+    int tweaked_pk_parity,\n+    const secp256k1_xonly_pubkey *internal_pubkey,\n+    const unsigned char *tweak32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5);\n+\n+/** Compute the keypair for a secret key.\n+ *\n+ *  Returns: 1: secret was valid, keypair is ready to use\n+ *           0: secret was invalid, try again\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out: keypair: pointer to the created keypair (cannot be NULL)\n+ *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n+    const secp256k1_context* ctx,\n+    secp256k1_keypair *keypair,\n+    const unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the public key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n+ *               the keypair public key. If not, it's set to an invalid value.\n+ *               (cannot be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Get the x-only public key from a keypair.\n+ *\n+ *  This is the same as calling secp256k1_keypair_pub and then\n+ *  secp256k1_xonly_pubkey_from_pubkey.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n+ *               to the keypair public key after converting it to an\n+ *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n+ *               NULL).\n+ *    pk_parity: pointer to an integer that will be set to the pk_parity\n+ *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey *pubkey,\n+    int *pk_parity,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(4);\n+\n+/** Tweak a keypair by adding the generator multiplied with tweak32 to the\n+ *  x-only public key and secret key parts of the keypair.",
      "path": "include/secp256k1_extrakeys.h",
      "position": null,
      "original_position": 206,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481469111,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed",
      "created_at": "2020-09-04T11:37:14Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483561492",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483561492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483561578",
      "pull_request_review_id": 482579586,
      "id": 483561578,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2MTU3OA==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 134,
      "original_position": 134,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481493842,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch, fixed",
      "created_at": "2020-09-04T11:37:26Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483561578",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483561578"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 134,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483794809",
      "pull_request_review_id": 482877989,
      "id": 483794809,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NDgwOQ==",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+#ifndef SECP256K1_EXTRAKEYS_H\n+#define SECP256K1_EXTRAKEYS_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Opaque data structure that holds a parsed and valid \"x-only\" public key.\n+ *  An x-only pubkey encodes a point whose Y coordinate is even. It is\n+ *  serialized using only its X coordinate (32 bytes). See BIP-340 for more\n+ *  information about x-only pubkeys.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_xonly_pubkey_serialize and\n+ *  secp256k1_xonly_pubkey_parse.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_xonly_pubkey;\n+\n+/** Opaque data structure that holds a keypair consisting of a secret and a\n+ *  public key.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 96 bytes in size, and can be safely copied/moved.\n+ */\n+typedef struct {\n+    unsigned char data[96];\n+} secp256k1_keypair;\n+\n+/** Parse a 32-byte public key into a xonly_pubkey object.\n+ *\n+ *  Returns: 1 if the public key was fully valid.\n+ *           0 if the public key could not be parsed or is invalid.\n+ *\n+ *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n+ *               parsed version of input. If not, it's set to an invalid value.\n+ *               (cannot be NULL).\n+ *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_xonly_pubkey* pubkey,\n+    const unsigned char *input32\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize an xonly_pubkey object into a 32-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n+ *                 (cannot be NULL).\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n+ *                 initialized public key (cannot be NULL).\n+ */\n+SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *output32,\n+    const secp256k1_xonly_pubkey* pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.\n+ *\n+ *  Returns: 1 if the public key was successfully converted\n+ *           0 otherwise\n+ *\n+ *  Args:         ctx: pointer to a context object (cannot be NULL)\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n+ *                     converted public key (cannot be NULL)\n+ *          pk_parity: pointer to an integer that will be set to 1 if the point",
      "path": "include/secp256k1_extrakeys.h",
      "position": 78,
      "original_position": 78,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481475728,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I see. I think a further slight improvement would be to rename this function to `secp256k1_xonly_pubkey_tweak_addition_check`. As of today, it's using two verbs instead of only one to designate the checking of a past transformation of  a public key.",
      "created_at": "2020-09-04T18:50:42Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483794809",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483794809"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483795563",
      "pull_request_review_id": 482878961,
      "id": 483795563,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NTU2Mw==",
      "diff_hunk": "@@ -164,6 +164,19 @@ static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out\n     memcpy(out32, (const unsigned char*)out, 32);\n }\n \n+/* Initializes a sha256 struct and writes the 64 byte string\n+ * SHA256(tag)||SHA256(tag) into it. */\n+static void secp256k1_sha256_initialize_tagged(secp256k1_sha256 *hash, const unsigned char *tag, size_t taglen) {",
      "path": "src/hash_impl.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481490521,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I didn't catch at first hash was in fact the hasher and not the message digest. I guess that's a matter of habits, renaming would to costly for the ones used to.",
      "created_at": "2020-09-04T18:52:33Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483795563",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483795563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483798415",
      "pull_request_review_id": 482882677,
      "id": 483798415,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5ODQxNQ==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 211,
      "original_position": 211,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481506817,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think I misunderstood the call trace with regards to `illegal_callback`. I though it was aborting outside of testing and thus can't return 0.",
      "created_at": "2020-09-04T18:59:41Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r483798415",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/483798415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/484041486",
      "pull_request_review_id": 483124071,
      "id": 484041486,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA0MTQ4Ng==",
      "diff_hunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/nonce\")||SHA256(\"BIP0340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x46615b35ul;\n+    sha->s[1] = 0xf4bfbff7ul;\n+    sha->s[2] = 0x9f8dc671ul;\n+    sha->s[3] = 0x83627ab3ul;\n+    sha->s[4] = 0x60217180ul;\n+    sha->s[5] = 0x57358661ul;\n+    sha->s[6] = 0x21a29e54ul;\n+    sha->s[7] = 0x68b07b4cul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/aux\")||SHA256(\"BIP0340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x24dd3219ul;\n+    sha->s[1] = 0x4eba7e70ul;\n+    sha->s[2] = 0xca0fabb9ul;\n+    sha->s[3] = 0x0fa3166dul;\n+    sha->s[4] = 0x3afbe4b1ul;\n+    sha->s[5] = 0x4c44df97ul;\n+    sha->s[6] = 0x4aac2739ul;\n+    sha->s[7] = 0x249e850aul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP0340/nonce\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP0340/challenge\")||SHA256(\"BIP0340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x9cecba11ul;\n+    sha->s[1] = 0x23925381ul;\n+    sha->s[2] = 0x11679112ul;\n+    sha->s[3] = 0xd1627e0ful;\n+    sha->s[4] = 0x97c87550ul;\n+    sha->s[5] = 0x003cc765ul;\n+    sha->s[6] = 0x90f61164ul;\n+    sha->s[7] = 0x33e9b66aul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    secp256k1_fe_normalize_var(&r.y);\n+    if (secp256k1_fe_is_odd(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 211,
      "original_position": 211,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "fb442254ef88d6bfcfe76cf25236ebda02bad795",
      "in_reply_to_id": 481506817,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@ariad, the `illegal_callback` does abort in the default implementation as you noted, \r\nbut users can override this to a non-aborting callback in runtime (https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h#L275),\r\nOr even in compile time: https://github.com/bitcoin-core/secp256k1/blob/master/configure.ac#L139.\r\nAlthough the required implementation of these callbacks isn't documented properly.\r\n(see https://github.com/rust-bitcoin/rust-secp256k1/issues/228 for example)",
      "created_at": "2020-09-06T08:42:27Z",
      "updated_at": "2020-09-06T18:59:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r484041486",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/484041486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/484641772",
      "pull_request_review_id": 483785318,
      "id": 484641772,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY0MTc3Mg==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 224,
      "original_position": 222,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467253138,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think he means doing the negation at `secp256k1_xonly_pubkey_parse` time, where currently a negation happens 50% of the time in one direction (and instead doing it the other 50% in the other direction). Seems very hard to do in a way that results in a sane API.",
      "created_at": "2020-09-08T04:21:45Z",
      "updated_at": "2020-09-08T04:25:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r484641772",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/484641772"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/485057850",
      "pull_request_review_id": 484318491,
      "id": 485057850,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1Nzg1MA==",
      "diff_hunk": "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_scalar_mul(&e, &e, &sk);\n+    secp256k1_scalar_add(&e, &e, &k);\n+    secp256k1_scalar_get_b32(&sig64[32], &e);\n+\n+    memczero(sig64, 64, !ret);\n+    secp256k1_scalar_clear(&k);\n+    secp256k1_scalar_clear(&sk);\n+    memset(seckey, 0, sizeof(seckey));\n+\n+    return ret;\n+}\n+\n+int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_xonly_pubkey *pubkey) {\n+    secp256k1_scalar s;\n+    secp256k1_scalar e;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_gej pkj;\n+    secp256k1_fe rx;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32];\n+    int overflow;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {\n+        return 0;\n+    }\n+\n+    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n+    if (overflow) {\n+        return 0;\n+    }\n+\n+    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {\n+        return 0;\n+    }\n+\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    secp256k1_fe_get_b32(buf, &pk.x);\n+    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    secp256k1_scalar_set_b32(&e, buf, NULL);\n+\n+    /* Compute rj =  s*G + (-e)*pkj */\n+    secp256k1_scalar_negate(&e, &e);",
      "path": "src/modules/schnorrsig/main_impl.h",
      "position": 224,
      "original_position": 222,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "2c8e321a1b543e1f008a32c0a9091b752ccf8e72",
      "in_reply_to_id": 467253138,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed.  Now that I look again, it is even harder to implement (API-wise) than I had realized at the time I wrote my comment.",
      "created_at": "2020-09-08T16:43:04Z",
      "updated_at": "2020-09-08T16:43:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r485057850",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/485057850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/486486320",
      "pull_request_review_id": 486122392,
      "id": 486486320,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NjMyMA==",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to\n+ *           return an error.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey, the algorithm description, and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP0340/nonce\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and\n+ *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg32,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_nonce_function_hardened noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 97,
      "original_position": 97,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Are we planning to change the API to allow arbitrary message lengths, or add a new function to the API later to allow arbitrary message lengths?",
      "created_at": "2020-09-10T16:43:08Z",
      "updated_at": "2020-09-10T16:43:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r486486320",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/486486320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 97,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/486491020",
      "pull_request_review_id": 486128368,
      "id": 486491020,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MTAyMA==",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ *  Bitcoin Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ */\n+\n+/** A pointer to a function to deterministically generate a nonce.\n+ *\n+ *  Same as secp256k1_nonce function with the exception of accepting an\n+ *  additional pubkey argument and not requiring an attempt argument. The pubkey\n+ *  argument can protect signature schemes with key-prefixed challenge hash\n+ *  inputs against reusing the nonce when signing with the wrong precomputed\n+ *  pubkey.\n+ *\n+ *  Returns: 1 if a nonce was successfully generated. 0 will cause signing to\n+ *           return an error.\n+ *  Out:     nonce32:   pointer to a 32-byte array to be filled by the function.\n+ *  In:      msg32:     the 32-byte message hash being verified (will not be NULL)\n+ *           key32:     pointer to a 32-byte secret key (will not be NULL)\n+ *      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32\n+ *                      (will not be NULL)\n+ *           algo16:    pointer to a 16-byte array describing the signature\n+ *                      algorithm (will not be NULL).\n+ *           data:      Arbitrary data pointer that is passed through.\n+ *\n+ *  Except for test cases, this function should compute some cryptographic hash of\n+ *  the message, the key, the pubkey, the algorithm description, and data.\n+ */\n+typedef int (*secp256k1_nonce_function_hardened)(\n+    unsigned char *nonce32,\n+    const unsigned char *msg32,\n+    const unsigned char *key32,\n+    const unsigned char *xonly_pk32,\n+    const unsigned char *algo16,\n+    void *data\n+);\n+\n+/** An implementation of the nonce generation function as defined in Bitcoin\n+ *  Improvement Proposal 340 \"Schnorr Signatures for secp256k1\"\n+ *  (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n+ *\n+ *  If a data pointer is passed, it is assumed to be a pointer to 32 bytes of\n+ *  auxiliary random data as defined in BIP-340. If the data pointer is NULL,\n+ *  schnorrsig_sign does not produce BIP-340 compliant signatures. The algo16\n+ *  argument must be non-NULL, otherwise the function will fail and return 0.\n+ *  The hash will be tagged with algo16 after removing all terminating null\n+ *  bytes. Therefore, to create BIP-340 compliant signatures, algo16 must be set\n+ *  to \"BIP0340/nonce\\0\\0\\0\"\n+ */\n+SECP256K1_API extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340;\n+\n+/** Create a Schnorr signature.\n+ *\n+ *  Does _not_ strictly follow BIP-340 because it does not verify the resulting\n+ *  signature. Instead, you can manually use secp256k1_schnorrsig_verify and\n+ *  abort if it fails.\n+ *\n+ *  Otherwise BIP-340 compliant if the noncefp argument is NULL or\n+ *  secp256k1_nonce_function_bip340 and the ndata argument is 32-byte auxiliary\n+ *  randomness.\n+ *\n+ *  Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\n+ *         ndata: pointer to arbitrary data used by the nonce generation\n+ *                function (can be NULL). If it is non-NULL and\n+ *                secp256k1_nonce_function_bip340 is used, then ndata must be a\n+ *                pointer to 32-byte auxiliary randomness as per BIP-340.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_sign(\n+    const secp256k1_context* ctx,\n+    unsigned char *sig64,\n+    const unsigned char *msg32,\n+    const secp256k1_keypair *keypair,\n+    secp256k1_nonce_function_hardened noncefp,\n+    void *ndata\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Verify a Schnorr signature.\n+ *\n+ *  Returns: 1: correct signature\n+ *           0: incorrect signature\n+ *  Args:    ctx: a secp256k1 context object, initialized for verification.\n+ *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n+ *         msg32: the 32-byte message being verified (cannot be NULL)",
      "path": "include/secp256k1_schnorrsig.h",
      "position": 97,
      "original_position": 97,
      "commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "original_commit_id": "f431b3f28ac95a3645ad5a6dc96b878fa30a1de3",
      "in_reply_to_id": 486486320,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, see the post-merge to do list https://github.com/bitcoin-core/secp256k1/pull/558#issuecomment-687871250",
      "created_at": "2020-09-10T16:50:58Z",
      "updated_at": "2020-09-10T16:50:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/558#discussion_r486491020",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/486491020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/558"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 97,
      "original_line": 97,
      "side": "RIGHT"
    }
  ]
}